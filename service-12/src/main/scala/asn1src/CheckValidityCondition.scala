/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang.{ghost => ghostExpr, _}
import stainless.annotation._
import stainless.collection._
import stainless.proof._
import StaticChecks._


def TCheckValidityCondition_IsConstraintValid(pVal: TCheckValidityCondition): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TParameterMask_IsConstraintValid(pVal.mask)
    if ret.isRight then
        ret = TParameterValue_IsConstraintValid(pVal.expectedValue)
    ret
}

def TCheckValidityCondition_Initialize(): TCheckValidityCondition = TCheckValidityCondition(mask = TParameterMask_Initialize(), expectedValue = TParameterValue_Initialize())

@opaque @inlineOnce 
def TCheckValidityCondition_ACN_Encode(pVal: TCheckValidityCondition, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(56L))
    TCheckValidityCondition_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    val CheckValidityCondition_validityParameter_ID = {

        val CheckValidityCondition_validityParameter_ID00 = pVal.expectedValue match
            case TParameterValue.ParameterValue_param1_PRESENT(_) =>TParameter_ID.Tparam1

        val CheckValidityCondition_validityParameter_ID01 = pVal.mask match
            case TParameterMask.ParameterMask_param1_PRESENT(_) =>TParameter_ID.Tparam1


        val CheckValidityCondition_validityParameter_ID = CheckValidityCondition_validityParameter_ID00


        if !((CheckValidityCondition_validityParameter_ID == CheckValidityCondition_validityParameter_ID00) && (CheckValidityCondition_validityParameter_ID == CheckValidityCondition_validityParameter_ID01)) then
            return Left(998)
        CheckValidityCondition_validityParameter_ID
    }
    /* Encode CheckValidityCondition_validityParameter_ID */
    val intVal_CheckValidityCondition_validityParameter_ID = CheckValidityCondition_validityParameter_ID match
        case TParameter_ID.Tparam1 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(0))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 4294967295L)
            bitCountLemma(intVal_CheckValidityCondition_validityParameter_ID)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_32(intVal_CheckValidityCondition_validityParameter_ID)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 56L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode mask */
    CheckValidityCondition_mask_ACN_Encode(codec, pVal, CheckValidityCondition_validityParameter_ID, pVal.mask) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 24L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 48L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = pVal.mask match {
        case TParameterMask.ParameterMask_param1_PRESENT(param1) =>
            16L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Encode expectedValue */
    CheckValidityCondition_expectedValue_ACN_Encode(codec, pVal, CheckValidityCondition_validityParameter_ID, pVal.expectedValue) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 56L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = pVal.expectedValue match {
        case TParameterValue.ParameterValue_param1_PRESENT(param1) =>
            8L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 56L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def CheckValidityCondition_mask_ACN_Encode(codec: ACN, pVal: TCheckValidityCondition, CheckValidityCondition_validityParameter_ID: TParameter_ID, mask: TParameterMask): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(16L))
    @ghost val oldCdc = snapshot(codec)
    TParameterMask_IsConstraintValid(mask) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    mask match
        case TParameterMask.ParameterMask_param1_PRESENT(param1) =>
            assert(16.toInt >= 0) // overflow may happen during cast
            codec.base.bitStream.appendBitsMSBFirstVec(param1.arr, 16.toInt)
    
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + mask.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def CheckValidityCondition_expectedValue_ACN_Encode(codec: ACN, pVal: TCheckValidityCondition, CheckValidityCondition_validityParameter_ID: TParameter_ID, expectedValue: TParameterValue): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(8L))
    @ghost val oldCdc = snapshot(codec)
    TParameterValue_IsConstraintValid(expectedValue) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    expectedValue match
        case TParameterValue.ParameterValue_param1_PRESENT(param1) =>
            codec.enc_Int_PositiveInteger_ConstSize_8(param1)
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + expectedValue.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TCheckValidityCondition_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TCheckValidityCondition] =
{
    require(codec.base.bitStream.validate_offset_bits(56L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode CheckValidityCondition_validityParameter_ID */
    val intVal_CheckValidityCondition_validityParameter_ID = codec.dec_Int_PositiveInteger_ConstSize_big_endian_32()

    val CheckValidityCondition_validityParameter_ID = intVal_CheckValidityCondition_validityParameter_ID.toRaw match
        case 0 => TParameter_ID.Tparam1
        case _ => return LeftMut(ERR_ACN_DECODE_CHECKVALIDITYCONDITION_VALIDITYPARAMETER_ID)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 56L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode mask */
    val pVal_mask = CheckValidityCondition_mask_ACN_Decode(codec, CheckValidityCondition_validityParameter_ID) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 24L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 48L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = pVal_mask match {
        case TParameterMask.ParameterMask_param1_PRESENT(param1) =>
            16L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Decode expectedValue */
    val pVal_expectedValue = CheckValidityCondition_expectedValue_ACN_Decode(codec, CheckValidityCondition_validityParameter_ID) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 56L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = pVal_expectedValue match {
        case TParameterValue.ParameterValue_param1_PRESENT(param1) =>
            8L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 56L)
    }
    val pVal = TCheckValidityCondition(pVal_mask, pVal_expectedValue)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2)
    }

    TCheckValidityCondition_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TCheckValidityCondition](l)
        case Right(_) => RightMut[ErrorCode, TCheckValidityCondition](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TCheckValidityCondition]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TCheckValidityCondition_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TCheckValidityCondition_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TCheckValidityCondition]) =
{
    require(codec.base.bitStream.validate_offset_bits(56L))
    val cpy = snapshot(codec)
    val res = TCheckValidityCondition_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def CheckValidityCondition_mask_ACN_Decode(codec: ACN, CheckValidityCondition_validityParameter_ID: TParameter_ID): EitherMut[Int, TParameterMask] = {
    require(codec.base.bitStream.validate_offset_bits(16L))
    @ghost val oldCdc = snapshot(codec)
    val mask = CheckValidityCondition_validityParameter_ID match
        case TParameter_ID.Tparam1 =>
            val param1 = TParameterMask_param1(codec.base.bitStream.readBitsVec(16.toInt))
            TParameterMask.ParameterMask_param1_PRESENT(param1)
    TParameterMask_IsConstraintValid(mask) match {
        case Left(l) =>
            LeftMut[Int, TParameterMask](l)
        case Right(_) =>
            RightMut[Int, TParameterMask](mask)
    }
}.ensuring { (res: EitherMut[Int, TParameterMask]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TParameterMask_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def CheckValidityCondition_mask_ACN_Decode_pure(codec: ACN, CheckValidityCondition_validityParameter_ID: TParameter_ID): (ACN, EitherMut[Int, TParameterMask]) = {
    require(codec.base.bitStream.validate_offset_bits(16L))
    val cpy = snapshot(codec)
    val res = CheckValidityCondition_mask_ACN_Decode(cpy, CheckValidityCondition_validityParameter_ID)
    (cpy, res)
}

@opaque @inlineOnce
def CheckValidityCondition_expectedValue_ACN_Decode(codec: ACN, CheckValidityCondition_validityParameter_ID: TParameter_ID): EitherMut[Int, TParameterValue] = {
    require(codec.base.bitStream.validate_offset_bits(8L))
    @ghost val oldCdc = snapshot(codec)
    val expectedValue = CheckValidityCondition_validityParameter_ID match
        case TParameter_ID.Tparam1 =>
            val param1 = codec.dec_Int_PositiveInteger_ConstSize_8()
    
            TParameterValue.ParameterValue_param1_PRESENT(param1)
    TParameterValue_IsConstraintValid(expectedValue) match {
        case Left(l) =>
            LeftMut[Int, TParameterValue](l)
        case Right(_) =>
            RightMut[Int, TParameterValue](expectedValue)
    }
}.ensuring { (res: EitherMut[Int, TParameterValue]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TParameterValue_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def CheckValidityCondition_expectedValue_ACN_Decode_pure(codec: ACN, CheckValidityCondition_validityParameter_ID: TParameter_ID): (ACN, EitherMut[Int, TParameterValue]) = {
    require(codec.base.bitStream.validate_offset_bits(8L))
    val cpy = snapshot(codec)
    val res = CheckValidityCondition_expectedValue_ACN_Decode(cpy, CheckValidityCondition_validityParameter_ID)
    (cpy, res)
}