/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang._
import stainless.annotation._
import stainless.collection._
import stainless.proof._
import StaticChecks._

sealed trait TPMON_ID:
    def i: Int
object TPMON_ID:
    case object Tparam0 extends TPMON_ID:
        override def i: Int = 0

// please use the following macros to avoid breaking code.
// type Tparam0 = TPMON_ID.param0

@inline @cCode.inline val ERR_PMON_ID: Int = 881 /*param0 */

 

@inline @cCode.inline val ERR_ACN_ENCODE_PMON_ID: Int = 884 /*  */
@inline @cCode.inline val TPMON_ID_REQUIRED_BYTES_FOR_ACN_ENCODING = 4
@inline @cCode.inline val TPMON_ID_REQUIRED_BITS_FOR_ACN_ENCODING = 32

@inline @cCode.inline val ERR_ACN_DECODE_PMON_ID: Int = 885 /*  */
/*-- TPMON_ParameterValue --------------------------------------------*/
type TPMON_ParameterValue_param0 = ULong


enum TPMON_ParameterValue:
    case PMON_ParameterValue_param0_PRESENT(param0: TPMON_ParameterValue_param0)

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775799L))
        this match {
            case TPMON_ParameterValue.PMON_ParameterValue_param0_PRESENT(param0) =>
                8L
        }
    }.ensuring { (res: Long) => 
        res == 8L
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775799L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775799L))
        this match {
            case TPMON_ParameterValue.PMON_ParameterValue_param0_PRESENT(param0) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775799L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775799L))
        require((offset % 8L) == (otherOffset % 8L))
        this match {
            case TPMON_ParameterValue.PMON_ParameterValue_param0_PRESENT(param0) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775799L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775799L))
        require((offset % 16L) == (otherOffset % 16L))
        this match {
            case TPMON_ParameterValue.PMON_ParameterValue_param0_PRESENT(param0) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775799L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775799L))
        require((offset % 32L) == (otherOffset % 32L))
        this match {
            case TPMON_ParameterValue.PMON_ParameterValue_param0_PRESENT(param0) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

@inline @cCode.inline val ERR_PMON_PARAMETERVALUE_PARAM0: Int = 886 /*(0 .. 255) */

@inline @cCode.inline val ERR_PMON_PARAMETERVALUE: Int = 891 /* */

 
 
/*-- TPMON_Mask --------------------------------------------*/

case class TPMON_Mask_param0(arr: Vector[UByte])
{
    require(this.arr.length == 32)
}

enum TPMON_Mask:
    case PMON_Mask_param0_PRESENT(param0: TPMON_Mask_param0)

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775552L))
        this match {
            case TPMON_Mask.PMON_Mask_param0_PRESENT(param0) =>
                255L
        }
    }.ensuring { (res: Long) => 
        res == 255L
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775552L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775552L))
        this match {
            case TPMON_Mask.PMON_Mask_param0_PRESENT(param0) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775552L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775552L))
        require((offset % 8L) == (otherOffset % 8L))
        this match {
            case TPMON_Mask.PMON_Mask_param0_PRESENT(param0) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775552L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775552L))
        require((offset % 16L) == (otherOffset % 16L))
        this match {
            case TPMON_Mask.PMON_Mask_param0_PRESENT(param0) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775552L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775552L))
        require((offset % 32L) == (otherOffset % 32L))
        this match {
            case TPMON_Mask.PMON_Mask_param0_PRESENT(param0) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

@inline @cCode.inline val ERR_PMON_MASK_PARAM0: Int = 922 /*(SIZE(255)) */

@inline @cCode.inline val ERR_PMON_MASK: Int = 927 /* */

 
 
/*-- TPMON_LimitCrossed --------------------------------------------*/
type TPMON_LimitCrossed_param0 = ULong


enum TPMON_LimitCrossed:
    case PMON_LimitCrossed_param0_PRESENT(param0: TPMON_LimitCrossed_param0)

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775799L))
        this match {
            case TPMON_LimitCrossed.PMON_LimitCrossed_param0_PRESENT(param0) =>
                8L
        }
    }.ensuring { (res: Long) => 
        res == 8L
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775799L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775799L))
        this match {
            case TPMON_LimitCrossed.PMON_LimitCrossed_param0_PRESENT(param0) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775799L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775799L))
        require((offset % 8L) == (otherOffset % 8L))
        this match {
            case TPMON_LimitCrossed.PMON_LimitCrossed_param0_PRESENT(param0) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775799L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775799L))
        require((offset % 16L) == (otherOffset % 16L))
        this match {
            case TPMON_LimitCrossed.PMON_LimitCrossed_param0_PRESENT(param0) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775799L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775799L))
        require((offset % 32L) == (otherOffset % 32L))
        this match {
            case TPMON_LimitCrossed.PMON_LimitCrossed_param0_PRESENT(param0) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

@inline @cCode.inline val ERR_PMON_LIMITCROSSED_PARAM0: Int = 937 /*(0 .. 255) */

@inline @cCode.inline val ERR_PMON_LIMITCROSSED: Int = 942 /* */

 
 
sealed trait TPMON_CheckType:
    def i: Int
object TPMON_CheckType:
    case object TexpectedValueChecking extends TPMON_CheckType:
        override def i: Int = 0
    case object TlimitChecking extends TPMON_CheckType:
        override def i: Int = 1
    case object TdeltaChecking extends TPMON_CheckType:
        override def i: Int = 2

// please use the following macros to avoid breaking code.
// type TexpectedValueChecking = TPMON_CheckType.expectedValueChecking
// type TlimitChecking = TPMON_CheckType.limitChecking
// type TdeltaChecking = TPMON_CheckType.deltaChecking

@inline @cCode.inline val ERR_PMON_CHECKTYPE: Int = 932 /*expectedValueChecking | limitChecking | deltaChecking */

 

@inline @cCode.inline val ERR_ACN_ENCODE_PMON_CHECKTYPE: Int = 935 /*  */
@inline @cCode.inline val TPMON_CheckType_REQUIRED_BYTES_FOR_ACN_ENCODING = 1
@inline @cCode.inline val TPMON_CheckType_REQUIRED_BITS_FOR_ACN_ENCODING = 2

@inline @cCode.inline val ERR_ACN_DECODE_PMON_CHECKTYPE: Int = 936 /*  */
/*-- TPMON_ExpectedValueCheckMask --------------------------------------------*/

enum TPMON_ExpectedValueCheckMask:
    case PMON_ExpectedValueCheckMask_expectedValueChecking_PRESENT(expectedValueChecking: TPMON_Mask)
    case PMON_ExpectedValueCheckMask_limitChecking_PRESENT(limitChecking: NullType)
    case PMON_ExpectedValueCheckMask_deltaChecking_PRESENT(deltaChecking: NullType)

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775552L))
        this match {
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_expectedValueChecking_PRESENT(expectedValueChecking) =>
                expectedValueChecking match {
                    case TPMON_Mask.PMON_Mask_param0_PRESENT(param0) =>
                        255L
                }
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_limitChecking_PRESENT(limitChecking) =>
                0L
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_deltaChecking_PRESENT(deltaChecking) =>
                0L
        }
    }.ensuring { (res: Long) => 
        (0L <= res) && (res <= 255L)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775552L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775552L))
        this match {
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_expectedValueChecking_PRESENT(expectedValueChecking) =>
                expectedValueChecking.sizeLemmaAnyOffset(offset, otherOffset)
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_limitChecking_PRESENT(limitChecking) =>
                ()
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_deltaChecking_PRESENT(deltaChecking) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775552L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775552L))
        require((offset % 8L) == (otherOffset % 8L))
        this match {
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_expectedValueChecking_PRESENT(expectedValueChecking) =>
                expectedValueChecking.sizeLemmaNextByte(offset, otherOffset)
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_limitChecking_PRESENT(limitChecking) =>
                ()
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_deltaChecking_PRESENT(deltaChecking) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775552L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775552L))
        require((offset % 16L) == (otherOffset % 16L))
        this match {
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_expectedValueChecking_PRESENT(expectedValueChecking) =>
                expectedValueChecking.sizeLemmaNextWord(offset, otherOffset)
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_limitChecking_PRESENT(limitChecking) =>
                ()
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_deltaChecking_PRESENT(deltaChecking) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775552L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775552L))
        require((offset % 32L) == (otherOffset % 32L))
        this match {
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_expectedValueChecking_PRESENT(expectedValueChecking) =>
                expectedValueChecking.sizeLemmaNextDWord(offset, otherOffset)
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_limitChecking_PRESENT(limitChecking) =>
                ()
            case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_deltaChecking_PRESENT(deltaChecking) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

@inline @cCode.inline val ERR_PMON_EXPECTEDVALUECHECKMASK: Int = 917 /* */
@inline @cCode.inline val ERR_PMON_EXPECTEDVALUECHECKMASK_EXPECTEDVALUECHECKING_2: Int = 906 /* */

 
sealed trait TCheckingStatusForExpectedValueChecking:
    def i: Int
object TCheckingStatusForExpectedValueChecking:
    case object TexpectedValue extends TCheckingStatusForExpectedValueChecking:
        override def i: Int = 0
    case object TCheckingStatusForExpectedValueChecking_unchecked extends TCheckingStatusForExpectedValueChecking:
        override def i: Int = 1
    case object TCheckingStatusForExpectedValueChecking_invalid extends TCheckingStatusForExpectedValueChecking:
        override def i: Int = 2
    case object TunexpectedValue extends TCheckingStatusForExpectedValueChecking:
        override def i: Int = 3

// please use the following macros to avoid breaking code.
// type TexpectedValue = TCheckingStatusForExpectedValueChecking.expectedValue
// type TCheckingStatusForExpectedValueChecking_unchecked = TCheckingStatusForExpectedValueChecking.unchecked
// type TCheckingStatusForExpectedValueChecking_invalid = TCheckingStatusForExpectedValueChecking.invalid
// type TunexpectedValue = TCheckingStatusForExpectedValueChecking.unexpectedValue

@inline @cCode.inline val ERR_CHECKINGSTATUSFOREXPECTEDVALUECHECKING: Int = 982 /*expectedValue | unchecked | invalid | unexpectedValue */

 

@inline @cCode.inline val ERR_ACN_ENCODE_CHECKINGSTATUSFOREXPECTEDVALUECHECKING: Int = 985 /*  */
@inline @cCode.inline val TCheckingStatusForExpectedValueChecking_REQUIRED_BYTES_FOR_ACN_ENCODING = 1
@inline @cCode.inline val TCheckingStatusForExpectedValueChecking_REQUIRED_BITS_FOR_ACN_ENCODING = 2

@inline @cCode.inline val ERR_ACN_DECODE_CHECKINGSTATUSFOREXPECTEDVALUECHECKING: Int = 986 /*  */
sealed trait TCheckingStatusForLimitChecking:
    def i: Int
object TCheckingStatusForLimitChecking:
    case object TwithinLimits extends TCheckingStatusForLimitChecking:
        override def i: Int = 0
    case object TCheckingStatusForLimitChecking_unchecked extends TCheckingStatusForLimitChecking:
        override def i: Int = 1
    case object TCheckingStatusForLimitChecking_invalid extends TCheckingStatusForLimitChecking:
        override def i: Int = 2
    case object TbelowLowLimit extends TCheckingStatusForLimitChecking:
        override def i: Int = 3
    case object TaboveHighLimit extends TCheckingStatusForLimitChecking:
        override def i: Int = 4

// please use the following macros to avoid breaking code.
// type TwithinLimits = TCheckingStatusForLimitChecking.withinLimits
// type TCheckingStatusForLimitChecking_unchecked = TCheckingStatusForLimitChecking.unchecked
// type TCheckingStatusForLimitChecking_invalid = TCheckingStatusForLimitChecking.invalid
// type TbelowLowLimit = TCheckingStatusForLimitChecking.belowLowLimit
// type TaboveHighLimit = TCheckingStatusForLimitChecking.aboveHighLimit

@inline @cCode.inline val ERR_CHECKINGSTATUSFORLIMITCHECKING: Int = 987 /*withinLimits | unchecked | invalid | belowLowLimit | aboveHighLimit */

 

@inline @cCode.inline val ERR_ACN_ENCODE_CHECKINGSTATUSFORLIMITCHECKING: Int = 990 /*  */
@inline @cCode.inline val TCheckingStatusForLimitChecking_REQUIRED_BYTES_FOR_ACN_ENCODING = 1
@inline @cCode.inline val TCheckingStatusForLimitChecking_REQUIRED_BITS_FOR_ACN_ENCODING = 3

@inline @cCode.inline val ERR_ACN_DECODE_CHECKINGSTATUSFORLIMITCHECKING: Int = 991 /*  */
sealed trait TCheckingStatusForDeltaChecking:
    def i: Int
object TCheckingStatusForDeltaChecking:
    case object TwithinThresholds extends TCheckingStatusForDeltaChecking:
        override def i: Int = 0
    case object TCheckingStatusForDeltaChecking_unchecked extends TCheckingStatusForDeltaChecking:
        override def i: Int = 1
    case object TCheckingStatusForDeltaChecking_invalid extends TCheckingStatusForDeltaChecking:
        override def i: Int = 2
    case object TbelowLowTreshold extends TCheckingStatusForDeltaChecking:
        override def i: Int = 3
    case object TaboveHighTreshold extends TCheckingStatusForDeltaChecking:
        override def i: Int = 4

// please use the following macros to avoid breaking code.
// type TwithinThresholds = TCheckingStatusForDeltaChecking.withinThresholds
// type TCheckingStatusForDeltaChecking_unchecked = TCheckingStatusForDeltaChecking.unchecked
// type TCheckingStatusForDeltaChecking_invalid = TCheckingStatusForDeltaChecking.invalid
// type TbelowLowTreshold = TCheckingStatusForDeltaChecking.belowLowTreshold
// type TaboveHighTreshold = TCheckingStatusForDeltaChecking.aboveHighTreshold

@inline @cCode.inline val ERR_CHECKINGSTATUSFORDELTACHECKING: Int = 992 /*withinThresholds | unchecked | invalid | belowLowTreshold | aboveHighTreshold */

 

@inline @cCode.inline val ERR_ACN_ENCODE_CHECKINGSTATUSFORDELTACHECKING: Int = 995 /*  */
@inline @cCode.inline val TCheckingStatusForDeltaChecking_REQUIRED_BYTES_FOR_ACN_ENCODING = 1
@inline @cCode.inline val TCheckingStatusForDeltaChecking_REQUIRED_BITS_FOR_ACN_ENCODING = 3

@inline @cCode.inline val ERR_ACN_DECODE_CHECKINGSTATUSFORDELTACHECKING: Int = 996 /*  */
/*-- TPMON_CheckingStatus --------------------------------------------*/

enum TPMON_CheckingStatus:
    case PMON_CheckingStatus_expectedValueChecking_PRESENT(expectedValueChecking: TCheckingStatusForExpectedValueChecking)
    case PMON_CheckingStatus_limitChecking_PRESENT(limitChecking: TCheckingStatusForLimitChecking)
    case PMON_CheckingStatus_deltaChecking_PRESENT(deltaChecking: TCheckingStatusForDeltaChecking)

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775804L))
        this match {
            case TPMON_CheckingStatus.PMON_CheckingStatus_expectedValueChecking_PRESENT(expectedValueChecking) =>
                2L
            case TPMON_CheckingStatus.PMON_CheckingStatus_limitChecking_PRESENT(limitChecking) =>
                3L
            case TPMON_CheckingStatus.PMON_CheckingStatus_deltaChecking_PRESENT(deltaChecking) =>
                3L
        }
    }.ensuring { (res: Long) => 
        (0L <= res) && (res <= 3L)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775804L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775804L))
        this match {
            case TPMON_CheckingStatus.PMON_CheckingStatus_expectedValueChecking_PRESENT(expectedValueChecking) =>
                ()
            case TPMON_CheckingStatus.PMON_CheckingStatus_limitChecking_PRESENT(limitChecking) =>
                ()
            case TPMON_CheckingStatus.PMON_CheckingStatus_deltaChecking_PRESENT(deltaChecking) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775804L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775804L))
        require((offset % 8L) == (otherOffset % 8L))
        this match {
            case TPMON_CheckingStatus.PMON_CheckingStatus_expectedValueChecking_PRESENT(expectedValueChecking) =>
                ()
            case TPMON_CheckingStatus.PMON_CheckingStatus_limitChecking_PRESENT(limitChecking) =>
                ()
            case TPMON_CheckingStatus.PMON_CheckingStatus_deltaChecking_PRESENT(deltaChecking) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775804L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775804L))
        require((offset % 16L) == (otherOffset % 16L))
        this match {
            case TPMON_CheckingStatus.PMON_CheckingStatus_expectedValueChecking_PRESENT(expectedValueChecking) =>
                ()
            case TPMON_CheckingStatus.PMON_CheckingStatus_limitChecking_PRESENT(limitChecking) =>
                ()
            case TPMON_CheckingStatus.PMON_CheckingStatus_deltaChecking_PRESENT(deltaChecking) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775804L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775804L))
        require((offset % 32L) == (otherOffset % 32L))
        this match {
            case TPMON_CheckingStatus.PMON_CheckingStatus_expectedValueChecking_PRESENT(expectedValueChecking) =>
                ()
            case TPMON_CheckingStatus.PMON_CheckingStatus_limitChecking_PRESENT(limitChecking) =>
                ()
            case TPMON_CheckingStatus.PMON_CheckingStatus_deltaChecking_PRESENT(deltaChecking) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

@inline @cCode.inline val ERR_PMON_CHECKINGSTATUS: Int = 977 /* */
@inline @cCode.inline val ERR_PMON_CHECKINGSTATUS_EXPECTEDVALUECHECKING_2: Int = 952 /* */
@inline @cCode.inline val ERR_PMON_CHECKINGSTATUS_LIMITCHECKING_2: Int = 962 /* */
@inline @cCode.inline val ERR_PMON_CHECKINGSTATUS_DELTACHECKING_2: Int = 972 /* */

 
sealed trait TPMON_Status:
    def i: Int
object TPMON_Status:
    case object TPMON_Status_disabled extends TPMON_Status:
        override def i: Int = 0
    case object TPMON_Status_enabled extends TPMON_Status:
        override def i: Int = 1

// please use the following macros to avoid breaking code.
// type TPMON_Status_disabled = TPMON_Status.disabled
// type TPMON_Status_enabled = TPMON_Status.enabled

@inline @cCode.inline val ERR_PMON_STATUS: Int = 997 /*disabled | enabled */

 

@inline @cCode.inline val ERR_ACN_ENCODE_PMON_STATUS: Int = 1000 /*  */
@inline @cCode.inline val TPMON_Status_REQUIRED_BYTES_FOR_ACN_ENCODING = 1
@inline @cCode.inline val TPMON_Status_REQUIRED_BITS_FOR_ACN_ENCODING = 1

@inline @cCode.inline val ERR_ACN_DECODE_PMON_STATUS: Int = 1001 /*  */


