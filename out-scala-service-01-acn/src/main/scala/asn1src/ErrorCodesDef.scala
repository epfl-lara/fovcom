/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang._
import stainless.annotation._
import stainless.collection._
import stainless.proof._
import StaticChecks._

sealed trait TAcceptanceFailureCode:
    def i: Int
object TAcceptanceFailureCode:
    case object TAcceptanceFailureCode_error1 extends TAcceptanceFailureCode:
        override def i: Int = 1

// please use the following macros to avoid breaking code.
// type TAcceptanceFailureCode_error1 = TAcceptanceFailureCode.error1

@inline @cCode.inline val ERR_ACCEPTANCEFAILURECODE: Int = 1 /*error1 */

 

@inline @cCode.inline val ERR_ACN_ENCODE_ACCEPTANCEFAILURECODE: Int = 4 /*  */
@inline @cCode.inline val TAcceptanceFailureCode_REQUIRED_BYTES_FOR_ACN_ENCODING = 0
@inline @cCode.inline val TAcceptanceFailureCode_REQUIRED_BITS_FOR_ACN_ENCODING = 0

@inline @cCode.inline val ERR_ACN_DECODE_ACCEPTANCEFAILURECODE: Int = 5 /*  */
/*-- TAcceptanceFailureData --------------------------------------------*/

case class TAcceptanceFailureData_error1(arr: Vector[UByte])
{
    require(this.arr.length == 1)
}

enum TAcceptanceFailureData:
    case AcceptanceFailureData_error1_PRESENT(error1: TAcceptanceFailureData_error1)

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        this match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                1L
        }
    }.ensuring { (res: Long) => 
        res == 1L
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        this match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 8L) == (otherOffset % 8L))
        this match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 16L) == (otherOffset % 16L))
        this match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 32L) == (otherOffset % 32L))
        this match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

@inline @cCode.inline val ERR_ACCEPTANCEFAILUREDATA_ERROR1: Int = 6 /*(SIZE(1)) */

@inline @cCode.inline val ERR_ACCEPTANCEFAILUREDATA: Int = 11 /* */

 
 
/*-- TAcceptanceFailureNotice --------------------------------------------*/

case class TAcceptanceFailureNotice (
    data: TAcceptanceFailureData
) {

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        val size_0 = 0L
        val size_1 = this.data match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                1L
        }
        size_0 + size_1
    }.ensuring { (res: Long) => 
        res == 1L
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaAnyOffset(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 8L) == (otherOffset % 8L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextByte(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 16L) == (otherOffset % 16L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextWord(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 32L) == (otherOffset % 32L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextDWord(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }
}


@inline @cCode.inline val ERR_ACCEPTANCEFAILURENOTICE: Int = 31 /* */
@inline @cCode.inline val ERR_ACCEPTANCEFAILURENOTICE_DATA_2: Int = 28 /* */

 

@inline @cCode.inline val ERR_ACN_ENCODE_ACCEPTANCEFAILURENOTICE: Int = 34 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_ACCEPTANCEFAILURENOTICE_CODE_UNINITIALIZED: Int = 35 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_ACCEPTANCEFAILURENOTICE_CODE: Int = 16 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_ACCEPTANCEFAILURENOTICE_DATA: Int = 26 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_ACCEPTANCEFAILURENOTICE_DATA_ERROR1: Int = 21 /*  */
@inline @cCode.inline val TAcceptanceFailureNotice_REQUIRED_BYTES_FOR_ACN_ENCODING = 1
@inline @cCode.inline val TAcceptanceFailureNotice_REQUIRED_BITS_FOR_ACN_ENCODING = 1

@inline @cCode.inline val ERR_ACN_DECODE_ACCEPTANCEFAILURENOTICE: Int = 36 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_ACCEPTANCEFAILURENOTICE_CODE: Int = 17 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_ACCEPTANCEFAILURENOTICE_DATA: Int = 27 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_ACCEPTANCEFAILURENOTICE_DATA_ERROR1: Int = 22 /*  */
sealed trait TExecutionStartFailureCode:
    def i: Int
object TExecutionStartFailureCode:
    case object TExecutionStartFailureCode_error1 extends TExecutionStartFailureCode:
        override def i: Int = 1

// please use the following macros to avoid breaking code.
// type TExecutionStartFailureCode_error1 = TExecutionStartFailureCode.error1

@inline @cCode.inline val ERR_EXECUTIONSTARTFAILURECODE: Int = 37 /*error1 */

 

@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONSTARTFAILURECODE: Int = 40 /*  */
@inline @cCode.inline val TExecutionStartFailureCode_REQUIRED_BYTES_FOR_ACN_ENCODING = 0
@inline @cCode.inline val TExecutionStartFailureCode_REQUIRED_BITS_FOR_ACN_ENCODING = 0

@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONSTARTFAILURECODE: Int = 41 /*  */
/*-- TExecutionStartFailureData --------------------------------------------*/

case class TExecutionStartFailureData_error1(arr: Vector[UByte])
{
    require(this.arr.length == 1)
}

enum TExecutionStartFailureData:
    case ExecutionStartFailureData_error1_PRESENT(error1: TExecutionStartFailureData_error1)

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        this match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                1L
        }
    }.ensuring { (res: Long) => 
        res == 1L
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        this match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 8L) == (otherOffset % 8L))
        this match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 16L) == (otherOffset % 16L))
        this match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 32L) == (otherOffset % 32L))
        this match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

@inline @cCode.inline val ERR_EXECUTIONSTARTFAILUREDATA_ERROR1: Int = 42 /*(SIZE(1)) */

@inline @cCode.inline val ERR_EXECUTIONSTARTFAILUREDATA: Int = 47 /* */

 
 
/*-- TExecutionStartFailureNotice --------------------------------------------*/

case class TExecutionStartFailureNotice (
    data: TExecutionStartFailureData
) {

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        val size_0 = 0L
        val size_1 = this.data match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                1L
        }
        size_0 + size_1
    }.ensuring { (res: Long) => 
        res == 1L
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaAnyOffset(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 8L) == (otherOffset % 8L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextByte(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 16L) == (otherOffset % 16L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextWord(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 32L) == (otherOffset % 32L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextDWord(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }
}


@inline @cCode.inline val ERR_EXECUTIONSTARTFAILURENOTICE: Int = 67 /* */
@inline @cCode.inline val ERR_EXECUTIONSTARTFAILURENOTICE_DATA_2: Int = 64 /* */

 

@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONSTARTFAILURENOTICE: Int = 70 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONSTARTFAILURENOTICE_CODE_UNINITIALIZED: Int = 71 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONSTARTFAILURENOTICE_CODE: Int = 52 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONSTARTFAILURENOTICE_DATA: Int = 62 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONSTARTFAILURENOTICE_DATA_ERROR1: Int = 57 /*  */
@inline @cCode.inline val TExecutionStartFailureNotice_REQUIRED_BYTES_FOR_ACN_ENCODING = 1
@inline @cCode.inline val TExecutionStartFailureNotice_REQUIRED_BITS_FOR_ACN_ENCODING = 1

@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONSTARTFAILURENOTICE: Int = 72 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONSTARTFAILURENOTICE_CODE: Int = 53 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONSTARTFAILURENOTICE_DATA: Int = 63 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONSTARTFAILURENOTICE_DATA_ERROR1: Int = 58 /*  */
sealed trait TExecutionProgressFailureCode:
    def i: Int
object TExecutionProgressFailureCode:
    case object TExecutionProgressFailureCode_error1 extends TExecutionProgressFailureCode:
        override def i: Int = 1

// please use the following macros to avoid breaking code.
// type TExecutionProgressFailureCode_error1 = TExecutionProgressFailureCode.error1

@inline @cCode.inline val ERR_EXECUTIONPROGRESSFAILURECODE: Int = 73 /*error1 */

 

@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONPROGRESSFAILURECODE: Int = 76 /*  */
@inline @cCode.inline val TExecutionProgressFailureCode_REQUIRED_BYTES_FOR_ACN_ENCODING = 0
@inline @cCode.inline val TExecutionProgressFailureCode_REQUIRED_BITS_FOR_ACN_ENCODING = 0

@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONPROGRESSFAILURECODE: Int = 77 /*  */
/*-- TExecutionProgressFailureData --------------------------------------------*/

case class TExecutionProgressFailureData_error1(arr: Vector[UByte])
{
    require(this.arr.length == 1)
}

enum TExecutionProgressFailureData:
    case ExecutionProgressFailureData_error1_PRESENT(error1: TExecutionProgressFailureData_error1)

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        this match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                1L
        }
    }.ensuring { (res: Long) => 
        res == 1L
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        this match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 8L) == (otherOffset % 8L))
        this match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 16L) == (otherOffset % 16L))
        this match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 32L) == (otherOffset % 32L))
        this match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

@inline @cCode.inline val ERR_EXECUTIONPROGRESSFAILUREDATA_ERROR1: Int = 78 /*(SIZE(1)) */

@inline @cCode.inline val ERR_EXECUTIONPROGRESSFAILUREDATA: Int = 83 /* */

 
 
/*-- TExecutionProgressFailureNotice --------------------------------------------*/

case class TExecutionProgressFailureNotice (
    data: TExecutionProgressFailureData
) {

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        val size_0 = 0L
        val size_1 = this.data match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                1L
        }
        size_0 + size_1
    }.ensuring { (res: Long) => 
        res == 1L
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaAnyOffset(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 8L) == (otherOffset % 8L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextByte(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 16L) == (otherOffset % 16L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextWord(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 32L) == (otherOffset % 32L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextDWord(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }
}


@inline @cCode.inline val ERR_EXECUTIONPROGRESSFAILURENOTICE: Int = 103 /* */
@inline @cCode.inline val ERR_EXECUTIONPROGRESSFAILURENOTICE_DATA_2: Int = 100 /* */

 

@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONPROGRESSFAILURENOTICE: Int = 106 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONPROGRESSFAILURENOTICE_CODE_UNINITIALIZED: Int = 107 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONPROGRESSFAILURENOTICE_CODE: Int = 88 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONPROGRESSFAILURENOTICE_DATA: Int = 98 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONPROGRESSFAILURENOTICE_DATA_ERROR1: Int = 93 /*  */
@inline @cCode.inline val TExecutionProgressFailureNotice_REQUIRED_BYTES_FOR_ACN_ENCODING = 1
@inline @cCode.inline val TExecutionProgressFailureNotice_REQUIRED_BITS_FOR_ACN_ENCODING = 1

@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONPROGRESSFAILURENOTICE: Int = 108 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONPROGRESSFAILURENOTICE_CODE: Int = 89 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONPROGRESSFAILURENOTICE_DATA: Int = 99 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONPROGRESSFAILURENOTICE_DATA_ERROR1: Int = 94 /*  */
sealed trait TExecutionCompletionFailureCode:
    def i: Int
object TExecutionCompletionFailureCode:
    case object TExecutionCompletionFailureCode_error1 extends TExecutionCompletionFailureCode:
        override def i: Int = 1

// please use the following macros to avoid breaking code.
// type TExecutionCompletionFailureCode_error1 = TExecutionCompletionFailureCode.error1

@inline @cCode.inline val ERR_EXECUTIONCOMPLETIONFAILURECODE: Int = 109 /*error1 */

 

@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONCOMPLETIONFAILURECODE: Int = 112 /*  */
@inline @cCode.inline val TExecutionCompletionFailureCode_REQUIRED_BYTES_FOR_ACN_ENCODING = 0
@inline @cCode.inline val TExecutionCompletionFailureCode_REQUIRED_BITS_FOR_ACN_ENCODING = 0

@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONCOMPLETIONFAILURECODE: Int = 113 /*  */
/*-- TExecutionCompletionFailureData --------------------------------------------*/

case class TExecutionCompletionFailureData_error1(arr: Vector[UByte])
{
    require(this.arr.length == 1)
}

enum TExecutionCompletionFailureData:
    case ExecutionCompletionFailureData_error1_PRESENT(error1: TExecutionCompletionFailureData_error1)

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        this match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                1L
        }
    }.ensuring { (res: Long) => 
        res == 1L
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        this match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 8L) == (otherOffset % 8L))
        this match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 16L) == (otherOffset % 16L))
        this match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 32L) == (otherOffset % 32L))
        this match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

@inline @cCode.inline val ERR_EXECUTIONCOMPLETIONFAILUREDATA_ERROR1: Int = 114 /*(SIZE(1)) */

@inline @cCode.inline val ERR_EXECUTIONCOMPLETIONFAILUREDATA: Int = 119 /* */

 
 
/*-- TExecutionCompletionFailureNotice --------------------------------------------*/

case class TExecutionCompletionFailureNotice (
    data: TExecutionCompletionFailureData
) {

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        val size_0 = 0L
        val size_1 = this.data match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                1L
        }
        size_0 + size_1
    }.ensuring { (res: Long) => 
        res == 1L
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaAnyOffset(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 8L) == (otherOffset % 8L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextByte(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 16L) == (otherOffset % 16L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextWord(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 32L) == (otherOffset % 32L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextDWord(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }
}


@inline @cCode.inline val ERR_EXECUTIONCOMPLETIONFAILURENOTICE: Int = 139 /* */
@inline @cCode.inline val ERR_EXECUTIONCOMPLETIONFAILURENOTICE_DATA_2: Int = 136 /* */

 

@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONCOMPLETIONFAILURENOTICE: Int = 142 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONCOMPLETIONFAILURENOTICE_CODE_UNINITIALIZED: Int = 143 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONCOMPLETIONFAILURENOTICE_CODE: Int = 124 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONCOMPLETIONFAILURENOTICE_DATA: Int = 134 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_EXECUTIONCOMPLETIONFAILURENOTICE_DATA_ERROR1: Int = 129 /*  */
@inline @cCode.inline val TExecutionCompletionFailureNotice_REQUIRED_BYTES_FOR_ACN_ENCODING = 1
@inline @cCode.inline val TExecutionCompletionFailureNotice_REQUIRED_BITS_FOR_ACN_ENCODING = 1

@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONCOMPLETIONFAILURENOTICE: Int = 144 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONCOMPLETIONFAILURENOTICE_CODE: Int = 125 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONCOMPLETIONFAILURENOTICE_DATA: Int = 135 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_EXECUTIONCOMPLETIONFAILURENOTICE_DATA_ERROR1: Int = 130 /*  */
sealed trait TRoutingFailureCode:
    def i: Int
object TRoutingFailureCode:
    case object TRoutingFailureCode_error1 extends TRoutingFailureCode:
        override def i: Int = 1

// please use the following macros to avoid breaking code.
// type TRoutingFailureCode_error1 = TRoutingFailureCode.error1

@inline @cCode.inline val ERR_ROUTINGFAILURECODE: Int = 145 /*error1 */

 

@inline @cCode.inline val ERR_ACN_ENCODE_ROUTINGFAILURECODE: Int = 148 /*  */
@inline @cCode.inline val TRoutingFailureCode_REQUIRED_BYTES_FOR_ACN_ENCODING = 0
@inline @cCode.inline val TRoutingFailureCode_REQUIRED_BITS_FOR_ACN_ENCODING = 0

@inline @cCode.inline val ERR_ACN_DECODE_ROUTINGFAILURECODE: Int = 149 /*  */
/*-- TRoutingFailureData --------------------------------------------*/

case class TRoutingFailureData_error1(arr: Vector[UByte])
{
    require(this.arr.length == 1)
}

enum TRoutingFailureData:
    case RoutingFailureData_error1_PRESENT(error1: TRoutingFailureData_error1)

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        this match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                1L
        }
    }.ensuring { (res: Long) => 
        res == 1L
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        this match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 8L) == (otherOffset % 8L))
        this match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 16L) == (otherOffset % 16L))
        this match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 32L) == (otherOffset % 32L))
        this match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                ()
        }
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

@inline @cCode.inline val ERR_ROUTINGFAILUREDATA_ERROR1: Int = 150 /*(SIZE(1)) */

@inline @cCode.inline val ERR_ROUTINGFAILUREDATA: Int = 155 /* */

 
 
/*-- TRoutingFailureNotice --------------------------------------------*/

case class TRoutingFailureNotice (
    data: TRoutingFailureData
) {

    def size(offset: Long): Long = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        val size_0 = 0L
        val size_1 = this.data match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                1L
        }
        size_0 + size_1
    }.ensuring { (res: Long) => 
        res == 1L
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaAnyOffset(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaAnyOffset(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextByte(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 8L) == (otherOffset % 8L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextByte(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 16L) == (otherOffset % 16L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextWord(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }

    @ghost @opaque @inlineOnce
    def sizeLemmaNextDWord(offset: Long, otherOffset: Long): Unit = {
        require((0L <= offset) && (offset <= 9223372036854775806L))
        require((0L <= otherOffset) && (otherOffset <= 9223372036854775806L))
        require((offset % 32L) == (otherOffset % 32L))
        val size_0_offset = 0L
        val size_0_otherOffset = 0L
        val size_1_offset = this.data match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                1L
        }
        val size_1_otherOffset = this.data match {
            case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
                1L
        }
        this.data.sizeLemmaNextDWord(offset + size_0_offset, otherOffset + size_0_otherOffset)
        ()
    }.ensuring { (res: Unit) => 
        this.size(offset) == this.size(otherOffset)
    }
}


@inline @cCode.inline val ERR_ROUTINGFAILURENOTICE: Int = 175 /* */
@inline @cCode.inline val ERR_ROUTINGFAILURENOTICE_DATA_2: Int = 172 /* */

 

@inline @cCode.inline val ERR_ACN_ENCODE_ROUTINGFAILURENOTICE: Int = 178 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_ROUTINGFAILURENOTICE_CODE_UNINITIALIZED: Int = 179 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_ROUTINGFAILURENOTICE_CODE: Int = 160 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_ROUTINGFAILURENOTICE_DATA: Int = 170 /*  */
@inline @cCode.inline val ERR_ACN_ENCODE_ROUTINGFAILURENOTICE_DATA_ERROR1: Int = 165 /*  */
@inline @cCode.inline val TRoutingFailureNotice_REQUIRED_BYTES_FOR_ACN_ENCODING = 1
@inline @cCode.inline val TRoutingFailureNotice_REQUIRED_BITS_FOR_ACN_ENCODING = 1

@inline @cCode.inline val ERR_ACN_DECODE_ROUTINGFAILURENOTICE: Int = 180 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_ROUTINGFAILURENOTICE_CODE: Int = 161 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_ROUTINGFAILURENOTICE_DATA: Int = 171 /*  */
@inline @cCode.inline val ERR_ACN_DECODE_ROUTINGFAILURENOTICE_DATA_ERROR1: Int = 166 /*  */


