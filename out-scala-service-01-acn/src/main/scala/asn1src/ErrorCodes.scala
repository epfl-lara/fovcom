/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang.{ghost => ghostExpr, _}
import stainless.annotation._
import stainless.collection._
import stainless.proof._
import StaticChecks._


def TAcceptanceFailureCode_IsConstraintValid(pVal: TAcceptanceFailureCode): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal == TAcceptanceFailureCode.TAcceptanceFailureCode_error1) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TAcceptanceFailureCode_Initialize(): TAcceptanceFailureCode = TAcceptanceFailureCode.TAcceptanceFailureCode_error1

@opaque @inlineOnce 
def TAcceptanceFailureCode_ACN_Encode(pVal: TAcceptanceFailureCode, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(0L))
    TAcceptanceFailureCode_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TAcceptanceFailureCode.TAcceptanceFailureCode_error1 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    codec.base.encodeConstrainedPosWholeNumber(intVal_pVal, 0.toRawULong, 0.toRawULong)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex
    }
}

@opaque @inlineOnce 
def TAcceptanceFailureCode_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TAcceptanceFailureCode] =
{
    require(codec.base.bitStream.validate_offset_bits(0L))

    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    val intVal_pVal = codec.base.decodeConstrainedPosWholeNumber(ULong.fromRaw(0), ULong.fromRaw(0)) // uper:135
    val pVal = intVal_pVal.toRaw match
        case 0 => TAcceptanceFailureCode.TAcceptanceFailureCode_error1
        case _ => return LeftMut(ERR_ACN_DECODE_ACCEPTANCEFAILURECODE)

    TAcceptanceFailureCode_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TAcceptanceFailureCode](l)
        case Right(_) => RightMut[ErrorCode, TAcceptanceFailureCode](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TAcceptanceFailureCode]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex && TAcceptanceFailureCode_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TAcceptanceFailureCode_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TAcceptanceFailureCode]) =
{
    require(codec.base.bitStream.validate_offset_bits(0L))
    val cpy = snapshot(codec)
    val res = TAcceptanceFailureCode_ACN_Decode(cpy)
    (cpy, res)
}

def TAcceptanceFailureData_error1_IsConstraintValid(@annotation.unused pVal: TAcceptanceFailureData_error1): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TAcceptanceFailureData_IsConstraintValid(pVal: TAcceptanceFailureData): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
            ret = TAcceptanceFailureData_error1_IsConstraintValid(error1)
    ret
}

def TAcceptanceFailureData_error1_Initialize(): TAcceptanceFailureData_error1 = TAcceptanceFailureData_error1(Vector.fill(1)(0.toRawUByte))
def TAcceptanceFailureData_Initialize(): TAcceptanceFailureData = TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(TAcceptanceFailureData_error1(Vector.fill(1)(0.toRawUByte)))

def TAcceptanceFailureNotice_IsConstraintValid(pVal: TAcceptanceFailureNotice): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TAcceptanceFailureData_IsConstraintValid(pVal.data)
    ret
}

def TAcceptanceFailureNotice_Initialize(): TAcceptanceFailureNotice = TAcceptanceFailureNotice(data = TAcceptanceFailureData_Initialize())

@opaque @inlineOnce 
def TAcceptanceFailureNotice_ACN_Encode(pVal: TAcceptanceFailureNotice, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    TAcceptanceFailureNotice_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    val AcceptanceFailureNotice_code = pVal.data match
        case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(_) =>TAcceptanceFailureCode.TAcceptanceFailureCode_error1

    /* Encode AcceptanceFailureNotice_code */
    val intVal_AcceptanceFailureNotice_code = AcceptanceFailureNotice_code match
        case TAcceptanceFailureCode.TAcceptanceFailureCode_error1 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    codec.base.encodeConstrainedPosWholeNumber(intVal_AcceptanceFailureNotice_code, 0.toRawULong, 0.toRawULong)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 1L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode data */
    AcceptanceFailureNotice_data_ACN_Encode(codec, pVal, AcceptanceFailureNotice_code, pVal.data) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = pVal.data match {
        case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
            1L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 1L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def AcceptanceFailureNotice_data_ACN_Encode(codec: ACN, pVal: TAcceptanceFailureNotice, AcceptanceFailureNotice_code: TAcceptanceFailureCode, data: TAcceptanceFailureData): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    @ghost val oldCdc = snapshot(codec)
    TAcceptanceFailureData_IsConstraintValid(data) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    data match
        case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
            assert(1.toInt >= 0) // overflow may happen during cast
            codec.base.bitStream.appendBitsMSBFirstVec(error1.arr, 1.toInt)
    
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + data.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TAcceptanceFailureNotice_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TAcceptanceFailureNotice] =
{
    require(codec.base.bitStream.validate_offset_bits(1L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode AcceptanceFailureNotice_code */
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    val intVal_AcceptanceFailureNotice_code = codec.base.decodeConstrainedPosWholeNumber(ULong.fromRaw(0), ULong.fromRaw(0)) // uper:135
    val AcceptanceFailureNotice_code = intVal_AcceptanceFailureNotice_code.toRaw match
        case 0 => TAcceptanceFailureCode.TAcceptanceFailureCode_error1
        case _ => return LeftMut(ERR_ACN_DECODE_ACCEPTANCEFAILURENOTICE_CODE)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 1L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode data */
    val pVal_data = AcceptanceFailureNotice_data_ACN_Decode(codec, AcceptanceFailureNotice_code) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = pVal_data match {
        case TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1) =>
            1L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 1L)
    }
    val pVal = TAcceptanceFailureNotice(pVal_data)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TAcceptanceFailureNotice_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TAcceptanceFailureNotice](l)
        case Right(_) => RightMut[ErrorCode, TAcceptanceFailureNotice](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TAcceptanceFailureNotice]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TAcceptanceFailureNotice_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TAcceptanceFailureNotice_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TAcceptanceFailureNotice]) =
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = TAcceptanceFailureNotice_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def AcceptanceFailureNotice_data_ACN_Decode(codec: ACN, AcceptanceFailureNotice_code: TAcceptanceFailureCode): EitherMut[Int, TAcceptanceFailureData] = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    @ghost val oldCdc = snapshot(codec)
    val data = AcceptanceFailureNotice_code match
        case TAcceptanceFailureCode.TAcceptanceFailureCode_error1 =>
            val error1 = TAcceptanceFailureData_error1(codec.base.bitStream.readBitsVec(1.toInt))
            TAcceptanceFailureData.AcceptanceFailureData_error1_PRESENT(error1)
    TAcceptanceFailureData_IsConstraintValid(data) match {
        case Left(l) =>
            LeftMut[Int, TAcceptanceFailureData](l)
        case Right(_) =>
            RightMut[Int, TAcceptanceFailureData](data)
    }
}.ensuring { (res: EitherMut[Int, TAcceptanceFailureData]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TAcceptanceFailureData_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def AcceptanceFailureNotice_data_ACN_Decode_pure(codec: ACN, AcceptanceFailureNotice_code: TAcceptanceFailureCode): (ACN, EitherMut[Int, TAcceptanceFailureData]) = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = AcceptanceFailureNotice_data_ACN_Decode(cpy, AcceptanceFailureNotice_code)
    (cpy, res)
}

def TExecutionStartFailureCode_IsConstraintValid(pVal: TExecutionStartFailureCode): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal == TExecutionStartFailureCode.TExecutionStartFailureCode_error1) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TExecutionStartFailureCode_Initialize(): TExecutionStartFailureCode = TExecutionStartFailureCode.TExecutionStartFailureCode_error1

@opaque @inlineOnce 
def TExecutionStartFailureCode_ACN_Encode(pVal: TExecutionStartFailureCode, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(0L))
    TExecutionStartFailureCode_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TExecutionStartFailureCode.TExecutionStartFailureCode_error1 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    codec.base.encodeConstrainedPosWholeNumber(intVal_pVal, 0.toRawULong, 0.toRawULong)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex
    }
}

@opaque @inlineOnce 
def TExecutionStartFailureCode_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TExecutionStartFailureCode] =
{
    require(codec.base.bitStream.validate_offset_bits(0L))

    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    val intVal_pVal = codec.base.decodeConstrainedPosWholeNumber(ULong.fromRaw(0), ULong.fromRaw(0)) // uper:135
    val pVal = intVal_pVal.toRaw match
        case 0 => TExecutionStartFailureCode.TExecutionStartFailureCode_error1
        case _ => return LeftMut(ERR_ACN_DECODE_EXECUTIONSTARTFAILURECODE)

    TExecutionStartFailureCode_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TExecutionStartFailureCode](l)
        case Right(_) => RightMut[ErrorCode, TExecutionStartFailureCode](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TExecutionStartFailureCode]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex && TExecutionStartFailureCode_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TExecutionStartFailureCode_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TExecutionStartFailureCode]) =
{
    require(codec.base.bitStream.validate_offset_bits(0L))
    val cpy = snapshot(codec)
    val res = TExecutionStartFailureCode_ACN_Decode(cpy)
    (cpy, res)
}

def TExecutionStartFailureData_error1_IsConstraintValid(@annotation.unused pVal: TExecutionStartFailureData_error1): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TExecutionStartFailureData_IsConstraintValid(pVal: TExecutionStartFailureData): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
            ret = TExecutionStartFailureData_error1_IsConstraintValid(error1)
    ret
}

def TExecutionStartFailureData_error1_Initialize(): TExecutionStartFailureData_error1 = TExecutionStartFailureData_error1(Vector.fill(1)(0.toRawUByte))
def TExecutionStartFailureData_Initialize(): TExecutionStartFailureData = TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(TExecutionStartFailureData_error1(Vector.fill(1)(0.toRawUByte)))

def TExecutionStartFailureNotice_IsConstraintValid(pVal: TExecutionStartFailureNotice): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TExecutionStartFailureData_IsConstraintValid(pVal.data)
    ret
}

def TExecutionStartFailureNotice_Initialize(): TExecutionStartFailureNotice = TExecutionStartFailureNotice(data = TExecutionStartFailureData_Initialize())

@opaque @inlineOnce 
def TExecutionStartFailureNotice_ACN_Encode(pVal: TExecutionStartFailureNotice, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    TExecutionStartFailureNotice_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    val ExecutionStartFailureNotice_code = pVal.data match
        case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(_) =>TExecutionStartFailureCode.TExecutionStartFailureCode_error1

    /* Encode ExecutionStartFailureNotice_code */
    val intVal_ExecutionStartFailureNotice_code = ExecutionStartFailureNotice_code match
        case TExecutionStartFailureCode.TExecutionStartFailureCode_error1 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    codec.base.encodeConstrainedPosWholeNumber(intVal_ExecutionStartFailureNotice_code, 0.toRawULong, 0.toRawULong)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 1L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode data */
    ExecutionStartFailureNotice_data_ACN_Encode(codec, pVal, ExecutionStartFailureNotice_code, pVal.data) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = pVal.data match {
        case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
            1L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 1L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def ExecutionStartFailureNotice_data_ACN_Encode(codec: ACN, pVal: TExecutionStartFailureNotice, ExecutionStartFailureNotice_code: TExecutionStartFailureCode, data: TExecutionStartFailureData): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    @ghost val oldCdc = snapshot(codec)
    TExecutionStartFailureData_IsConstraintValid(data) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    data match
        case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
            assert(1.toInt >= 0) // overflow may happen during cast
            codec.base.bitStream.appendBitsMSBFirstVec(error1.arr, 1.toInt)
    
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + data.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TExecutionStartFailureNotice_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TExecutionStartFailureNotice] =
{
    require(codec.base.bitStream.validate_offset_bits(1L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode ExecutionStartFailureNotice_code */
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    val intVal_ExecutionStartFailureNotice_code = codec.base.decodeConstrainedPosWholeNumber(ULong.fromRaw(0), ULong.fromRaw(0)) // uper:135
    val ExecutionStartFailureNotice_code = intVal_ExecutionStartFailureNotice_code.toRaw match
        case 0 => TExecutionStartFailureCode.TExecutionStartFailureCode_error1
        case _ => return LeftMut(ERR_ACN_DECODE_EXECUTIONSTARTFAILURENOTICE_CODE)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 1L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode data */
    val pVal_data = ExecutionStartFailureNotice_data_ACN_Decode(codec, ExecutionStartFailureNotice_code) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = pVal_data match {
        case TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1) =>
            1L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 1L)
    }
    val pVal = TExecutionStartFailureNotice(pVal_data)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TExecutionStartFailureNotice_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TExecutionStartFailureNotice](l)
        case Right(_) => RightMut[ErrorCode, TExecutionStartFailureNotice](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TExecutionStartFailureNotice]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TExecutionStartFailureNotice_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TExecutionStartFailureNotice_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TExecutionStartFailureNotice]) =
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = TExecutionStartFailureNotice_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def ExecutionStartFailureNotice_data_ACN_Decode(codec: ACN, ExecutionStartFailureNotice_code: TExecutionStartFailureCode): EitherMut[Int, TExecutionStartFailureData] = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    @ghost val oldCdc = snapshot(codec)
    val data = ExecutionStartFailureNotice_code match
        case TExecutionStartFailureCode.TExecutionStartFailureCode_error1 =>
            val error1 = TExecutionStartFailureData_error1(codec.base.bitStream.readBitsVec(1.toInt))
            TExecutionStartFailureData.ExecutionStartFailureData_error1_PRESENT(error1)
    TExecutionStartFailureData_IsConstraintValid(data) match {
        case Left(l) =>
            LeftMut[Int, TExecutionStartFailureData](l)
        case Right(_) =>
            RightMut[Int, TExecutionStartFailureData](data)
    }
}.ensuring { (res: EitherMut[Int, TExecutionStartFailureData]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TExecutionStartFailureData_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def ExecutionStartFailureNotice_data_ACN_Decode_pure(codec: ACN, ExecutionStartFailureNotice_code: TExecutionStartFailureCode): (ACN, EitherMut[Int, TExecutionStartFailureData]) = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = ExecutionStartFailureNotice_data_ACN_Decode(cpy, ExecutionStartFailureNotice_code)
    (cpy, res)
}

def TExecutionProgressFailureCode_IsConstraintValid(pVal: TExecutionProgressFailureCode): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal == TExecutionProgressFailureCode.TExecutionProgressFailureCode_error1) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TExecutionProgressFailureCode_Initialize(): TExecutionProgressFailureCode = TExecutionProgressFailureCode.TExecutionProgressFailureCode_error1

@opaque @inlineOnce 
def TExecutionProgressFailureCode_ACN_Encode(pVal: TExecutionProgressFailureCode, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(0L))
    TExecutionProgressFailureCode_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TExecutionProgressFailureCode.TExecutionProgressFailureCode_error1 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    codec.base.encodeConstrainedPosWholeNumber(intVal_pVal, 0.toRawULong, 0.toRawULong)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex
    }
}

@opaque @inlineOnce 
def TExecutionProgressFailureCode_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TExecutionProgressFailureCode] =
{
    require(codec.base.bitStream.validate_offset_bits(0L))

    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    val intVal_pVal = codec.base.decodeConstrainedPosWholeNumber(ULong.fromRaw(0), ULong.fromRaw(0)) // uper:135
    val pVal = intVal_pVal.toRaw match
        case 0 => TExecutionProgressFailureCode.TExecutionProgressFailureCode_error1
        case _ => return LeftMut(ERR_ACN_DECODE_EXECUTIONPROGRESSFAILURECODE)

    TExecutionProgressFailureCode_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TExecutionProgressFailureCode](l)
        case Right(_) => RightMut[ErrorCode, TExecutionProgressFailureCode](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TExecutionProgressFailureCode]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex && TExecutionProgressFailureCode_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TExecutionProgressFailureCode_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TExecutionProgressFailureCode]) =
{
    require(codec.base.bitStream.validate_offset_bits(0L))
    val cpy = snapshot(codec)
    val res = TExecutionProgressFailureCode_ACN_Decode(cpy)
    (cpy, res)
}

def TExecutionProgressFailureData_error1_IsConstraintValid(@annotation.unused pVal: TExecutionProgressFailureData_error1): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TExecutionProgressFailureData_IsConstraintValid(pVal: TExecutionProgressFailureData): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
            ret = TExecutionProgressFailureData_error1_IsConstraintValid(error1)
    ret
}

def TExecutionProgressFailureData_error1_Initialize(): TExecutionProgressFailureData_error1 = TExecutionProgressFailureData_error1(Vector.fill(1)(0.toRawUByte))
def TExecutionProgressFailureData_Initialize(): TExecutionProgressFailureData = TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(TExecutionProgressFailureData_error1(Vector.fill(1)(0.toRawUByte)))

def TExecutionProgressFailureNotice_IsConstraintValid(pVal: TExecutionProgressFailureNotice): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TExecutionProgressFailureData_IsConstraintValid(pVal.data)
    ret
}

def TExecutionProgressFailureNotice_Initialize(): TExecutionProgressFailureNotice = TExecutionProgressFailureNotice(data = TExecutionProgressFailureData_Initialize())

@opaque @inlineOnce 
def TExecutionProgressFailureNotice_ACN_Encode(pVal: TExecutionProgressFailureNotice, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    TExecutionProgressFailureNotice_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    val ExecutionProgressFailureNotice_code = pVal.data match
        case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(_) =>TExecutionProgressFailureCode.TExecutionProgressFailureCode_error1

    /* Encode ExecutionProgressFailureNotice_code */
    val intVal_ExecutionProgressFailureNotice_code = ExecutionProgressFailureNotice_code match
        case TExecutionProgressFailureCode.TExecutionProgressFailureCode_error1 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    codec.base.encodeConstrainedPosWholeNumber(intVal_ExecutionProgressFailureNotice_code, 0.toRawULong, 0.toRawULong)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 1L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode data */
    ExecutionProgressFailureNotice_data_ACN_Encode(codec, pVal, ExecutionProgressFailureNotice_code, pVal.data) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = pVal.data match {
        case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
            1L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 1L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def ExecutionProgressFailureNotice_data_ACN_Encode(codec: ACN, pVal: TExecutionProgressFailureNotice, ExecutionProgressFailureNotice_code: TExecutionProgressFailureCode, data: TExecutionProgressFailureData): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    @ghost val oldCdc = snapshot(codec)
    TExecutionProgressFailureData_IsConstraintValid(data) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    data match
        case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
            assert(1.toInt >= 0) // overflow may happen during cast
            codec.base.bitStream.appendBitsMSBFirstVec(error1.arr, 1.toInt)
    
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + data.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TExecutionProgressFailureNotice_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TExecutionProgressFailureNotice] =
{
    require(codec.base.bitStream.validate_offset_bits(1L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode ExecutionProgressFailureNotice_code */
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    val intVal_ExecutionProgressFailureNotice_code = codec.base.decodeConstrainedPosWholeNumber(ULong.fromRaw(0), ULong.fromRaw(0)) // uper:135
    val ExecutionProgressFailureNotice_code = intVal_ExecutionProgressFailureNotice_code.toRaw match
        case 0 => TExecutionProgressFailureCode.TExecutionProgressFailureCode_error1
        case _ => return LeftMut(ERR_ACN_DECODE_EXECUTIONPROGRESSFAILURENOTICE_CODE)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 1L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode data */
    val pVal_data = ExecutionProgressFailureNotice_data_ACN_Decode(codec, ExecutionProgressFailureNotice_code) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = pVal_data match {
        case TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1) =>
            1L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 1L)
    }
    val pVal = TExecutionProgressFailureNotice(pVal_data)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TExecutionProgressFailureNotice_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TExecutionProgressFailureNotice](l)
        case Right(_) => RightMut[ErrorCode, TExecutionProgressFailureNotice](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TExecutionProgressFailureNotice]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TExecutionProgressFailureNotice_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TExecutionProgressFailureNotice_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TExecutionProgressFailureNotice]) =
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = TExecutionProgressFailureNotice_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def ExecutionProgressFailureNotice_data_ACN_Decode(codec: ACN, ExecutionProgressFailureNotice_code: TExecutionProgressFailureCode): EitherMut[Int, TExecutionProgressFailureData] = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    @ghost val oldCdc = snapshot(codec)
    val data = ExecutionProgressFailureNotice_code match
        case TExecutionProgressFailureCode.TExecutionProgressFailureCode_error1 =>
            val error1 = TExecutionProgressFailureData_error1(codec.base.bitStream.readBitsVec(1.toInt))
            TExecutionProgressFailureData.ExecutionProgressFailureData_error1_PRESENT(error1)
    TExecutionProgressFailureData_IsConstraintValid(data) match {
        case Left(l) =>
            LeftMut[Int, TExecutionProgressFailureData](l)
        case Right(_) =>
            RightMut[Int, TExecutionProgressFailureData](data)
    }
}.ensuring { (res: EitherMut[Int, TExecutionProgressFailureData]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TExecutionProgressFailureData_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def ExecutionProgressFailureNotice_data_ACN_Decode_pure(codec: ACN, ExecutionProgressFailureNotice_code: TExecutionProgressFailureCode): (ACN, EitherMut[Int, TExecutionProgressFailureData]) = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = ExecutionProgressFailureNotice_data_ACN_Decode(cpy, ExecutionProgressFailureNotice_code)
    (cpy, res)
}

def TExecutionCompletionFailureCode_IsConstraintValid(pVal: TExecutionCompletionFailureCode): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal == TExecutionCompletionFailureCode.TExecutionCompletionFailureCode_error1) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TExecutionCompletionFailureCode_Initialize(): TExecutionCompletionFailureCode = TExecutionCompletionFailureCode.TExecutionCompletionFailureCode_error1

@opaque @inlineOnce 
def TExecutionCompletionFailureCode_ACN_Encode(pVal: TExecutionCompletionFailureCode, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(0L))
    TExecutionCompletionFailureCode_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TExecutionCompletionFailureCode.TExecutionCompletionFailureCode_error1 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    codec.base.encodeConstrainedPosWholeNumber(intVal_pVal, 0.toRawULong, 0.toRawULong)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex
    }
}

@opaque @inlineOnce 
def TExecutionCompletionFailureCode_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TExecutionCompletionFailureCode] =
{
    require(codec.base.bitStream.validate_offset_bits(0L))

    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    val intVal_pVal = codec.base.decodeConstrainedPosWholeNumber(ULong.fromRaw(0), ULong.fromRaw(0)) // uper:135
    val pVal = intVal_pVal.toRaw match
        case 0 => TExecutionCompletionFailureCode.TExecutionCompletionFailureCode_error1
        case _ => return LeftMut(ERR_ACN_DECODE_EXECUTIONCOMPLETIONFAILURECODE)

    TExecutionCompletionFailureCode_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TExecutionCompletionFailureCode](l)
        case Right(_) => RightMut[ErrorCode, TExecutionCompletionFailureCode](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TExecutionCompletionFailureCode]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex && TExecutionCompletionFailureCode_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TExecutionCompletionFailureCode_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TExecutionCompletionFailureCode]) =
{
    require(codec.base.bitStream.validate_offset_bits(0L))
    val cpy = snapshot(codec)
    val res = TExecutionCompletionFailureCode_ACN_Decode(cpy)
    (cpy, res)
}

def TExecutionCompletionFailureData_error1_IsConstraintValid(@annotation.unused pVal: TExecutionCompletionFailureData_error1): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TExecutionCompletionFailureData_IsConstraintValid(pVal: TExecutionCompletionFailureData): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
            ret = TExecutionCompletionFailureData_error1_IsConstraintValid(error1)
    ret
}

def TExecutionCompletionFailureData_error1_Initialize(): TExecutionCompletionFailureData_error1 = TExecutionCompletionFailureData_error1(Vector.fill(1)(0.toRawUByte))
def TExecutionCompletionFailureData_Initialize(): TExecutionCompletionFailureData = TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(TExecutionCompletionFailureData_error1(Vector.fill(1)(0.toRawUByte)))

def TExecutionCompletionFailureNotice_IsConstraintValid(pVal: TExecutionCompletionFailureNotice): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TExecutionCompletionFailureData_IsConstraintValid(pVal.data)
    ret
}

def TExecutionCompletionFailureNotice_Initialize(): TExecutionCompletionFailureNotice = TExecutionCompletionFailureNotice(data = TExecutionCompletionFailureData_Initialize())

@opaque @inlineOnce 
def TExecutionCompletionFailureNotice_ACN_Encode(pVal: TExecutionCompletionFailureNotice, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    TExecutionCompletionFailureNotice_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    val ExecutionCompletionFailureNotice_code = pVal.data match
        case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(_) =>TExecutionCompletionFailureCode.TExecutionCompletionFailureCode_error1

    /* Encode ExecutionCompletionFailureNotice_code */
    val intVal_ExecutionCompletionFailureNotice_code = ExecutionCompletionFailureNotice_code match
        case TExecutionCompletionFailureCode.TExecutionCompletionFailureCode_error1 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    codec.base.encodeConstrainedPosWholeNumber(intVal_ExecutionCompletionFailureNotice_code, 0.toRawULong, 0.toRawULong)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 1L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode data */
    ExecutionCompletionFailureNotice_data_ACN_Encode(codec, pVal, ExecutionCompletionFailureNotice_code, pVal.data) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = pVal.data match {
        case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
            1L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 1L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def ExecutionCompletionFailureNotice_data_ACN_Encode(codec: ACN, pVal: TExecutionCompletionFailureNotice, ExecutionCompletionFailureNotice_code: TExecutionCompletionFailureCode, data: TExecutionCompletionFailureData): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    @ghost val oldCdc = snapshot(codec)
    TExecutionCompletionFailureData_IsConstraintValid(data) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    data match
        case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
            assert(1.toInt >= 0) // overflow may happen during cast
            codec.base.bitStream.appendBitsMSBFirstVec(error1.arr, 1.toInt)
    
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + data.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TExecutionCompletionFailureNotice_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TExecutionCompletionFailureNotice] =
{
    require(codec.base.bitStream.validate_offset_bits(1L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode ExecutionCompletionFailureNotice_code */
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    val intVal_ExecutionCompletionFailureNotice_code = codec.base.decodeConstrainedPosWholeNumber(ULong.fromRaw(0), ULong.fromRaw(0)) // uper:135
    val ExecutionCompletionFailureNotice_code = intVal_ExecutionCompletionFailureNotice_code.toRaw match
        case 0 => TExecutionCompletionFailureCode.TExecutionCompletionFailureCode_error1
        case _ => return LeftMut(ERR_ACN_DECODE_EXECUTIONCOMPLETIONFAILURENOTICE_CODE)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 1L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode data */
    val pVal_data = ExecutionCompletionFailureNotice_data_ACN_Decode(codec, ExecutionCompletionFailureNotice_code) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = pVal_data match {
        case TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1) =>
            1L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 1L)
    }
    val pVal = TExecutionCompletionFailureNotice(pVal_data)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TExecutionCompletionFailureNotice_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TExecutionCompletionFailureNotice](l)
        case Right(_) => RightMut[ErrorCode, TExecutionCompletionFailureNotice](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TExecutionCompletionFailureNotice]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TExecutionCompletionFailureNotice_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TExecutionCompletionFailureNotice_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TExecutionCompletionFailureNotice]) =
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = TExecutionCompletionFailureNotice_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def ExecutionCompletionFailureNotice_data_ACN_Decode(codec: ACN, ExecutionCompletionFailureNotice_code: TExecutionCompletionFailureCode): EitherMut[Int, TExecutionCompletionFailureData] = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    @ghost val oldCdc = snapshot(codec)
    val data = ExecutionCompletionFailureNotice_code match
        case TExecutionCompletionFailureCode.TExecutionCompletionFailureCode_error1 =>
            val error1 = TExecutionCompletionFailureData_error1(codec.base.bitStream.readBitsVec(1.toInt))
            TExecutionCompletionFailureData.ExecutionCompletionFailureData_error1_PRESENT(error1)
    TExecutionCompletionFailureData_IsConstraintValid(data) match {
        case Left(l) =>
            LeftMut[Int, TExecutionCompletionFailureData](l)
        case Right(_) =>
            RightMut[Int, TExecutionCompletionFailureData](data)
    }
}.ensuring { (res: EitherMut[Int, TExecutionCompletionFailureData]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TExecutionCompletionFailureData_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def ExecutionCompletionFailureNotice_data_ACN_Decode_pure(codec: ACN, ExecutionCompletionFailureNotice_code: TExecutionCompletionFailureCode): (ACN, EitherMut[Int, TExecutionCompletionFailureData]) = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = ExecutionCompletionFailureNotice_data_ACN_Decode(cpy, ExecutionCompletionFailureNotice_code)
    (cpy, res)
}

def TRoutingFailureCode_IsConstraintValid(pVal: TRoutingFailureCode): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal == TRoutingFailureCode.TRoutingFailureCode_error1) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TRoutingFailureCode_Initialize(): TRoutingFailureCode = TRoutingFailureCode.TRoutingFailureCode_error1

@opaque @inlineOnce 
def TRoutingFailureCode_ACN_Encode(pVal: TRoutingFailureCode, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(0L))
    TRoutingFailureCode_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TRoutingFailureCode.TRoutingFailureCode_error1 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    codec.base.encodeConstrainedPosWholeNumber(intVal_pVal, 0.toRawULong, 0.toRawULong)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex
    }
}

@opaque @inlineOnce 
def TRoutingFailureCode_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TRoutingFailureCode] =
{
    require(codec.base.bitStream.validate_offset_bits(0L))

    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    val intVal_pVal = codec.base.decodeConstrainedPosWholeNumber(ULong.fromRaw(0), ULong.fromRaw(0)) // uper:135
    val pVal = intVal_pVal.toRaw match
        case 0 => TRoutingFailureCode.TRoutingFailureCode_error1
        case _ => return LeftMut(ERR_ACN_DECODE_ROUTINGFAILURECODE)

    TRoutingFailureCode_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TRoutingFailureCode](l)
        case Right(_) => RightMut[ErrorCode, TRoutingFailureCode](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TRoutingFailureCode]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex && TRoutingFailureCode_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TRoutingFailureCode_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TRoutingFailureCode]) =
{
    require(codec.base.bitStream.validate_offset_bits(0L))
    val cpy = snapshot(codec)
    val res = TRoutingFailureCode_ACN_Decode(cpy)
    (cpy, res)
}

def TRoutingFailureData_error1_IsConstraintValid(@annotation.unused pVal: TRoutingFailureData_error1): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TRoutingFailureData_IsConstraintValid(pVal: TRoutingFailureData): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
            ret = TRoutingFailureData_error1_IsConstraintValid(error1)
    ret
}

def TRoutingFailureData_error1_Initialize(): TRoutingFailureData_error1 = TRoutingFailureData_error1(Vector.fill(1)(0.toRawUByte))
def TRoutingFailureData_Initialize(): TRoutingFailureData = TRoutingFailureData.RoutingFailureData_error1_PRESENT(TRoutingFailureData_error1(Vector.fill(1)(0.toRawUByte)))

def TRoutingFailureNotice_IsConstraintValid(pVal: TRoutingFailureNotice): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TRoutingFailureData_IsConstraintValid(pVal.data)
    ret
}

def TRoutingFailureNotice_Initialize(): TRoutingFailureNotice = TRoutingFailureNotice(data = TRoutingFailureData_Initialize())

@opaque @inlineOnce 
def TRoutingFailureNotice_ACN_Encode(pVal: TRoutingFailureNotice, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    TRoutingFailureNotice_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    val RoutingFailureNotice_code = pVal.data match
        case TRoutingFailureData.RoutingFailureData_error1_PRESENT(_) =>TRoutingFailureCode.TRoutingFailureCode_error1

    /* Encode RoutingFailureNotice_code */
    val intVal_RoutingFailureNotice_code = RoutingFailureNotice_code match
        case TRoutingFailureCode.TRoutingFailureCode_error1 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    codec.base.encodeConstrainedPosWholeNumber(intVal_RoutingFailureNotice_code, 0.toRawULong, 0.toRawULong)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 1L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode data */
    RoutingFailureNotice_data_ACN_Encode(codec, pVal, RoutingFailureNotice_code, pVal.data) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = pVal.data match {
        case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
            1L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 1L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def RoutingFailureNotice_data_ACN_Encode(codec: ACN, pVal: TRoutingFailureNotice, RoutingFailureNotice_code: TRoutingFailureCode, data: TRoutingFailureData): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    @ghost val oldCdc = snapshot(codec)
    TRoutingFailureData_IsConstraintValid(data) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    data match
        case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
            assert(1.toInt >= 0) // overflow may happen during cast
            codec.base.bitStream.appendBitsMSBFirstVec(error1.arr, 1.toInt)
    
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + data.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TRoutingFailureNotice_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TRoutingFailureNotice] =
{
    require(codec.base.bitStream.validate_offset_bits(1L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode RoutingFailureNotice_code */
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(0) - ULong.fromRaw(0)) == 0)
            bitCountLemma()
        }
    }
    val intVal_RoutingFailureNotice_code = codec.base.decodeConstrainedPosWholeNumber(ULong.fromRaw(0), ULong.fromRaw(0)) // uper:135
    val RoutingFailureNotice_code = intVal_RoutingFailureNotice_code.toRaw match
        case 0 => TRoutingFailureCode.TRoutingFailureCode_error1
        case _ => return LeftMut(ERR_ACN_DECODE_ROUTINGFAILURENOTICE_CODE)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 1L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode data */
    val pVal_data = RoutingFailureNotice_data_ACN_Decode(codec, RoutingFailureNotice_code) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = pVal_data match {
        case TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1) =>
            1L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 1L)
    }
    val pVal = TRoutingFailureNotice(pVal_data)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TRoutingFailureNotice_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TRoutingFailureNotice](l)
        case Right(_) => RightMut[ErrorCode, TRoutingFailureNotice](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TRoutingFailureNotice]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TRoutingFailureNotice_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TRoutingFailureNotice_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TRoutingFailureNotice]) =
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = TRoutingFailureNotice_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def RoutingFailureNotice_data_ACN_Decode(codec: ACN, RoutingFailureNotice_code: TRoutingFailureCode): EitherMut[Int, TRoutingFailureData] = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    @ghost val oldCdc = snapshot(codec)
    val data = RoutingFailureNotice_code match
        case TRoutingFailureCode.TRoutingFailureCode_error1 =>
            val error1 = TRoutingFailureData_error1(codec.base.bitStream.readBitsVec(1.toInt))
            TRoutingFailureData.RoutingFailureData_error1_PRESENT(error1)
    TRoutingFailureData_IsConstraintValid(data) match {
        case Left(l) =>
            LeftMut[Int, TRoutingFailureData](l)
        case Right(_) =>
            RightMut[Int, TRoutingFailureData](data)
    }
}.ensuring { (res: EitherMut[Int, TRoutingFailureData]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TRoutingFailureData_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def RoutingFailureNotice_data_ACN_Decode_pure(codec: ACN, RoutingFailureNotice_code: TRoutingFailureCode): (ACN, EitherMut[Int, TRoutingFailureData]) = {
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = RoutingFailureNotice_data_ACN_Decode(cpy, RoutingFailureNotice_code)
    (cpy, res)
}