/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang.{ghost => ghostExpr, _}
import stainless.annotation._
import stainless.collection._
import stainless.proof._
import StaticChecks._


def TLimitCheckingCriteria_IsConstraintValid(pVal: TLimitCheckingCriteria): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TDummyType_IsConstraintValid(pVal.lowLimit)
    if ret.isRight then
        ret = TEventDefinition_ID_IsConstraintValid(pVal.lowLimitEventDefinition_ID)
        if ret.isRight then
            ret = TDummyType_IsConstraintValid(pVal.highLimit)
            if ret.isRight then
                ret = TEventDefinition_ID_IsConstraintValid(pVal.highLimitEventDefinition)
    ret
}

def TLimitCheckingCriteria_Initialize(): TLimitCheckingCriteria = TLimitCheckingCriteria(lowLimit = ULong.fromRaw(15L), lowLimitEventDefinition_ID = ULong.fromRaw(0L), highLimit = ULong.fromRaw(15L), highLimitEventDefinition = ULong.fromRaw(0L))

@opaque @inlineOnce 
def TLimitCheckingCriteria_ACN_Encode(pVal: TLimitCheckingCriteria, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(72L))
    TLimitCheckingCriteria_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode lowLimit */
    TDummyType_ACN_Encode(pVal.lowLimit, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 72L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 4L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode lowLimitEventDefinition_ID */
    TEventDefinition_ID_ACN_Encode(pVal.lowLimitEventDefinition_ID, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 68L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 36L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Encode highLimit */
    TDummyType_ACN_Encode(pVal.highLimit, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 36L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 40L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Encode highLimitEventDefinition */
    TEventDefinition_ID_ACN_Encode(pVal.highLimitEventDefinition, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 72L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_3 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 72L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TLimitCheckingCriteria_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TLimitCheckingCriteria] =
{
    require(codec.base.bitStream.validate_offset_bits(72L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode lowLimit */
    val pVal_lowLimit = TDummyType_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 72L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 4L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode lowLimitEventDefinition_ID */
    val pVal_lowLimitEventDefinition_ID = TEventDefinition_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 68L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 36L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Decode highLimit */
    val pVal_highLimit = TDummyType_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 36L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 40L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Decode highLimitEventDefinition */
    val pVal_highLimitEventDefinition = TEventDefinition_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 72L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_3 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 72L)
    }
    val pVal = TLimitCheckingCriteria(pVal_lowLimit, pVal_lowLimitEventDefinition_ID, pVal_highLimit, pVal_highLimitEventDefinition)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3)
    }

    TLimitCheckingCriteria_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TLimitCheckingCriteria](l)
        case Right(_) => RightMut[ErrorCode, TLimitCheckingCriteria](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TLimitCheckingCriteria]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TLimitCheckingCriteria_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TLimitCheckingCriteria_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TLimitCheckingCriteria]) =
{
    require(codec.base.bitStream.validate_offset_bits(72L))
    val cpy = snapshot(codec)
    val res = TLimitCheckingCriteria_ACN_Decode(cpy)
    (cpy, res)
}

def TDeltaCheckingCriteria_IsConstraintValid(pVal: TDeltaCheckingCriteria): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TDummyType_IsConstraintValid(pVal.lowDeltaThreshold)
    if ret.isRight then
        ret = TEventDefinition_ID_IsConstraintValid(pVal.lowThresholdEventDefinition_ID)
        if ret.isRight then
            ret = TDummyType_IsConstraintValid(pVal.highDeltaThreshold)
            if ret.isRight then
                ret = TEventDefinition_ID_IsConstraintValid(pVal.highThresholdEventDefinition_ID)
                if ret.isRight then
                    ret = TPUSC_UINT32_IsConstraintValid(pVal.numberOFConstructiveDeltaValues)
    ret
}

def TDeltaCheckingCriteria_Initialize(): TDeltaCheckingCriteria = TDeltaCheckingCriteria(lowDeltaThreshold = ULong.fromRaw(15L), lowThresholdEventDefinition_ID = ULong.fromRaw(0L), highDeltaThreshold = ULong.fromRaw(15L), highThresholdEventDefinition_ID = ULong.fromRaw(0L), numberOFConstructiveDeltaValues = ULong.fromRaw(0L))

@opaque @inlineOnce 
def TDeltaCheckingCriteria_ACN_Encode(pVal: TDeltaCheckingCriteria, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(104L))
    TDeltaCheckingCriteria_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode lowDeltaThreshold */
    TDummyType_ACN_Encode(pVal.lowDeltaThreshold, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 104L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 4L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode lowThresholdEventDefinition_ID */
    TEventDefinition_ID_ACN_Encode(pVal.lowThresholdEventDefinition_ID, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 100L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 36L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Encode highDeltaThreshold */
    TDummyType_ACN_Encode(pVal.highDeltaThreshold, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 68L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 40L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Encode highThresholdEventDefinition_ID */
    TEventDefinition_ID_ACN_Encode(pVal.highThresholdEventDefinition_ID, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 64L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 72L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_3 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Encode numberOFConstructiveDeltaValues */
    TPUSC_UINT32_ACN_Encode(pVal.numberOFConstructiveDeltaValues, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 104L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_4 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 104L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3 + size_4)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TDeltaCheckingCriteria_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TDeltaCheckingCriteria] =
{
    require(codec.base.bitStream.validate_offset_bits(104L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode lowDeltaThreshold */
    val pVal_lowDeltaThreshold = TDummyType_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 104L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 4L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode lowThresholdEventDefinition_ID */
    val pVal_lowThresholdEventDefinition_ID = TEventDefinition_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 100L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 36L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Decode highDeltaThreshold */
    val pVal_highDeltaThreshold = TDummyType_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 68L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 40L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Decode highThresholdEventDefinition_ID */
    val pVal_highThresholdEventDefinition_ID = TEventDefinition_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 64L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 72L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_3 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Decode numberOFConstructiveDeltaValues */
    val pVal_numberOFConstructiveDeltaValues = TPUSC_UINT32_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 104L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_4 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 104L)
    }
    val pVal = TDeltaCheckingCriteria(pVal_lowDeltaThreshold, pVal_lowThresholdEventDefinition_ID, pVal_highDeltaThreshold, pVal_highThresholdEventDefinition_ID, pVal_numberOFConstructiveDeltaValues)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3 + size_4)
    }

    TDeltaCheckingCriteria_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TDeltaCheckingCriteria](l)
        case Right(_) => RightMut[ErrorCode, TDeltaCheckingCriteria](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TDeltaCheckingCriteria]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TDeltaCheckingCriteria_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TDeltaCheckingCriteria_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TDeltaCheckingCriteria]) =
{
    require(codec.base.bitStream.validate_offset_bits(104L))
    val cpy = snapshot(codec)
    val res = TDeltaCheckingCriteria_ACN_Decode(cpy)
    (cpy, res)
}

def TEventDefinitionSpare_IsConstraintValid(@annotation.unused pVal: TEventDefinitionSpare): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TEventDefinitionSpare_Initialize(): TEventDefinitionSpare = TEventDefinitionSpare(Vector.fill(4)(0.toRawUByte))

@opaque @inlineOnce 
def TEventDefinitionSpare_ACN_Encode(pVal: TEventDefinitionSpare, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    TEventDefinitionSpare_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    assert(32.toInt >= 0) // overflow may happen during cast
    codec.base.bitStream.appendBitsMSBFirstVec(pVal.arr, 32.toInt)

    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L
    }
}

@opaque @inlineOnce 
def TEventDefinitionSpare_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TEventDefinitionSpare] =
{
    require(codec.base.bitStream.validate_offset_bits(32L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = TEventDefinitionSpare(codec.base.bitStream.readBitsVec(32.toInt))

    TEventDefinitionSpare_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TEventDefinitionSpare](l)
        case Right(_) => RightMut[ErrorCode, TEventDefinitionSpare](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TEventDefinitionSpare]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L && TEventDefinitionSpare_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TEventDefinitionSpare_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TEventDefinitionSpare]) =
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    val cpy = snapshot(codec)
    val res = TEventDefinitionSpare_ACN_Decode(cpy)
    (cpy, res)
}

def TExpectedValueCheckingCriteria_IsConstraintValid(pVal: TExpectedValueCheckingCriteria): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TDummyType_IsConstraintValid(pVal.mask)
    if ret.isRight then
        pVal.spare match
            case SomeMut(spare) =>
                ret = TEventDefinitionSpare_IsConstraintValid(spare)
            case NoneMut() =>
        if ret.isRight then
            ret = TDummyType_IsConstraintValid(pVal.expectedValue)
            if ret.isRight then
                ret = TEventDefinition_ID_IsConstraintValid(pVal.eventDefinition_ID)
    if ret.isRight then
        ret = (pVal.spare.isDefined == true) match
            case true =>
                Right(0)
            case false =>
                Left(45)
    ret
}

def TExpectedValueCheckingCriteria_Initialize(): TExpectedValueCheckingCriteria = TExpectedValueCheckingCriteria(mask = ULong.fromRaw(15L), spare = SomeMut(TEventDefinitionSpare(Vector.fill(4)(0.toRawUByte))), expectedValue = ULong.fromRaw(15L), eventDefinition_ID = ULong.fromRaw(0L))

@opaque @inlineOnce 
def TExpectedValueCheckingCriteria_ACN_Encode(pVal: TExpectedValueCheckingCriteria, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(72L))
    TExpectedValueCheckingCriteria_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode mask */
    TDummyType_ACN_Encode(pVal.mask, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 72L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 4L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    ExpectedValueCheckingCriteria_spare_Optional_ACN_Encode(codec, pVal, pVal.spare) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 68L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 36L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = pVal.spare match {
        case SomeMut(v) =>
            32L
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Encode expectedValue */
    TDummyType_ACN_Encode(pVal.expectedValue, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 36L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 40L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Encode eventDefinition_ID */
    TEventDefinition_ID_ACN_Encode(pVal.eventDefinition_ID, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 72L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_3 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 72L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def ExpectedValueCheckingCriteria_spare_Optional_ACN_Encode(codec: ACN, pVal: TExpectedValueCheckingCriteria, spare: OptionMut[TEventDefinitionSpare]): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(32L))
    @ghost val oldCdc = snapshot(codec)
    /* Encode spare */
    /* marked as ALWAYS PRESENT, so it must be Some */
    spare match
        case SomeMut(spare) =>
            TEventDefinitionSpare_ACN_Encode(spare, codec, false) match // uper:6
                case Right(_) =>
                case Left(err) => return Left(err)
        case NoneMut() => return Left(628)
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L
    }
}



@opaque @inlineOnce 
def TExpectedValueCheckingCriteria_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TExpectedValueCheckingCriteria] =
{
    require(codec.base.bitStream.validate_offset_bits(72L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode mask */
    val pVal_mask = TDummyType_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 72L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 4L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    val pVal_spare = ExpectedValueCheckingCriteria_spare_Optional_ACN_Decode(codec) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 68L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 36L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = pVal_spare match {
        case SomeMut(v) =>
            32L
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Decode expectedValue */
    val pVal_expectedValue = TDummyType_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 36L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 40L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Decode eventDefinition_ID */
    val pVal_eventDefinition_ID = TEventDefinition_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 72L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_3 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 72L)
    }
    val pVal = TExpectedValueCheckingCriteria(pVal_mask, pVal_spare, pVal_expectedValue, pVal_eventDefinition_ID)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3)
    }

    TExpectedValueCheckingCriteria_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TExpectedValueCheckingCriteria](l)
        case Right(_) => RightMut[ErrorCode, TExpectedValueCheckingCriteria](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TExpectedValueCheckingCriteria]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TExpectedValueCheckingCriteria_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TExpectedValueCheckingCriteria_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TExpectedValueCheckingCriteria]) =
{
    require(codec.base.bitStream.validate_offset_bits(72L))
    val cpy = snapshot(codec)
    val res = TExpectedValueCheckingCriteria_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def ExpectedValueCheckingCriteria_spare_Optional_ACN_Decode(codec: ACN): EitherMut[Int, OptionMut[TEventDefinitionSpare]] = {
    require(codec.base.bitStream.validate_offset_bits(32L))
    @ghost val oldCdc = snapshot(codec)
    /* Decode spare */
    /* marked as ALWAYS PRESENT */
    val spare: OptionMut[TEventDefinitionSpare] =
        val pVal_spare = TEventDefinitionSpare_ACN_Decode(codec) match // uper:13
            case RightMut(decData) => decData
            case LeftMut(err) => return LeftMut(err)
        SomeMut(pVal_spare)
    RightMut[Int, OptionMut[TEventDefinitionSpare]](spare)
}.ensuring { (res: EitherMut[Int, OptionMut[TEventDefinitionSpare]]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            resVal.isDefined && old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L
    }
}



@ghost @pure
def ExpectedValueCheckingCriteria_spare_Optional_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, OptionMut[TEventDefinitionSpare]]) = {
    require(codec.base.bitStream.validate_offset_bits(32L))
    val cpy = snapshot(codec)
    val res = ExpectedValueCheckingCriteria_spare_Optional_ACN_Decode(cpy)
    (cpy, res)
}



def TCheckTypeCriteria_IsConstraintValid(pVal: TCheckTypeCriteria): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TCheckTypeCriteria.CheckTypeCriteria_expectedValueChecking_PRESENT(expectedValueChecking) =>
            ret = TExpectedValueCheckingCriteria_IsConstraintValid(expectedValueChecking)
        case TCheckTypeCriteria.CheckTypeCriteria_limitChecking_PRESENT(limitChecking) =>
            ret = TLimitCheckingCriteria_IsConstraintValid(limitChecking)
        case TCheckTypeCriteria.CheckTypeCriteria_deltaChecking_PRESENT(deltaChecking) =>
            ret = TDeltaCheckingCriteria_IsConstraintValid(deltaChecking)
    ret
}

def TCheckTypeCriteria_Initialize(): TCheckTypeCriteria = TCheckTypeCriteria.CheckTypeCriteria_expectedValueChecking_PRESENT(TExpectedValueCheckingCriteria_Initialize())

def TParameterMonitoringDefinition_IsConstraintValid(pVal: TParameterMonitoringDefinition): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TPMON_ID_IsConstraintValid(pVal.pmon_ID)
    if ret.isRight then
        ret = TParameter_ID_IsConstraintValid(pVal.monitoredParameter_ID)
        if ret.isRight then
            pVal.checkValidityCondition match
                case SomeMut(checkValidityCondition) =>
                    ret = TCheckValidityCondition_IsConstraintValid(checkValidityCondition)
                case NoneMut() =>
            if ret.isRight then
                pVal.monitoringInterval match
                    case SomeMut(monitoringInterval) =>
                        ret = TPUSC_UINT32_IsConstraintValid(monitoringInterval)
                    case NoneMut() =>
                if ret.isRight then
                    ret = TPUSC_UINT32_IsConstraintValid(pVal.repetitionNumber)
                    if ret.isRight then
                        ret = TCheckTypeCriteria_IsConstraintValid(pVal.checkTypeCriteria)
    if ret.isRight then
        ret = (pVal.checkValidityCondition.isDefined == true) match
            case true =>
                Right(0)
            case false =>
                Left(45)
        if ret.isRight then
            ret = (pVal.monitoringInterval.isDefined == true) match
                case true =>
                    Right(0)
                case false =>
                    Left(45)
    ret
}

def TParameterMonitoringDefinition_Initialize(): TParameterMonitoringDefinition = TParameterMonitoringDefinition(pmon_ID = TPMON_ID.Tparam0, monitoredParameter_ID = TParameter_ID.Tparam1, checkValidityCondition = SomeMut(TCheckValidityCondition_Initialize()), monitoringInterval = SomeMut(ULong.fromRaw(0L)), repetitionNumber = ULong.fromRaw(0L), checkTypeCriteria = TCheckTypeCriteria_Initialize())

@opaque @inlineOnce 
def TParameterMonitoringDefinition_ACN_Encode(pVal: TParameterMonitoringDefinition, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(290L))
    TParameterMonitoringDefinition_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode pmon_ID */
    TPMON_ID_ACN_Encode(pVal.pmon_ID, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 290L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode monitoredParameter_ID */
    TParameter_ID_ACN_Encode(pVal.monitoredParameter_ID, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 258L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    ParameterMonitoringDefinition_checkValidityCondition_Optional_ACN_Encode(codec, pVal, pVal.checkValidityCondition) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 226L, 56L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 120L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = pVal.checkValidityCondition match {
        case SomeMut(v) =>
            v.size(codec_0_3.base.bitStream.bitIndex)
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    ParameterMonitoringDefinition_monitoringInterval_Optional_ACN_Encode(codec, pVal, pVal.monitoringInterval) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 170L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 152L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_3 = pVal.monitoringInterval match {
        case SomeMut(v) =>
            32L
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Encode repetitionNumber */
    TPUSC_UINT32_ACN_Encode(pVal.repetitionNumber, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_5.base.bitStream, codec.base.bitStream, 138L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 184L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_4 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    @ghost val codec_0_6 = snapshot(codec)
    val ParameterMonitoringDefinition_checkType = pVal.checkTypeCriteria match
        case TCheckTypeCriteria.CheckTypeCriteria_expectedValueChecking_PRESENT(_) =>TPMON_CheckType.TexpectedValueChecking
        case TCheckTypeCriteria.CheckTypeCriteria_limitChecking_PRESENT(_) =>TPMON_CheckType.TlimitChecking
        case TCheckTypeCriteria.CheckTypeCriteria_deltaChecking_PRESENT(_) =>TPMON_CheckType.TdeltaChecking

    /* Encode ParameterMonitoringDefinition_checkType */
    val intVal_ParameterMonitoringDefinition_checkType = ParameterMonitoringDefinition_checkType match
        case TPMON_CheckType.TexpectedValueChecking => ULong.fromRaw(0L)
        case TPMON_CheckType.TlimitChecking => ULong.fromRaw(1L)
        case TPMON_CheckType.TdeltaChecking => ULong.fromRaw(2L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(2))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 2)
            bitCountLemma(intVal_ParameterMonitoringDefinition_checkType)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(intVal_ParameterMonitoringDefinition_checkType, 2)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_6.base.bitStream, codec.base.bitStream, 106L, 2L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 186L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_5 = 2L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5)
    }
    @ghost val codec_0_7 = snapshot(codec)
    /* Encode checkTypeCriteria */
    ParameterMonitoringDefinition_checkTypeCriteria_ACN_Encode(codec, pVal, ParameterMonitoringDefinition_checkType, pVal.checkTypeCriteria) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 290L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_6 = pVal.checkTypeCriteria match {
        case TCheckTypeCriteria.CheckTypeCriteria_expectedValueChecking_PRESENT(expectedValueChecking) =>
            expectedValueChecking.size(codec_0_7.base.bitStream.bitIndex)
        case TCheckTypeCriteria.CheckTypeCriteria_limitChecking_PRESENT(limitChecking) =>
            limitChecking.size(codec_0_7.base.bitStream.bitIndex)
        case TCheckTypeCriteria.CheckTypeCriteria_deltaChecking_PRESENT(deltaChecking) =>
            deltaChecking.size(codec_0_7.base.bitStream.bitIndex)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 290L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def ParameterMonitoringDefinition_checkValidityCondition_Optional_ACN_Encode(codec: ACN, pVal: TParameterMonitoringDefinition, checkValidityCondition: OptionMut[TCheckValidityCondition]): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(56L))
    @ghost val oldCdc = snapshot(codec)
    /* Encode checkValidityCondition */
    /* marked as ALWAYS PRESENT, so it must be Some */
    checkValidityCondition match
        case SomeMut(checkValidityCondition) =>
            TCheckValidityCondition_ACN_Encode(checkValidityCondition, codec, false) match // uper:6
                case Right(_) =>
                case Left(err) => return Left(err)
        case NoneMut() => return Left(628)
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + checkValidityCondition.get.size(old(codec).base.bitStream.bitIndex)
    }
}



@opaque @inlineOnce
def ParameterMonitoringDefinition_monitoringInterval_Optional_ACN_Encode(codec: ACN, pVal: TParameterMonitoringDefinition, monitoringInterval: OptionMut[ULong]): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(32L))
    @ghost val oldCdc = snapshot(codec)
    /* Encode monitoringInterval */
    /* marked as ALWAYS PRESENT, so it must be Some */
    monitoringInterval match
        case SomeMut(monitoringInterval) =>
            TPUSC_UINT32_ACN_Encode(monitoringInterval, codec, false) match // uper:6
                case Right(_) =>
                case Left(err) => return Left(err)
        case NoneMut() => return Left(628)
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L
    }
}



@opaque @inlineOnce
def ParameterMonitoringDefinition_checkTypeCriteria_ACN_Encode(codec: ACN, pVal: TParameterMonitoringDefinition, ParameterMonitoringDefinition_checkType: TPMON_CheckType, checkTypeCriteria: TCheckTypeCriteria): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(104L))
    @ghost val oldCdc = snapshot(codec)
    TCheckTypeCriteria_IsConstraintValid(checkTypeCriteria) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    checkTypeCriteria match
        case TCheckTypeCriteria.CheckTypeCriteria_expectedValueChecking_PRESENT(expectedValueChecking) =>
            TExpectedValueCheckingCriteria_ACN_Encode(expectedValueChecking, codec, false) match // uper:6
                case Right(_) =>
                case Left(err) => return Left(err)
        case TCheckTypeCriteria.CheckTypeCriteria_limitChecking_PRESENT(limitChecking) =>
            TLimitCheckingCriteria_ACN_Encode(limitChecking, codec, false) match // uper:6
                case Right(_) =>
                case Left(err) => return Left(err)
        case TCheckTypeCriteria.CheckTypeCriteria_deltaChecking_PRESENT(deltaChecking) =>
            TDeltaCheckingCriteria_ACN_Encode(deltaChecking, codec, false) match // uper:6
                case Right(_) =>
                case Left(err) => return Left(err)
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + checkTypeCriteria.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TParameterMonitoringDefinition_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TParameterMonitoringDefinition] =
{
    require(codec.base.bitStream.validate_offset_bits(290L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode pmon_ID */
    val pVal_pmon_ID = TPMON_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 290L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode monitoredParameter_ID */
    val pVal_monitoredParameter_ID = TParameter_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 258L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    val pVal_checkValidityCondition = ParameterMonitoringDefinition_checkValidityCondition_Optional_ACN_Decode(codec) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 226L, 56L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 120L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = pVal_checkValidityCondition match {
        case SomeMut(v) =>
            v.size(codec_0_3.base.bitStream.bitIndex)
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    val pVal_monitoringInterval = ParameterMonitoringDefinition_monitoringInterval_Optional_ACN_Decode(codec) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 170L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 152L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_3 = pVal_monitoringInterval match {
        case SomeMut(v) =>
            32L
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Decode repetitionNumber */
    val pVal_repetitionNumber = TPUSC_UINT32_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_5.base.bitStream, codec.base.bitStream, 138L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 184L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_4 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    @ghost val codec_0_6 = snapshot(codec)
    /* Decode ParameterMonitoringDefinition_checkType */
    val intVal_ParameterMonitoringDefinition_checkType = codec.dec_Int_PositiveInteger_ConstSize(2)

    val ParameterMonitoringDefinition_checkType = intVal_ParameterMonitoringDefinition_checkType.toRaw match
        case 0 => TPMON_CheckType.TexpectedValueChecking
        case 1 => TPMON_CheckType.TlimitChecking
        case 2 => TPMON_CheckType.TdeltaChecking
        case _ => return LeftMut(ERR_ACN_DECODE_PARAMETERMONITORINGDEFINITION_CHECKTYPE)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_6.base.bitStream, codec.base.bitStream, 106L, 2L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 186L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_5 = 2L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5)
    }
    @ghost val codec_0_7 = snapshot(codec)
    /* Decode checkTypeCriteria */
    val pVal_checkTypeCriteria = ParameterMonitoringDefinition_checkTypeCriteria_ACN_Decode(codec, ParameterMonitoringDefinition_checkType) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 290L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_6 = pVal_checkTypeCriteria match {
        case TCheckTypeCriteria.CheckTypeCriteria_expectedValueChecking_PRESENT(expectedValueChecking) =>
            expectedValueChecking.size(codec_0_7.base.bitStream.bitIndex)
        case TCheckTypeCriteria.CheckTypeCriteria_limitChecking_PRESENT(limitChecking) =>
            limitChecking.size(codec_0_7.base.bitStream.bitIndex)
        case TCheckTypeCriteria.CheckTypeCriteria_deltaChecking_PRESENT(deltaChecking) =>
            deltaChecking.size(codec_0_7.base.bitStream.bitIndex)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 290L)
    }
    val pVal = TParameterMonitoringDefinition(pVal_pmon_ID, pVal_monitoredParameter_ID, pVal_checkValidityCondition, pVal_monitoringInterval, pVal_repetitionNumber, pVal_checkTypeCriteria)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6)
    }

    TParameterMonitoringDefinition_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TParameterMonitoringDefinition](l)
        case Right(_) => RightMut[ErrorCode, TParameterMonitoringDefinition](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TParameterMonitoringDefinition]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TParameterMonitoringDefinition_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TParameterMonitoringDefinition_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TParameterMonitoringDefinition]) =
{
    require(codec.base.bitStream.validate_offset_bits(290L))
    val cpy = snapshot(codec)
    val res = TParameterMonitoringDefinition_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def ParameterMonitoringDefinition_checkValidityCondition_Optional_ACN_Decode(codec: ACN): EitherMut[Int, OptionMut[TCheckValidityCondition]] = {
    require(codec.base.bitStream.validate_offset_bits(56L))
    @ghost val oldCdc = snapshot(codec)
    /* Decode checkValidityCondition */
    /* marked as ALWAYS PRESENT */
    val checkValidityCondition: OptionMut[TCheckValidityCondition] =
        val pVal_checkValidityCondition = TCheckValidityCondition_ACN_Decode(codec) match // uper:13
            case RightMut(decData) => decData
            case LeftMut(err) => return LeftMut(err)
        SomeMut(pVal_checkValidityCondition)
    RightMut[Int, OptionMut[TCheckValidityCondition]](checkValidityCondition)
}.ensuring { (res: EitherMut[Int, OptionMut[TCheckValidityCondition]]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            resVal.isDefined && old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.get.size(old(codec).base.bitStream.bitIndex)
    }
}



@ghost @pure
def ParameterMonitoringDefinition_checkValidityCondition_Optional_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, OptionMut[TCheckValidityCondition]]) = {
    require(codec.base.bitStream.validate_offset_bits(56L))
    val cpy = snapshot(codec)
    val res = ParameterMonitoringDefinition_checkValidityCondition_Optional_ACN_Decode(cpy)
    (cpy, res)
}



@opaque @inlineOnce
def ParameterMonitoringDefinition_monitoringInterval_Optional_ACN_Decode(codec: ACN): EitherMut[Int, OptionMut[ULong]] = {
    require(codec.base.bitStream.validate_offset_bits(32L))
    @ghost val oldCdc = snapshot(codec)
    /* Decode monitoringInterval */
    /* marked as ALWAYS PRESENT */
    val monitoringInterval: OptionMut[TPUSC_UINT32] =
        val pVal_monitoringInterval = TPUSC_UINT32_ACN_Decode(codec) match // uper:13
            case RightMut(decData) => decData
            case LeftMut(err) => return LeftMut(err)
        SomeMut(pVal_monitoringInterval)
    RightMut[Int, OptionMut[ULong]](monitoringInterval)
}.ensuring { (res: EitherMut[Int, OptionMut[ULong]]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            resVal.isDefined && old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L
    }
}



@ghost @pure
def ParameterMonitoringDefinition_monitoringInterval_Optional_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, OptionMut[ULong]]) = {
    require(codec.base.bitStream.validate_offset_bits(32L))
    val cpy = snapshot(codec)
    val res = ParameterMonitoringDefinition_monitoringInterval_Optional_ACN_Decode(cpy)
    (cpy, res)
}



@opaque @inlineOnce
def ParameterMonitoringDefinition_checkTypeCriteria_ACN_Decode(codec: ACN, ParameterMonitoringDefinition_checkType: TPMON_CheckType): EitherMut[Int, TCheckTypeCriteria] = {
    require(codec.base.bitStream.validate_offset_bits(104L))
    @ghost val oldCdc = snapshot(codec)
    val checkTypeCriteria = ParameterMonitoringDefinition_checkType match
        case TPMON_CheckType.TexpectedValueChecking =>
            val expectedValueChecking = TExpectedValueCheckingCriteria_ACN_Decode(codec) match // uper:13
                case RightMut(decData) => decData
                case LeftMut(err) => return LeftMut(err)
            TCheckTypeCriteria.CheckTypeCriteria_expectedValueChecking_PRESENT(expectedValueChecking)
        case TPMON_CheckType.TlimitChecking =>
            val limitChecking = TLimitCheckingCriteria_ACN_Decode(codec) match // uper:13
                case RightMut(decData) => decData
                case LeftMut(err) => return LeftMut(err)
            TCheckTypeCriteria.CheckTypeCriteria_limitChecking_PRESENT(limitChecking)
        case TPMON_CheckType.TdeltaChecking =>
            val deltaChecking = TDeltaCheckingCriteria_ACN_Decode(codec) match // uper:13
                case RightMut(decData) => decData
                case LeftMut(err) => return LeftMut(err)
            TCheckTypeCriteria.CheckTypeCriteria_deltaChecking_PRESENT(deltaChecking)
    TCheckTypeCriteria_IsConstraintValid(checkTypeCriteria) match {
        case Left(l) =>
            LeftMut[Int, TCheckTypeCriteria](l)
        case Right(_) =>
            RightMut[Int, TCheckTypeCriteria](checkTypeCriteria)
    }
}.ensuring { (res: EitherMut[Int, TCheckTypeCriteria]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TCheckTypeCriteria_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def ParameterMonitoringDefinition_checkTypeCriteria_ACN_Decode_pure(codec: ACN, ParameterMonitoringDefinition_checkType: TPMON_CheckType): (ACN, EitherMut[Int, TCheckTypeCriteria]) = {
    require(codec.base.bitStream.validate_offset_bits(104L))
    val cpy = snapshot(codec)
    val res = ParameterMonitoringDefinition_checkTypeCriteria_ACN_Decode(cpy, ParameterMonitoringDefinition_checkType)
    (cpy, res)
}

def TTC_12_7_ParameterMonitoringDefinition_IsConstraintValid(pVal: TTC_12_7_ParameterMonitoringDefinition): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TPMON_ID_IsConstraintValid(pVal.pmon_ID)
    if ret.isRight then
        ret = TParameter_ID_IsConstraintValid(pVal.monitoredParameter_ID)
        if ret.isRight then
            pVal.checkValidityCondition match
                case SomeMut(checkValidityCondition) =>
                    ret = TCheckValidityCondition_IsConstraintValid(checkValidityCondition)
                case NoneMut() =>
            if ret.isRight then
                pVal.monitoringInterval match
                    case SomeMut(monitoringInterval) =>
                        ret = TPUSC_UINT32_IsConstraintValid(monitoringInterval)
                    case NoneMut() =>
                if ret.isRight then
                    ret = TPUSC_UINT32_IsConstraintValid(pVal.repetitionNumber)
                    if ret.isRight then
                        ret = TCheckTypeCriteria_IsConstraintValid(pVal.checkTypeCriteria)
    if ret.isRight then
        ret = (pVal.checkValidityCondition.isDefined == false) match
            case true =>
                Right(0)
            case false =>
                Left(45)
        if ret.isRight then
            ret = (pVal.monitoringInterval.isDefined == false) match
                case true =>
                    Right(0)
                case false =>
                    Left(45)
    ret
}

def TTC_12_7_ParameterMonitoringDefinition_Initialize(): TTC_12_7_ParameterMonitoringDefinition = TTC_12_7_ParameterMonitoringDefinition(pmon_ID = TPMON_ID.Tparam0, monitoredParameter_ID = TParameter_ID.Tparam1, checkValidityCondition = NoneMut(), monitoringInterval = NoneMut(), repetitionNumber = ULong.fromRaw(0L), checkTypeCriteria = TCheckTypeCriteria_Initialize())

@opaque @inlineOnce 
def TTC_12_7_ParameterMonitoringDefinition_ACN_Encode(pVal: TTC_12_7_ParameterMonitoringDefinition, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(202L))
    TTC_12_7_ParameterMonitoringDefinition_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode pmon_ID */
    TPMON_ID_ACN_Encode(pVal.pmon_ID, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 202L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode monitoredParameter_ID */
    TParameter_ID_ACN_Encode(pVal.monitoredParameter_ID, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 170L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    TC_12_7_ParameterMonitoringDefinition_checkValidityCondition_Optional_ACN_Encode(codec, pVal, pVal.checkValidityCondition) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 138L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = pVal.checkValidityCondition match {
        case SomeMut(v) =>
            v.size(codec_0_3.base.bitStream.bitIndex)
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    TC_12_7_ParameterMonitoringDefinition_monitoringInterval_Optional_ACN_Encode(codec, pVal, pVal.monitoringInterval) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 138L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_3 = pVal.monitoringInterval match {
        case SomeMut(v) =>
            32L
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Encode repetitionNumber */
    TPUSC_UINT32_ACN_Encode(pVal.repetitionNumber, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_5.base.bitStream, codec.base.bitStream, 138L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 96L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_4 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    @ghost val codec_0_6 = snapshot(codec)
    val TC_12_7_ParameterMonitoringDefinition_checkType = pVal.checkTypeCriteria match
        case TCheckTypeCriteria.CheckTypeCriteria_expectedValueChecking_PRESENT(_) =>TPMON_CheckType.TexpectedValueChecking
        case TCheckTypeCriteria.CheckTypeCriteria_limitChecking_PRESENT(_) =>TPMON_CheckType.TlimitChecking
        case TCheckTypeCriteria.CheckTypeCriteria_deltaChecking_PRESENT(_) =>TPMON_CheckType.TdeltaChecking

    /* Encode TC_12_7_ParameterMonitoringDefinition_checkType */
    val intVal_TC_12_7_ParameterMonitoringDefinition_checkType = TC_12_7_ParameterMonitoringDefinition_checkType match
        case TPMON_CheckType.TexpectedValueChecking => ULong.fromRaw(0L)
        case TPMON_CheckType.TlimitChecking => ULong.fromRaw(1L)
        case TPMON_CheckType.TdeltaChecking => ULong.fromRaw(2L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(2))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 2)
            bitCountLemma(intVal_TC_12_7_ParameterMonitoringDefinition_checkType)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(intVal_TC_12_7_ParameterMonitoringDefinition_checkType, 2)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_6.base.bitStream, codec.base.bitStream, 106L, 2L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 98L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_5 = 2L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5)
    }
    @ghost val codec_0_7 = snapshot(codec)
    /* Encode checkTypeCriteria */
    TC_12_7_ParameterMonitoringDefinition_checkTypeCriteria_ACN_Encode(codec, pVal, TC_12_7_ParameterMonitoringDefinition_checkType, pVal.checkTypeCriteria) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 202L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_6 = pVal.checkTypeCriteria match {
        case TCheckTypeCriteria.CheckTypeCriteria_expectedValueChecking_PRESENT(expectedValueChecking) =>
            expectedValueChecking.size(codec_0_7.base.bitStream.bitIndex)
        case TCheckTypeCriteria.CheckTypeCriteria_limitChecking_PRESENT(limitChecking) =>
            limitChecking.size(codec_0_7.base.bitStream.bitIndex)
        case TCheckTypeCriteria.CheckTypeCriteria_deltaChecking_PRESENT(deltaChecking) =>
            deltaChecking.size(codec_0_7.base.bitStream.bitIndex)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 202L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def TC_12_7_ParameterMonitoringDefinition_checkValidityCondition_Optional_ACN_Encode(codec: ACN, pVal: TTC_12_7_ParameterMonitoringDefinition, checkValidityCondition: OptionMut[TCheckValidityCondition]): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(56L))
    @ghost val oldCdc = snapshot(codec)
    /* Encode checkValidityCondition */
    /* marked as ALWAYS ABSENT, so do not encode anything */
    
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex
    }
}



@opaque @inlineOnce
def TC_12_7_ParameterMonitoringDefinition_monitoringInterval_Optional_ACN_Encode(codec: ACN, pVal: TTC_12_7_ParameterMonitoringDefinition, monitoringInterval: OptionMut[ULong]): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(32L))
    @ghost val oldCdc = snapshot(codec)
    /* Encode monitoringInterval */
    /* marked as ALWAYS ABSENT, so do not encode anything */
    
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex
    }
}



@opaque @inlineOnce
def TC_12_7_ParameterMonitoringDefinition_checkTypeCriteria_ACN_Encode(codec: ACN, pVal: TTC_12_7_ParameterMonitoringDefinition, TC_12_7_ParameterMonitoringDefinition_checkType: TPMON_CheckType, checkTypeCriteria: TCheckTypeCriteria): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(104L))
    @ghost val oldCdc = snapshot(codec)
    TCheckTypeCriteria_IsConstraintValid(checkTypeCriteria) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    checkTypeCriteria match
        case TCheckTypeCriteria.CheckTypeCriteria_expectedValueChecking_PRESENT(expectedValueChecking) =>
            TExpectedValueCheckingCriteria_ACN_Encode(expectedValueChecking, codec, false) match // uper:6
                case Right(_) =>
                case Left(err) => return Left(err)
        case TCheckTypeCriteria.CheckTypeCriteria_limitChecking_PRESENT(limitChecking) =>
            TLimitCheckingCriteria_ACN_Encode(limitChecking, codec, false) match // uper:6
                case Right(_) =>
                case Left(err) => return Left(err)
        case TCheckTypeCriteria.CheckTypeCriteria_deltaChecking_PRESENT(deltaChecking) =>
            TDeltaCheckingCriteria_ACN_Encode(deltaChecking, codec, false) match // uper:6
                case Right(_) =>
                case Left(err) => return Left(err)
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + checkTypeCriteria.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TTC_12_7_ParameterMonitoringDefinition_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TTC_12_7_ParameterMonitoringDefinition] =
{
    require(codec.base.bitStream.validate_offset_bits(202L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode pmon_ID */
    val pVal_pmon_ID = TPMON_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 202L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode monitoredParameter_ID */
    val pVal_monitoredParameter_ID = TParameter_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 170L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    val pVal_checkValidityCondition = TC_12_7_ParameterMonitoringDefinition_checkValidityCondition_Optional_ACN_Decode(codec) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 138L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = pVal_checkValidityCondition match {
        case SomeMut(v) =>
            v.size(codec_0_3.base.bitStream.bitIndex)
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    val pVal_monitoringInterval = TC_12_7_ParameterMonitoringDefinition_monitoringInterval_Optional_ACN_Decode(codec) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 138L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_3 = pVal_monitoringInterval match {
        case SomeMut(v) =>
            32L
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Decode repetitionNumber */
    val pVal_repetitionNumber = TPUSC_UINT32_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_5.base.bitStream, codec.base.bitStream, 138L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 96L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_4 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    @ghost val codec_0_6 = snapshot(codec)
    /* Decode TC_12_7_ParameterMonitoringDefinition_checkType */
    val intVal_TC_12_7_ParameterMonitoringDefinition_checkType = codec.dec_Int_PositiveInteger_ConstSize(2)

    val TC_12_7_ParameterMonitoringDefinition_checkType = intVal_TC_12_7_ParameterMonitoringDefinition_checkType.toRaw match
        case 0 => TPMON_CheckType.TexpectedValueChecking
        case 1 => TPMON_CheckType.TlimitChecking
        case 2 => TPMON_CheckType.TdeltaChecking
        case _ => return LeftMut(ERR_ACN_DECODE_TC_12_7_PARAMETERMONITORINGDEFINITION_CHECKTYPE)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_6.base.bitStream, codec.base.bitStream, 106L, 2L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 98L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_5 = 2L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5)
    }
    @ghost val codec_0_7 = snapshot(codec)
    /* Decode checkTypeCriteria */
    val pVal_checkTypeCriteria = TC_12_7_ParameterMonitoringDefinition_checkTypeCriteria_ACN_Decode(codec, TC_12_7_ParameterMonitoringDefinition_checkType) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 202L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_6 = pVal_checkTypeCriteria match {
        case TCheckTypeCriteria.CheckTypeCriteria_expectedValueChecking_PRESENT(expectedValueChecking) =>
            expectedValueChecking.size(codec_0_7.base.bitStream.bitIndex)
        case TCheckTypeCriteria.CheckTypeCriteria_limitChecking_PRESENT(limitChecking) =>
            limitChecking.size(codec_0_7.base.bitStream.bitIndex)
        case TCheckTypeCriteria.CheckTypeCriteria_deltaChecking_PRESENT(deltaChecking) =>
            deltaChecking.size(codec_0_7.base.bitStream.bitIndex)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 202L)
    }
    val pVal = TTC_12_7_ParameterMonitoringDefinition(pVal_pmon_ID, pVal_monitoredParameter_ID, pVal_checkValidityCondition, pVal_monitoringInterval, pVal_repetitionNumber, pVal_checkTypeCriteria)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6)
    }

    TTC_12_7_ParameterMonitoringDefinition_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TTC_12_7_ParameterMonitoringDefinition](l)
        case Right(_) => RightMut[ErrorCode, TTC_12_7_ParameterMonitoringDefinition](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TTC_12_7_ParameterMonitoringDefinition]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TTC_12_7_ParameterMonitoringDefinition_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TTC_12_7_ParameterMonitoringDefinition_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TTC_12_7_ParameterMonitoringDefinition]) =
{
    require(codec.base.bitStream.validate_offset_bits(202L))
    val cpy = snapshot(codec)
    val res = TTC_12_7_ParameterMonitoringDefinition_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def TC_12_7_ParameterMonitoringDefinition_checkValidityCondition_Optional_ACN_Decode(codec: ACN): EitherMut[Int, OptionMut[TCheckValidityCondition]] = {
    require(codec.base.bitStream.validate_offset_bits(56L))
    @ghost val oldCdc = snapshot(codec)
    /* Decode checkValidityCondition */
    /* marked as ALWAYS ABSENT, so do not decode anything */
    val checkValidityCondition: OptionMut[TCheckValidityCondition] = NoneMut[TCheckValidityCondition]()
    RightMut[Int, OptionMut[TCheckValidityCondition]](checkValidityCondition)
}.ensuring { (res: EitherMut[Int, OptionMut[TCheckValidityCondition]]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            !resVal.isDefined && old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex
    }
}



@ghost @pure
def TC_12_7_ParameterMonitoringDefinition_checkValidityCondition_Optional_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, OptionMut[TCheckValidityCondition]]) = {
    require(codec.base.bitStream.validate_offset_bits(56L))
    val cpy = snapshot(codec)
    val res = TC_12_7_ParameterMonitoringDefinition_checkValidityCondition_Optional_ACN_Decode(cpy)
    (cpy, res)
}



@opaque @inlineOnce
def TC_12_7_ParameterMonitoringDefinition_monitoringInterval_Optional_ACN_Decode(codec: ACN): EitherMut[Int, OptionMut[ULong]] = {
    require(codec.base.bitStream.validate_offset_bits(32L))
    @ghost val oldCdc = snapshot(codec)
    /* Decode monitoringInterval */
    /* marked as ALWAYS ABSENT, so do not decode anything */
    val monitoringInterval: OptionMut[TPUSC_UINT32] = NoneMut[TPUSC_UINT32]()
    RightMut[Int, OptionMut[ULong]](monitoringInterval)
}.ensuring { (res: EitherMut[Int, OptionMut[ULong]]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            !resVal.isDefined && old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex
    }
}



@ghost @pure
def TC_12_7_ParameterMonitoringDefinition_monitoringInterval_Optional_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, OptionMut[ULong]]) = {
    require(codec.base.bitStream.validate_offset_bits(32L))
    val cpy = snapshot(codec)
    val res = TC_12_7_ParameterMonitoringDefinition_monitoringInterval_Optional_ACN_Decode(cpy)
    (cpy, res)
}



@opaque @inlineOnce
def TC_12_7_ParameterMonitoringDefinition_checkTypeCriteria_ACN_Decode(codec: ACN, TC_12_7_ParameterMonitoringDefinition_checkType: TPMON_CheckType): EitherMut[Int, TCheckTypeCriteria] = {
    require(codec.base.bitStream.validate_offset_bits(104L))
    @ghost val oldCdc = snapshot(codec)
    val checkTypeCriteria = TC_12_7_ParameterMonitoringDefinition_checkType match
        case TPMON_CheckType.TexpectedValueChecking =>
            val expectedValueChecking = TExpectedValueCheckingCriteria_ACN_Decode(codec) match // uper:13
                case RightMut(decData) => decData
                case LeftMut(err) => return LeftMut(err)
            TCheckTypeCriteria.CheckTypeCriteria_expectedValueChecking_PRESENT(expectedValueChecking)
        case TPMON_CheckType.TlimitChecking =>
            val limitChecking = TLimitCheckingCriteria_ACN_Decode(codec) match // uper:13
                case RightMut(decData) => decData
                case LeftMut(err) => return LeftMut(err)
            TCheckTypeCriteria.CheckTypeCriteria_limitChecking_PRESENT(limitChecking)
        case TPMON_CheckType.TdeltaChecking =>
            val deltaChecking = TDeltaCheckingCriteria_ACN_Decode(codec) match // uper:13
                case RightMut(decData) => decData
                case LeftMut(err) => return LeftMut(err)
            TCheckTypeCriteria.CheckTypeCriteria_deltaChecking_PRESENT(deltaChecking)
    TCheckTypeCriteria_IsConstraintValid(checkTypeCriteria) match {
        case Left(l) =>
            LeftMut[Int, TCheckTypeCriteria](l)
        case Right(_) =>
            RightMut[Int, TCheckTypeCriteria](checkTypeCriteria)
    }
}.ensuring { (res: EitherMut[Int, TCheckTypeCriteria]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TCheckTypeCriteria_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def TC_12_7_ParameterMonitoringDefinition_checkTypeCriteria_ACN_Decode_pure(codec: ACN, TC_12_7_ParameterMonitoringDefinition_checkType: TPMON_CheckType): (ACN, EitherMut[Int, TCheckTypeCriteria]) = {
    require(codec.base.bitStream.validate_offset_bits(104L))
    val cpy = snapshot(codec)
    val res = TC_12_7_ParameterMonitoringDefinition_checkTypeCriteria_ACN_Decode(cpy, TC_12_7_ParameterMonitoringDefinition_checkType)
    (cpy, res)
}