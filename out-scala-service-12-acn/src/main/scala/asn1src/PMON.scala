/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang.{ghost => ghostExpr, _}
import stainless.annotation._
import stainless.collection._
import stainless.proof._
import StaticChecks._


def TPMON_ID_IsConstraintValid(pVal: TPMON_ID): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal == TPMON_ID.Tparam0) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPMON_ID_Initialize(): TPMON_ID = TPMON_ID.Tparam0

@opaque @inlineOnce 
def TPMON_ID_ACN_Encode(pVal: TPMON_ID, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    TPMON_ID_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TPMON_ID.Tparam0 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(0))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 4294967295L)
            bitCountLemma(intVal_pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_32(intVal_pVal)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L
    }
}

@opaque @inlineOnce 
def TPMON_ID_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPMON_ID] =
{
    require(codec.base.bitStream.validate_offset_bits(32L))

    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = codec.dec_Int_PositiveInteger_ConstSize_big_endian_32()

    val pVal = intVal_pVal.toRaw match
        case 0 => TPMON_ID.Tparam0
        case _ => return LeftMut(ERR_ACN_DECODE_PMON_ID)

    TPMON_ID_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPMON_ID](l)
        case Right(_) => RightMut[ErrorCode, TPMON_ID](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPMON_ID]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L && TPMON_ID_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPMON_ID_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPMON_ID]) =
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    val cpy = snapshot(codec)
    val res = TPMON_ID_ACN_Decode(cpy)
    (cpy, res)
}

def TPMON_ParameterValue_param0_IsConstraintValid(pVal: TPMON_ParameterValue_param0): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(255L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPMON_ParameterValue_IsConstraintValid(pVal: TPMON_ParameterValue): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TPMON_ParameterValue.PMON_ParameterValue_param0_PRESENT(param0) =>
            ret = TPMON_ParameterValue_param0_IsConstraintValid(param0)
    ret
}

def TPMON_ParameterValue_param0_Initialize(): TPMON_ParameterValue_param0 = ULong.fromRaw(0L)
def TPMON_ParameterValue_Initialize(): TPMON_ParameterValue = TPMON_ParameterValue.PMON_ParameterValue_param0_PRESENT(ULong.fromRaw(0L))

def TPMON_Mask_param0_IsConstraintValid(@annotation.unused pVal: TPMON_Mask_param0): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TPMON_Mask_IsConstraintValid(pVal: TPMON_Mask): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TPMON_Mask.PMON_Mask_param0_PRESENT(param0) =>
            ret = TPMON_Mask_param0_IsConstraintValid(param0)
    ret
}

def TPMON_Mask_param0_Initialize(): TPMON_Mask_param0 = TPMON_Mask_param0(Vector.fill(32)(0.toRawUByte))
def TPMON_Mask_Initialize(): TPMON_Mask = TPMON_Mask.PMON_Mask_param0_PRESENT(TPMON_Mask_param0(Vector.fill(32)(0.toRawUByte)))

def TPMON_LimitCrossed_param0_IsConstraintValid(pVal: TPMON_LimitCrossed_param0): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(255L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPMON_LimitCrossed_IsConstraintValid(pVal: TPMON_LimitCrossed): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TPMON_LimitCrossed.PMON_LimitCrossed_param0_PRESENT(param0) =>
            ret = TPMON_LimitCrossed_param0_IsConstraintValid(param0)
    ret
}

def TPMON_LimitCrossed_param0_Initialize(): TPMON_LimitCrossed_param0 = ULong.fromRaw(0L)
def TPMON_LimitCrossed_Initialize(): TPMON_LimitCrossed = TPMON_LimitCrossed.PMON_LimitCrossed_param0_PRESENT(ULong.fromRaw(0L))

def TPMON_CheckType_IsConstraintValid(pVal: TPMON_CheckType): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (((((pVal == TPMON_CheckType.TexpectedValueChecking)) || ((pVal == TPMON_CheckType.TlimitChecking)))) || ((pVal == TPMON_CheckType.TdeltaChecking))) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPMON_CheckType_Initialize(): TPMON_CheckType = TPMON_CheckType.TexpectedValueChecking

@opaque @inlineOnce 
def TPMON_CheckType_ACN_Encode(pVal: TPMON_CheckType, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    TPMON_CheckType_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TPMON_CheckType.TexpectedValueChecking => ULong.fromRaw(0L)
        case TPMON_CheckType.TlimitChecking => ULong.fromRaw(1L)
        case TPMON_CheckType.TdeltaChecking => ULong.fromRaw(2L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(2))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 2)
            bitCountLemma(intVal_pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(intVal_pVal, 2)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L
    }
}

@opaque @inlineOnce 
def TPMON_CheckType_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPMON_CheckType] =
{
    require(codec.base.bitStream.validate_offset_bits(2L))

    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = codec.dec_Int_PositiveInteger_ConstSize(2)

    val pVal = intVal_pVal.toRaw match
        case 0 => TPMON_CheckType.TexpectedValueChecking
        case 1 => TPMON_CheckType.TlimitChecking
        case 2 => TPMON_CheckType.TdeltaChecking
        case _ => return LeftMut(ERR_ACN_DECODE_PMON_CHECKTYPE)

    TPMON_CheckType_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPMON_CheckType](l)
        case Right(_) => RightMut[ErrorCode, TPMON_CheckType](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPMON_CheckType]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L && TPMON_CheckType_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPMON_CheckType_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPMON_CheckType]) =
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    val cpy = snapshot(codec)
    val res = TPMON_CheckType_ACN_Decode(cpy)
    (cpy, res)
}

def TPMON_ExpectedValueCheckMask_IsConstraintValid(pVal: TPMON_ExpectedValueCheckMask): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_expectedValueChecking_PRESENT(expectedValueChecking) =>
            ret = TPMON_Mask_IsConstraintValid(expectedValueChecking)
        case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_limitChecking_PRESENT(limitChecking) =>
            ret = Right(0)
        case TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_deltaChecking_PRESENT(deltaChecking) =>
            ret = Right(0)
    ret
}

def TPMON_ExpectedValueCheckMask_Initialize(): TPMON_ExpectedValueCheckMask = TPMON_ExpectedValueCheckMask.PMON_ExpectedValueCheckMask_expectedValueChecking_PRESENT(TPMON_Mask_Initialize())

def TCheckingStatusForExpectedValueChecking_IsConstraintValid(pVal: TCheckingStatusForExpectedValueChecking): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (((((((pVal == TCheckingStatusForExpectedValueChecking.TexpectedValue)) || ((pVal == TCheckingStatusForExpectedValueChecking.TCheckingStatusForExpectedValueChecking_unchecked)))) || ((pVal == TCheckingStatusForExpectedValueChecking.TCheckingStatusForExpectedValueChecking_invalid)))) || ((pVal == TCheckingStatusForExpectedValueChecking.TunexpectedValue))) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TCheckingStatusForExpectedValueChecking_Initialize(): TCheckingStatusForExpectedValueChecking = TCheckingStatusForExpectedValueChecking.TexpectedValue

@opaque @inlineOnce 
def TCheckingStatusForExpectedValueChecking_ACN_Encode(pVal: TCheckingStatusForExpectedValueChecking, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    TCheckingStatusForExpectedValueChecking_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TCheckingStatusForExpectedValueChecking.TexpectedValue => ULong.fromRaw(0L)
        case TCheckingStatusForExpectedValueChecking.TCheckingStatusForExpectedValueChecking_unchecked => ULong.fromRaw(1L)
        case TCheckingStatusForExpectedValueChecking.TCheckingStatusForExpectedValueChecking_invalid => ULong.fromRaw(2L)
        case TCheckingStatusForExpectedValueChecking.TunexpectedValue => ULong.fromRaw(3L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(3))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 2)
            bitCountLemma(intVal_pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(intVal_pVal, 2)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L
    }
}

@opaque @inlineOnce 
def TCheckingStatusForExpectedValueChecking_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TCheckingStatusForExpectedValueChecking] =
{
    require(codec.base.bitStream.validate_offset_bits(2L))

    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = codec.dec_Int_PositiveInteger_ConstSize(2)

    val pVal = intVal_pVal.toRaw match
        case 0 => TCheckingStatusForExpectedValueChecking.TexpectedValue
        case 1 => TCheckingStatusForExpectedValueChecking.TCheckingStatusForExpectedValueChecking_unchecked
        case 2 => TCheckingStatusForExpectedValueChecking.TCheckingStatusForExpectedValueChecking_invalid
        case 3 => TCheckingStatusForExpectedValueChecking.TunexpectedValue
        case _ => return LeftMut(ERR_ACN_DECODE_CHECKINGSTATUSFOREXPECTEDVALUECHECKING)

    TCheckingStatusForExpectedValueChecking_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TCheckingStatusForExpectedValueChecking](l)
        case Right(_) => RightMut[ErrorCode, TCheckingStatusForExpectedValueChecking](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TCheckingStatusForExpectedValueChecking]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L && TCheckingStatusForExpectedValueChecking_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TCheckingStatusForExpectedValueChecking_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TCheckingStatusForExpectedValueChecking]) =
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    val cpy = snapshot(codec)
    val res = TCheckingStatusForExpectedValueChecking_ACN_Decode(cpy)
    (cpy, res)
}

def TCheckingStatusForLimitChecking_IsConstraintValid(pVal: TCheckingStatusForLimitChecking): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (((((((((pVal == TCheckingStatusForLimitChecking.TwithinLimits)) || ((pVal == TCheckingStatusForLimitChecking.TCheckingStatusForLimitChecking_unchecked)))) || ((pVal == TCheckingStatusForLimitChecking.TCheckingStatusForLimitChecking_invalid)))) || ((pVal == TCheckingStatusForLimitChecking.TbelowLowLimit)))) || ((pVal == TCheckingStatusForLimitChecking.TaboveHighLimit))) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TCheckingStatusForLimitChecking_Initialize(): TCheckingStatusForLimitChecking = TCheckingStatusForLimitChecking.TwithinLimits

@opaque @inlineOnce 
def TCheckingStatusForLimitChecking_ACN_Encode(pVal: TCheckingStatusForLimitChecking, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(3L))
    TCheckingStatusForLimitChecking_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TCheckingStatusForLimitChecking.TwithinLimits => ULong.fromRaw(0L)
        case TCheckingStatusForLimitChecking.TCheckingStatusForLimitChecking_unchecked => ULong.fromRaw(1L)
        case TCheckingStatusForLimitChecking.TCheckingStatusForLimitChecking_invalid => ULong.fromRaw(2L)
        case TCheckingStatusForLimitChecking.TbelowLowLimit => ULong.fromRaw(3L)
        case TCheckingStatusForLimitChecking.TaboveHighLimit => ULong.fromRaw(4L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(4))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 3)
            bitCountLemma(intVal_pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(intVal_pVal, 3)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 3L
    }
}

@opaque @inlineOnce 
def TCheckingStatusForLimitChecking_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TCheckingStatusForLimitChecking] =
{
    require(codec.base.bitStream.validate_offset_bits(3L))

    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = codec.dec_Int_PositiveInteger_ConstSize(3)

    val pVal = intVal_pVal.toRaw match
        case 0 => TCheckingStatusForLimitChecking.TwithinLimits
        case 1 => TCheckingStatusForLimitChecking.TCheckingStatusForLimitChecking_unchecked
        case 2 => TCheckingStatusForLimitChecking.TCheckingStatusForLimitChecking_invalid
        case 3 => TCheckingStatusForLimitChecking.TbelowLowLimit
        case 4 => TCheckingStatusForLimitChecking.TaboveHighLimit
        case _ => return LeftMut(ERR_ACN_DECODE_CHECKINGSTATUSFORLIMITCHECKING)

    TCheckingStatusForLimitChecking_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TCheckingStatusForLimitChecking](l)
        case Right(_) => RightMut[ErrorCode, TCheckingStatusForLimitChecking](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TCheckingStatusForLimitChecking]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 3L && TCheckingStatusForLimitChecking_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TCheckingStatusForLimitChecking_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TCheckingStatusForLimitChecking]) =
{
    require(codec.base.bitStream.validate_offset_bits(3L))
    val cpy = snapshot(codec)
    val res = TCheckingStatusForLimitChecking_ACN_Decode(cpy)
    (cpy, res)
}

def TCheckingStatusForDeltaChecking_IsConstraintValid(pVal: TCheckingStatusForDeltaChecking): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (((((((((pVal == TCheckingStatusForDeltaChecking.TwithinThresholds)) || ((pVal == TCheckingStatusForDeltaChecking.TCheckingStatusForDeltaChecking_unchecked)))) || ((pVal == TCheckingStatusForDeltaChecking.TCheckingStatusForDeltaChecking_invalid)))) || ((pVal == TCheckingStatusForDeltaChecking.TbelowLowTreshold)))) || ((pVal == TCheckingStatusForDeltaChecking.TaboveHighTreshold))) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TCheckingStatusForDeltaChecking_Initialize(): TCheckingStatusForDeltaChecking = TCheckingStatusForDeltaChecking.TwithinThresholds

@opaque @inlineOnce 
def TCheckingStatusForDeltaChecking_ACN_Encode(pVal: TCheckingStatusForDeltaChecking, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(3L))
    TCheckingStatusForDeltaChecking_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TCheckingStatusForDeltaChecking.TwithinThresholds => ULong.fromRaw(0L)
        case TCheckingStatusForDeltaChecking.TCheckingStatusForDeltaChecking_unchecked => ULong.fromRaw(1L)
        case TCheckingStatusForDeltaChecking.TCheckingStatusForDeltaChecking_invalid => ULong.fromRaw(2L)
        case TCheckingStatusForDeltaChecking.TbelowLowTreshold => ULong.fromRaw(3L)
        case TCheckingStatusForDeltaChecking.TaboveHighTreshold => ULong.fromRaw(4L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(4))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 3)
            bitCountLemma(intVal_pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(intVal_pVal, 3)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 3L
    }
}

@opaque @inlineOnce 
def TCheckingStatusForDeltaChecking_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TCheckingStatusForDeltaChecking] =
{
    require(codec.base.bitStream.validate_offset_bits(3L))

    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = codec.dec_Int_PositiveInteger_ConstSize(3)

    val pVal = intVal_pVal.toRaw match
        case 0 => TCheckingStatusForDeltaChecking.TwithinThresholds
        case 1 => TCheckingStatusForDeltaChecking.TCheckingStatusForDeltaChecking_unchecked
        case 2 => TCheckingStatusForDeltaChecking.TCheckingStatusForDeltaChecking_invalid
        case 3 => TCheckingStatusForDeltaChecking.TbelowLowTreshold
        case 4 => TCheckingStatusForDeltaChecking.TaboveHighTreshold
        case _ => return LeftMut(ERR_ACN_DECODE_CHECKINGSTATUSFORDELTACHECKING)

    TCheckingStatusForDeltaChecking_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TCheckingStatusForDeltaChecking](l)
        case Right(_) => RightMut[ErrorCode, TCheckingStatusForDeltaChecking](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TCheckingStatusForDeltaChecking]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 3L && TCheckingStatusForDeltaChecking_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TCheckingStatusForDeltaChecking_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TCheckingStatusForDeltaChecking]) =
{
    require(codec.base.bitStream.validate_offset_bits(3L))
    val cpy = snapshot(codec)
    val res = TCheckingStatusForDeltaChecking_ACN_Decode(cpy)
    (cpy, res)
}

def TPMON_CheckingStatus_IsConstraintValid(pVal: TPMON_CheckingStatus): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TPMON_CheckingStatus.PMON_CheckingStatus_expectedValueChecking_PRESENT(expectedValueChecking) =>
            ret = TCheckingStatusForExpectedValueChecking_IsConstraintValid(expectedValueChecking)
        case TPMON_CheckingStatus.PMON_CheckingStatus_limitChecking_PRESENT(limitChecking) =>
            ret = TCheckingStatusForLimitChecking_IsConstraintValid(limitChecking)
        case TPMON_CheckingStatus.PMON_CheckingStatus_deltaChecking_PRESENT(deltaChecking) =>
            ret = TCheckingStatusForDeltaChecking_IsConstraintValid(deltaChecking)
    ret
}

def TPMON_CheckingStatus_Initialize(): TPMON_CheckingStatus = TPMON_CheckingStatus.PMON_CheckingStatus_expectedValueChecking_PRESENT(TCheckingStatusForExpectedValueChecking.TexpectedValue)

def TPMON_Status_IsConstraintValid(pVal: TPMON_Status): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (((pVal == TPMON_Status.TPMON_Status_disabled)) || ((pVal == TPMON_Status.TPMON_Status_enabled))) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPMON_Status_Initialize(): TPMON_Status = TPMON_Status.TPMON_Status_disabled

@opaque @inlineOnce 
def TPMON_Status_ACN_Encode(pVal: TPMON_Status, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    TPMON_Status_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TPMON_Status.TPMON_Status_disabled => ULong.fromRaw(0L)
        case TPMON_Status.TPMON_Status_enabled => ULong.fromRaw(1L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(1))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 1)
            bitCountLemma(intVal_pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(intVal_pVal, 1)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 1L
    }
}

@opaque @inlineOnce 
def TPMON_Status_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPMON_Status] =
{
    require(codec.base.bitStream.validate_offset_bits(1L))

    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = codec.dec_Int_PositiveInteger_ConstSize(1)

    val pVal = intVal_pVal.toRaw match
        case 0 => TPMON_Status.TPMON_Status_disabled
        case 1 => TPMON_Status.TPMON_Status_enabled
        case _ => return LeftMut(ERR_ACN_DECODE_PMON_STATUS)

    TPMON_Status_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPMON_Status](l)
        case Right(_) => RightMut[ErrorCode, TPMON_Status](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPMON_Status]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 1L && TPMON_Status_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPMON_Status_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPMON_Status]) =
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = TPMON_Status_ACN_Decode(cpy)
    (cpy, res)
}