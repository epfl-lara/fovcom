/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang.{ghost => ghostExpr, _}
import stainless.annotation._
import stainless.collection._
import stainless.proof._
import StaticChecks._


def TPUSC_BOOL1_IsConstraintValid(@annotation.unused pVal: TPUSC_BOOL1): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TPUSC_BOOL1_Initialize(): TPUSC_BOOL1 = false

@opaque @inlineOnce 
def TPUSC_BOOL1_ACN_Encode(pVal: TPUSC_BOOL1, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    TPUSC_BOOL1_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        val true_data: Array[UByte] = Array(0xFF.toUnsignedByte)
        val false_data: Array[UByte] = Array(0x00.toUnsignedByte)
        codec.base.bitStream.appendBitsMSBFirst(if pVal then true_data else false_data, 1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 1L
    }
}

@opaque @inlineOnce 
def TPUSC_BOOL1_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_BOOL1] =
{
    require(codec.base.bitStream.validate_offset_bits(1L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = {
        val tmp: Array[UByte] = Array(0x00.toUnsignedByte)
        val x = codec.BitStream_ReadBitPattern(tmp, 1)
        !x
    }

    TPUSC_BOOL1_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_BOOL1](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_BOOL1](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_BOOL1]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 1L && TPUSC_BOOL1_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_BOOL1_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_BOOL1]) =
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = TPUSC_BOOL1_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_BOOL8_IsConstraintValid(@annotation.unused pVal: TPUSC_BOOL8): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TPUSC_BOOL8_Initialize(): TPUSC_BOOL8 = false

@opaque @inlineOnce 
def TPUSC_BOOL8_ACN_Encode(pVal: TPUSC_BOOL8, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(8L))
    TPUSC_BOOL8_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        val true_data: Array[UByte] = Array(0xFF.toUnsignedByte)
        val false_data: Array[UByte] = Array(0x00.toUnsignedByte)
        codec.base.bitStream.appendBitsMSBFirst(if pVal then true_data else false_data, 8)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 8L
    }
}

@opaque @inlineOnce 
def TPUSC_BOOL8_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_BOOL8] =
{
    require(codec.base.bitStream.validate_offset_bits(8L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = {
        val tmp: Array[UByte] = Array(0x00.toUnsignedByte)
        val x = codec.BitStream_ReadBitPattern(tmp, 8)
        !x
    }

    TPUSC_BOOL8_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_BOOL8](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_BOOL8](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_BOOL8]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 8L && TPUSC_BOOL8_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_BOOL8_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_BOOL8]) =
{
    require(codec.base.bitStream.validate_offset_bits(8L))
    val cpy = snapshot(codec)
    val res = TPUSC_BOOL8_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_BOOL16_IsConstraintValid(@annotation.unused pVal: TPUSC_BOOL16): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TPUSC_BOOL16_Initialize(): TPUSC_BOOL16 = false

@opaque @inlineOnce 
def TPUSC_BOOL16_ACN_Encode(pVal: TPUSC_BOOL16, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(16L))
    TPUSC_BOOL16_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        val true_data: Array[UByte] = Array(0xFF.toUnsignedByte, 0xFF.toUnsignedByte)
        val false_data: Array[UByte] = Array(0x00.toUnsignedByte, 0x00.toUnsignedByte)
        codec.base.bitStream.appendBitsMSBFirst(if pVal then true_data else false_data, 16)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 16L
    }
}

@opaque @inlineOnce 
def TPUSC_BOOL16_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_BOOL16] =
{
    require(codec.base.bitStream.validate_offset_bits(16L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = {
        val tmp: Array[UByte] = Array(0x00.toUnsignedByte, 0x00.toUnsignedByte)
        val x = codec.BitStream_ReadBitPattern(tmp, 16)
        !x
    }

    TPUSC_BOOL16_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_BOOL16](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_BOOL16](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_BOOL16]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 16L && TPUSC_BOOL16_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_BOOL16_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_BOOL16]) =
{
    require(codec.base.bitStream.validate_offset_bits(16L))
    val cpy = snapshot(codec)
    val res = TPUSC_BOOL16_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_BOOL32_IsConstraintValid(@annotation.unused pVal: TPUSC_BOOL32): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TPUSC_BOOL32_Initialize(): TPUSC_BOOL32 = false

@opaque @inlineOnce 
def TPUSC_BOOL32_ACN_Encode(pVal: TPUSC_BOOL32, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    TPUSC_BOOL32_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        val true_data: Array[UByte] = Array(0xFF.toUnsignedByte, 0xFF.toUnsignedByte, 0xFF.toUnsignedByte, 0xFF.toUnsignedByte)
        val false_data: Array[UByte] = Array(0x00.toUnsignedByte, 0x00.toUnsignedByte, 0x00.toUnsignedByte, 0x00.toUnsignedByte)
        codec.base.bitStream.appendBitsMSBFirst(if pVal then true_data else false_data, 32)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L
    }
}

@opaque @inlineOnce 
def TPUSC_BOOL32_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_BOOL32] =
{
    require(codec.base.bitStream.validate_offset_bits(32L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = {
        val tmp: Array[UByte] = Array(0x00.toUnsignedByte, 0x00.toUnsignedByte, 0x00.toUnsignedByte, 0x00.toUnsignedByte)
        val x = codec.BitStream_ReadBitPattern(tmp, 32)
        !x
    }

    TPUSC_BOOL32_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_BOOL32](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_BOOL32](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_BOOL32]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L && TPUSC_BOOL32_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_BOOL32_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_BOOL32]) =
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    val cpy = snapshot(codec)
    val res = TPUSC_BOOL32_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT4_IsConstraintValid(pVal: TPUSC_UINT4): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(15L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT4_Initialize(): TPUSC_UINT4 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT4_ACN_Encode(pVal: TPUSC_UINT4, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(4L))
    TPUSC_UINT4_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(15))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 4)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 4)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 4L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT4_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT4] =
{
    require(codec.base.bitStream.validate_offset_bits(4L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(4)


    TPUSC_UINT4_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT4](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT4](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT4]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 4L && TPUSC_UINT4_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT4_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT4]) =
{
    require(codec.base.bitStream.validate_offset_bits(4L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT4_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT5_IsConstraintValid(pVal: TPUSC_UINT5): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(31L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT5_Initialize(): TPUSC_UINT5 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT5_ACN_Encode(pVal: TPUSC_UINT5, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(5L))
    TPUSC_UINT5_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(31))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 5)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 5)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 5L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT5_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT5] =
{
    require(codec.base.bitStream.validate_offset_bits(5L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(5)


    TPUSC_UINT5_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT5](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT5](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT5]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 5L && TPUSC_UINT5_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT5_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT5]) =
{
    require(codec.base.bitStream.validate_offset_bits(5L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT5_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT6_IsConstraintValid(pVal: TPUSC_UINT6): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(63L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT6_Initialize(): TPUSC_UINT6 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT6_ACN_Encode(pVal: TPUSC_UINT6, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(6L))
    TPUSC_UINT6_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(63))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 6)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 6)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 6L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT6_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT6] =
{
    require(codec.base.bitStream.validate_offset_bits(6L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(6)


    TPUSC_UINT6_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT6](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT6](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT6]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 6L && TPUSC_UINT6_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT6_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT6]) =
{
    require(codec.base.bitStream.validate_offset_bits(6L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT6_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT7_IsConstraintValid(pVal: TPUSC_UINT7): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(127L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT7_Initialize(): TPUSC_UINT7 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT7_ACN_Encode(pVal: TPUSC_UINT7, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(7L))
    TPUSC_UINT7_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(127))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 7)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 7)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 7L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT7_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT7] =
{
    require(codec.base.bitStream.validate_offset_bits(7L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(7)


    TPUSC_UINT7_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT7](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT7](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT7]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 7L && TPUSC_UINT7_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT7_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT7]) =
{
    require(codec.base.bitStream.validate_offset_bits(7L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT7_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT8_IsConstraintValid(pVal: TPUSC_UINT8): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(255L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT8_Initialize(): TPUSC_UINT8 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT8_ACN_Encode(pVal: TPUSC_UINT8, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(8L))
    TPUSC_UINT8_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_PositiveInteger_ConstSize_8(pVal)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 8L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT8_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT8] =
{
    require(codec.base.bitStream.validate_offset_bits(8L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize_8()


    TPUSC_UINT8_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT8](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT8](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT8]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 8L && TPUSC_UINT8_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT8_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT8]) =
{
    require(codec.base.bitStream.validate_offset_bits(8L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT8_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT9_IsConstraintValid(pVal: TPUSC_UINT9): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(511L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT9_Initialize(): TPUSC_UINT9 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT9_ACN_Encode(pVal: TPUSC_UINT9, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(9L))
    TPUSC_UINT9_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(511))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 9)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 9)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 9L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT9_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT9] =
{
    require(codec.base.bitStream.validate_offset_bits(9L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(9)


    TPUSC_UINT9_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT9](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT9](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT9]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 9L && TPUSC_UINT9_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT9_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT9]) =
{
    require(codec.base.bitStream.validate_offset_bits(9L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT9_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT10_IsConstraintValid(pVal: TPUSC_UINT10): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(1023L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT10_Initialize(): TPUSC_UINT10 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT10_ACN_Encode(pVal: TPUSC_UINT10, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(10L))
    TPUSC_UINT10_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(1023))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 10)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 10)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 10L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT10_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT10] =
{
    require(codec.base.bitStream.validate_offset_bits(10L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(10)


    TPUSC_UINT10_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT10](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT10](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT10]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 10L && TPUSC_UINT10_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT10_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT10]) =
{
    require(codec.base.bitStream.validate_offset_bits(10L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT10_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT11_IsConstraintValid(pVal: TPUSC_UINT11): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(2047L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT11_Initialize(): TPUSC_UINT11 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT11_ACN_Encode(pVal: TPUSC_UINT11, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(11L))
    TPUSC_UINT11_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(2047))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 11)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 11)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 11L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT11_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT11] =
{
    require(codec.base.bitStream.validate_offset_bits(11L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(11)


    TPUSC_UINT11_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT11](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT11](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT11]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 11L && TPUSC_UINT11_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT11_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT11]) =
{
    require(codec.base.bitStream.validate_offset_bits(11L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT11_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT12_IsConstraintValid(pVal: TPUSC_UINT12): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(4095L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT12_Initialize(): TPUSC_UINT12 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT12_ACN_Encode(pVal: TPUSC_UINT12, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(12L))
    TPUSC_UINT12_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(4095))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 12)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 12)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 12L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT12_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT12] =
{
    require(codec.base.bitStream.validate_offset_bits(12L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(12)


    TPUSC_UINT12_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT12](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT12](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT12]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 12L && TPUSC_UINT12_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT12_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT12]) =
{
    require(codec.base.bitStream.validate_offset_bits(12L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT12_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT13_IsConstraintValid(pVal: TPUSC_UINT13): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(8191L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT13_Initialize(): TPUSC_UINT13 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT13_ACN_Encode(pVal: TPUSC_UINT13, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(13L))
    TPUSC_UINT13_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(8191))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 13)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 13)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 13L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT13_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT13] =
{
    require(codec.base.bitStream.validate_offset_bits(13L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(13)


    TPUSC_UINT13_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT13](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT13](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT13]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 13L && TPUSC_UINT13_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT13_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT13]) =
{
    require(codec.base.bitStream.validate_offset_bits(13L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT13_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT14_IsConstraintValid(pVal: TPUSC_UINT14): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(16383L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT14_Initialize(): TPUSC_UINT14 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT14_ACN_Encode(pVal: TPUSC_UINT14, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(14L))
    TPUSC_UINT14_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(16383))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 14)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 14)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 14L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT14_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT14] =
{
    require(codec.base.bitStream.validate_offset_bits(14L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(14)


    TPUSC_UINT14_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT14](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT14](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT14]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 14L && TPUSC_UINT14_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT14_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT14]) =
{
    require(codec.base.bitStream.validate_offset_bits(14L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT14_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT15_IsConstraintValid(pVal: TPUSC_UINT15): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(32767L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT15_Initialize(): TPUSC_UINT15 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT15_ACN_Encode(pVal: TPUSC_UINT15, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(15L))
    TPUSC_UINT15_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(32767))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 15)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 15)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 15L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT15_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT15] =
{
    require(codec.base.bitStream.validate_offset_bits(15L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(15)


    TPUSC_UINT15_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT15](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT15](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT15]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 15L && TPUSC_UINT15_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT15_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT15]) =
{
    require(codec.base.bitStream.validate_offset_bits(15L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT15_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT16_IsConstraintValid(pVal: TPUSC_UINT16): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(65535L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT16_Initialize(): TPUSC_UINT16 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT16_ACN_Encode(pVal: TPUSC_UINT16, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(16L))
    TPUSC_UINT16_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_16(pVal)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 16L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT16_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT16] =
{
    require(codec.base.bitStream.validate_offset_bits(16L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize_big_endian_16()


    TPUSC_UINT16_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT16](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT16](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT16]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 16L && TPUSC_UINT16_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT16_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT16]) =
{
    require(codec.base.bitStream.validate_offset_bits(16L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT16_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT24_IsConstraintValid(pVal: TPUSC_UINT24): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(16777215L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT24_Initialize(): TPUSC_UINT24 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT24_ACN_Encode(pVal: TPUSC_UINT24, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(24L))
    TPUSC_UINT24_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(16777215))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 24)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 24)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 24L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT24_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT24] =
{
    require(codec.base.bitStream.validate_offset_bits(24L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(24)


    TPUSC_UINT24_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT24](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT24](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT24]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 24L && TPUSC_UINT24_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT24_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT24]) =
{
    require(codec.base.bitStream.validate_offset_bits(24L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT24_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT32_IsConstraintValid(pVal: TPUSC_UINT32): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(4294967295L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT32_Initialize(): TPUSC_UINT32 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT32_ACN_Encode(pVal: TPUSC_UINT32, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    TPUSC_UINT32_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(4294967295L))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 4294967295L)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_32(pVal)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT32_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT32] =
{
    require(codec.base.bitStream.validate_offset_bits(32L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize_big_endian_32()


    TPUSC_UINT32_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT32](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT32](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT32]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L && TPUSC_UINT32_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT32_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT32]) =
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT32_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT48_IsConstraintValid(pVal: TPUSC_UINT48): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(281474976710655L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT48_Initialize(): TPUSC_UINT48 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT48_ACN_Encode(pVal: TPUSC_UINT48, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(48L))
    TPUSC_UINT48_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(281474976710655L))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 48)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 48)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 48L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT48_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT48] =
{
    require(codec.base.bitStream.validate_offset_bits(48L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(48)


    TPUSC_UINT48_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT48](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT48](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT48]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 48L && TPUSC_UINT48_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT48_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT48]) =
{
    require(codec.base.bitStream.validate_offset_bits(48L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT48_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT64_IsConstraintValid(pVal: TPUSC_UINT64): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(9223372036854775807L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT64_Initialize(): TPUSC_UINT64 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT64_ACN_Encode(pVal: TPUSC_UINT64, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    TPUSC_UINT64_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_64(pVal)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 64L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT64_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT64] =
{
    require(codec.base.bitStream.validate_offset_bits(64L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize_big_endian_64()


    TPUSC_UINT64_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT64](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT64](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT64]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 64L && TPUSC_UINT64_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT64_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT64]) =
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT64_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT1_IsConstraintValid(pVal: TPUSC_UINT1): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(1L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT1_Initialize(): TPUSC_UINT1 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT1_ACN_Encode(pVal: TPUSC_UINT1, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    TPUSC_UINT1_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(1))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 1)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 1)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 1L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT1_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT1] =
{
    require(codec.base.bitStream.validate_offset_bits(1L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(1)


    TPUSC_UINT1_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT1](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT1](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT1]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 1L && TPUSC_UINT1_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT1_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT1]) =
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT1_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT2_IsConstraintValid(pVal: TPUSC_UINT2): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(3L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT2_Initialize(): TPUSC_UINT2 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT2_ACN_Encode(pVal: TPUSC_UINT2, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    TPUSC_UINT2_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(3))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 2)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 2)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT2_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT2] =
{
    require(codec.base.bitStream.validate_offset_bits(2L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(2)


    TPUSC_UINT2_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT2](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT2](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT2]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L && TPUSC_UINT2_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT2_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT2]) =
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT2_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_UINT3_IsConstraintValid(pVal: TPUSC_UINT3): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(7L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_UINT3_Initialize(): TPUSC_UINT3 = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TPUSC_UINT3_ACN_Encode(pVal: TPUSC_UINT3, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(3L))
    TPUSC_UINT3_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(7))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 3)
            bitCountLemma(pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(pVal, 3)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 3L
    }
}

@opaque @inlineOnce 
def TPUSC_UINT3_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_UINT3] =
{
    require(codec.base.bitStream.validate_offset_bits(3L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_PositiveInteger_ConstSize(3)


    TPUSC_UINT3_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_UINT3](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_UINT3](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_UINT3]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 3L && TPUSC_UINT3_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_UINT3_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_UINT3]) =
{
    require(codec.base.bitStream.validate_offset_bits(3L))
    val cpy = snapshot(codec)
    val res = TPUSC_UINT3_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT4_IsConstraintValid(pVal: TPUSC_INT4): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-8 <= pVal) && (pVal <= 7)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT4_Initialize(): TPUSC_INT4 = 0

@opaque @inlineOnce 
def TPUSC_INT4_ACN_Encode(pVal: TPUSC_INT4, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(4L))
    TPUSC_INT4_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize(pVal, 4)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 4L
    }
}

@opaque @inlineOnce 
def TPUSC_INT4_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT4] =
{
    require(codec.base.bitStream.validate_offset_bits(4L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize(4)


    TPUSC_INT4_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT4](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT4](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT4]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 4L && TPUSC_INT4_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT4_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT4]) =
{
    require(codec.base.bitStream.validate_offset_bits(4L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT4_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT5_IsConstraintValid(pVal: TPUSC_INT5): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-16 <= pVal) && (pVal <= 15)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT5_Initialize(): TPUSC_INT5 = 0

@opaque @inlineOnce 
def TPUSC_INT5_ACN_Encode(pVal: TPUSC_INT5, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(5L))
    TPUSC_INT5_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize(pVal, 5)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 5L
    }
}

@opaque @inlineOnce 
def TPUSC_INT5_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT5] =
{
    require(codec.base.bitStream.validate_offset_bits(5L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize(5)


    TPUSC_INT5_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT5](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT5](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT5]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 5L && TPUSC_INT5_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT5_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT5]) =
{
    require(codec.base.bitStream.validate_offset_bits(5L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT5_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT6_IsConstraintValid(pVal: TPUSC_INT6): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-32 <= pVal) && (pVal <= 31)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT6_Initialize(): TPUSC_INT6 = 0

@opaque @inlineOnce 
def TPUSC_INT6_ACN_Encode(pVal: TPUSC_INT6, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(6L))
    TPUSC_INT6_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize(pVal, 6)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 6L
    }
}

@opaque @inlineOnce 
def TPUSC_INT6_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT6] =
{
    require(codec.base.bitStream.validate_offset_bits(6L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize(6)


    TPUSC_INT6_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT6](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT6](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT6]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 6L && TPUSC_INT6_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT6_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT6]) =
{
    require(codec.base.bitStream.validate_offset_bits(6L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT6_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT7_IsConstraintValid(pVal: TPUSC_INT7): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-64 <= pVal) && (pVal <= 63)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT7_Initialize(): TPUSC_INT7 = 0

@opaque @inlineOnce 
def TPUSC_INT7_ACN_Encode(pVal: TPUSC_INT7, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(7L))
    TPUSC_INT7_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize(pVal, 7)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 7L
    }
}

@opaque @inlineOnce 
def TPUSC_INT7_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT7] =
{
    require(codec.base.bitStream.validate_offset_bits(7L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize(7)


    TPUSC_INT7_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT7](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT7](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT7]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 7L && TPUSC_INT7_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT7_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT7]) =
{
    require(codec.base.bitStream.validate_offset_bits(7L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT7_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT8_IsConstraintValid(pVal: TPUSC_INT8): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-128 <= pVal) && (pVal <= 127)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT8_Initialize(): TPUSC_INT8 = 0

@opaque @inlineOnce 
def TPUSC_INT8_ACN_Encode(pVal: TPUSC_INT8, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(8L))
    TPUSC_INT8_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize_8(pVal)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 8L
    }
}

@opaque @inlineOnce 
def TPUSC_INT8_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT8] =
{
    require(codec.base.bitStream.validate_offset_bits(8L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize_8()


    TPUSC_INT8_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT8](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT8](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT8]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 8L && TPUSC_INT8_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT8_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT8]) =
{
    require(codec.base.bitStream.validate_offset_bits(8L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT8_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT9_IsConstraintValid(pVal: TPUSC_INT9): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-256 <= pVal) && (pVal <= 255)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT9_Initialize(): TPUSC_INT9 = 0

@opaque @inlineOnce 
def TPUSC_INT9_ACN_Encode(pVal: TPUSC_INT9, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(9L))
    TPUSC_INT9_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize(pVal, 9)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 9L
    }
}

@opaque @inlineOnce 
def TPUSC_INT9_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT9] =
{
    require(codec.base.bitStream.validate_offset_bits(9L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize(9)


    TPUSC_INT9_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT9](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT9](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT9]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 9L && TPUSC_INT9_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT9_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT9]) =
{
    require(codec.base.bitStream.validate_offset_bits(9L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT9_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT10_IsConstraintValid(pVal: TPUSC_INT10): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-512 <= pVal) && (pVal <= 511)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT10_Initialize(): TPUSC_INT10 = 0

@opaque @inlineOnce 
def TPUSC_INT10_ACN_Encode(pVal: TPUSC_INT10, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(10L))
    TPUSC_INT10_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize(pVal, 10)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 10L
    }
}

@opaque @inlineOnce 
def TPUSC_INT10_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT10] =
{
    require(codec.base.bitStream.validate_offset_bits(10L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize(10)


    TPUSC_INT10_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT10](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT10](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT10]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 10L && TPUSC_INT10_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT10_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT10]) =
{
    require(codec.base.bitStream.validate_offset_bits(10L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT10_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT11_IsConstraintValid(pVal: TPUSC_INT11): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-1024 <= pVal) && (pVal <= 1023)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT11_Initialize(): TPUSC_INT11 = 0

@opaque @inlineOnce 
def TPUSC_INT11_ACN_Encode(pVal: TPUSC_INT11, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(11L))
    TPUSC_INT11_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize(pVal, 11)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 11L
    }
}

@opaque @inlineOnce 
def TPUSC_INT11_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT11] =
{
    require(codec.base.bitStream.validate_offset_bits(11L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize(11)


    TPUSC_INT11_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT11](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT11](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT11]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 11L && TPUSC_INT11_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT11_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT11]) =
{
    require(codec.base.bitStream.validate_offset_bits(11L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT11_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT12_IsConstraintValid(pVal: TPUSC_INT12): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-2048 <= pVal) && (pVal <= 2047)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT12_Initialize(): TPUSC_INT12 = 0

@opaque @inlineOnce 
def TPUSC_INT12_ACN_Encode(pVal: TPUSC_INT12, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(12L))
    TPUSC_INT12_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize(pVal, 12)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 12L
    }
}

@opaque @inlineOnce 
def TPUSC_INT12_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT12] =
{
    require(codec.base.bitStream.validate_offset_bits(12L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize(12)


    TPUSC_INT12_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT12](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT12](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT12]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 12L && TPUSC_INT12_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT12_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT12]) =
{
    require(codec.base.bitStream.validate_offset_bits(12L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT12_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT13_IsConstraintValid(pVal: TPUSC_INT13): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-4096 <= pVal) && (pVal <= 4095)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT13_Initialize(): TPUSC_INT13 = 0

@opaque @inlineOnce 
def TPUSC_INT13_ACN_Encode(pVal: TPUSC_INT13, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(13L))
    TPUSC_INT13_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize(pVal, 13)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 13L
    }
}

@opaque @inlineOnce 
def TPUSC_INT13_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT13] =
{
    require(codec.base.bitStream.validate_offset_bits(13L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize(13)


    TPUSC_INT13_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT13](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT13](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT13]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 13L && TPUSC_INT13_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT13_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT13]) =
{
    require(codec.base.bitStream.validate_offset_bits(13L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT13_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT14_IsConstraintValid(pVal: TPUSC_INT14): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-8192 <= pVal) && (pVal <= 8191)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT14_Initialize(): TPUSC_INT14 = 0

@opaque @inlineOnce 
def TPUSC_INT14_ACN_Encode(pVal: TPUSC_INT14, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(14L))
    TPUSC_INT14_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize(pVal, 14)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 14L
    }
}

@opaque @inlineOnce 
def TPUSC_INT14_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT14] =
{
    require(codec.base.bitStream.validate_offset_bits(14L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize(14)


    TPUSC_INT14_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT14](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT14](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT14]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 14L && TPUSC_INT14_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT14_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT14]) =
{
    require(codec.base.bitStream.validate_offset_bits(14L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT14_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT15_IsConstraintValid(pVal: TPUSC_INT15): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-16384 <= pVal) && (pVal <= 16383)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT15_Initialize(): TPUSC_INT15 = 0

@opaque @inlineOnce 
def TPUSC_INT15_ACN_Encode(pVal: TPUSC_INT15, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(15L))
    TPUSC_INT15_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize(pVal, 15)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 15L
    }
}

@opaque @inlineOnce 
def TPUSC_INT15_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT15] =
{
    require(codec.base.bitStream.validate_offset_bits(15L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize(15)


    TPUSC_INT15_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT15](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT15](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT15]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 15L && TPUSC_INT15_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT15_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT15]) =
{
    require(codec.base.bitStream.validate_offset_bits(15L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT15_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT16_IsConstraintValid(pVal: TPUSC_INT16): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-32768 <= pVal) && (pVal <= 32767)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT16_Initialize(): TPUSC_INT16 = 0

@opaque @inlineOnce 
def TPUSC_INT16_ACN_Encode(pVal: TPUSC_INT16, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(16L))
    TPUSC_INT16_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize_big_endian_16(pVal)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 16L
    }
}

@opaque @inlineOnce 
def TPUSC_INT16_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT16] =
{
    require(codec.base.bitStream.validate_offset_bits(16L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize_big_endian_16()

    TPUSC_INT16_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT16](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT16](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT16]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 16L && TPUSC_INT16_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT16_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT16]) =
{
    require(codec.base.bitStream.validate_offset_bits(16L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT16_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT24_IsConstraintValid(pVal: TPUSC_INT24): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-8388608 <= pVal) && (pVal <= 8388607)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT24_Initialize(): TPUSC_INT24 = 0

@opaque @inlineOnce 
def TPUSC_INT24_ACN_Encode(pVal: TPUSC_INT24, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(24L))
    TPUSC_INT24_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize(pVal, 24)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 24L
    }
}

@opaque @inlineOnce 
def TPUSC_INT24_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT24] =
{
    require(codec.base.bitStream.validate_offset_bits(24L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize(24)


    TPUSC_INT24_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT24](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT24](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT24]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 24L && TPUSC_INT24_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT24_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT24]) =
{
    require(codec.base.bitStream.validate_offset_bits(24L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT24_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT32_IsConstraintValid(pVal: TPUSC_INT32): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-2147483648 <= pVal) && (pVal <= 2147483647)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT32_Initialize(): TPUSC_INT32 = 0

@opaque @inlineOnce 
def TPUSC_INT32_ACN_Encode(pVal: TPUSC_INT32, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    TPUSC_INT32_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize_big_endian_32(pVal)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L
    }
}

@opaque @inlineOnce 
def TPUSC_INT32_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT32] =
{
    require(codec.base.bitStream.validate_offset_bits(32L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize_big_endian_32()


    TPUSC_INT32_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT32](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT32](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT32]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L && TPUSC_INT32_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT32_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT32]) =
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT32_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT48_IsConstraintValid(pVal: TPUSC_INT48): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-140737488355328L <= pVal) && (pVal <= 140737488355327L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT48_Initialize(): TPUSC_INT48 = 0

@opaque @inlineOnce 
def TPUSC_INT48_ACN_Encode(pVal: TPUSC_INT48, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(48L))
    TPUSC_INT48_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize(pVal, 48)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 48L
    }
}

@opaque @inlineOnce 
def TPUSC_INT48_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT48] =
{
    require(codec.base.bitStream.validate_offset_bits(48L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize(48)


    TPUSC_INT48_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT48](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT48](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT48]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 48L && TPUSC_INT48_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT48_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT48]) =
{
    require(codec.base.bitStream.validate_offset_bits(48L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT48_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_INT64_IsConstraintValid(pVal: TPUSC_INT64): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-4611686018427387903L <= pVal) && (pVal <= 4611686018427387903L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_INT64_Initialize(): TPUSC_INT64 = 0

@opaque @inlineOnce 
def TPUSC_INT64_ACN_Encode(pVal: TPUSC_INT64, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    TPUSC_INT64_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Int_TwosComplement_ConstSize_big_endian_64(pVal)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 64L
    }
}

@opaque @inlineOnce 
def TPUSC_INT64_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_INT64] =
{
    require(codec.base.bitStream.validate_offset_bits(64L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Int_TwosComplement_ConstSize_big_endian_64()


    TPUSC_INT64_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_INT64](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_INT64](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_INT64]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 64L && TPUSC_INT64_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_INT64_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_INT64]) =
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    val cpy = snapshot(codec)
    val res = TPUSC_INT64_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_FLOAT32_IsConstraintValid(@annotation.unused pVal: TPUSC_FLOAT32): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

@extern @pure
def TPUSC_FLOAT32_Initialize(): TPUSC_FLOAT32 = 0.0000000000000000000E+000

@opaque @inlineOnce @extern
def TPUSC_FLOAT32_ACN_Encode(pVal: TPUSC_FLOAT32, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    TPUSC_FLOAT32_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Real_IEEE754_32_big_endian(pVal.toFloat)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L
    }
}

@opaque @inlineOnce @extern
def TPUSC_FLOAT32_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_FLOAT32] =
{
    require(codec.base.bitStream.validate_offset_bits(32L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Real_IEEE754_32_big_endian()

    TPUSC_FLOAT32_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_FLOAT32](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_FLOAT32](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_FLOAT32]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L && TPUSC_FLOAT32_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure @extern
def TPUSC_FLOAT32_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_FLOAT32]) =
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    val cpy = snapshot(codec)
    val res = TPUSC_FLOAT32_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_FLOAT64_IsConstraintValid(@annotation.unused pVal: TPUSC_FLOAT64): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

@extern @pure
def TPUSC_FLOAT64_Initialize(): TPUSC_FLOAT64 = 0.0000000000000000000E+000

@opaque @inlineOnce @extern
def TPUSC_FLOAT64_ACN_Encode(pVal: TPUSC_FLOAT64, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    TPUSC_FLOAT64_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    codec.enc_Real_IEEE754_64_big_endian(pVal)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 64L
    }
}

@opaque @inlineOnce @extern
def TPUSC_FLOAT64_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_FLOAT64] =
{
    require(codec.base.bitStream.validate_offset_bits(64L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = codec.dec_Real_IEEE754_64_big_endian()

    TPUSC_FLOAT64_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_FLOAT64](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_FLOAT64](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_FLOAT64]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 64L && TPUSC_FLOAT64_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure @extern
def TPUSC_FLOAT64_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_FLOAT64]) =
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    val cpy = snapshot(codec)
    val res = TPUSC_FLOAT64_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_MIL_FLOAT32_mant_IsConstraintValid(@annotation.unused pVal: TPUSC_MIL_FLOAT32_mant): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TPUSC_MIL_FLOAT32_exp_IsConstraintValid(pVal: TPUSC_MIL_FLOAT32_exp): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-128 <= pVal) && (pVal <= 127)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_MIL_FLOAT32_IsConstraintValid(pVal: TPUSC_MIL_FLOAT32): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TPUSC_MIL_FLOAT32_mant_IsConstraintValid(pVal.mant)
    if ret.isRight then
        ret = TPUSC_MIL_FLOAT32_exp_IsConstraintValid(pVal.exp)
    ret
}

def TPUSC_MIL_FLOAT32_mant_Initialize(): TPUSC_MIL_FLOAT32_mant = TPUSC_MIL_FLOAT32_mant(Vector.fill(3)(0.toRawUByte))
def TPUSC_MIL_FLOAT32_exp_Initialize(): TPUSC_MIL_FLOAT32_exp = 0
def TPUSC_MIL_FLOAT32_Initialize(): TPUSC_MIL_FLOAT32 = TPUSC_MIL_FLOAT32(mant = TPUSC_MIL_FLOAT32_mant(Vector.fill(3)(0.toRawUByte)), exp = 0)

@opaque @inlineOnce 
def TPUSC_MIL_FLOAT32_ACN_Encode(pVal: TPUSC_MIL_FLOAT32, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    TPUSC_MIL_FLOAT32_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode mant */
    assert(24.toInt >= 0) // overflow may happen during cast
    codec.base.bitStream.appendBitsMSBFirstVec(pVal.mant.arr, 24.toInt)

    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 32L, 24L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 24L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 24L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode exp */
    codec.enc_Int_TwosComplement_ConstSize_8(pVal.exp)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 32L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TPUSC_MIL_FLOAT32_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_MIL_FLOAT32] =
{
    require(codec.base.bitStream.validate_offset_bits(32L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode mant */
    val pVal_mant = TPUSC_MIL_FLOAT32_mant(codec.base.bitStream.readBitsVec(24.toInt))
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 32L, 24L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 24L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 24L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode exp */
    val pVal_exp = codec.dec_Int_TwosComplement_ConstSize_8()

    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 32L)
    }
    val pVal = TPUSC_MIL_FLOAT32(pVal_mant, pVal_exp)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TPUSC_MIL_FLOAT32_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_MIL_FLOAT32](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_MIL_FLOAT32](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_MIL_FLOAT32]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TPUSC_MIL_FLOAT32_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_MIL_FLOAT32_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_MIL_FLOAT32]) =
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    val cpy = snapshot(codec)
    val res = TPUSC_MIL_FLOAT32_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_MIL_FLOAT48_mant_MSB_IsConstraintValid(@annotation.unused pVal: TPUSC_MIL_FLOAT48_mant_MSB): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TPUSC_MIL_FLOAT48_exp_IsConstraintValid(pVal: TPUSC_MIL_FLOAT48_exp): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = ((-128 <= pVal) && (pVal <= 127)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_MIL_FLOAT48_mant_LSB_IsConstraintValid(@annotation.unused pVal: TPUSC_MIL_FLOAT48_mant_LSB): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TPUSC_MIL_FLOAT48_IsConstraintValid(pVal: TPUSC_MIL_FLOAT48): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TPUSC_MIL_FLOAT48_mant_MSB_IsConstraintValid(pVal.mant_MSB)
    if ret.isRight then
        ret = TPUSC_MIL_FLOAT48_exp_IsConstraintValid(pVal.exp)
        if ret.isRight then
            ret = TPUSC_MIL_FLOAT48_mant_LSB_IsConstraintValid(pVal.mant_LSB)
    ret
}

def TPUSC_MIL_FLOAT48_mant_MSB_Initialize(): TPUSC_MIL_FLOAT48_mant_MSB = TPUSC_MIL_FLOAT48_mant_MSB(Vector.fill(3)(0.toRawUByte))
def TPUSC_MIL_FLOAT48_exp_Initialize(): TPUSC_MIL_FLOAT48_exp = 0
def TPUSC_MIL_FLOAT48_mant_LSB_Initialize(): TPUSC_MIL_FLOAT48_mant_LSB = TPUSC_MIL_FLOAT48_mant_LSB(Vector.fill(2)(0.toRawUByte))
def TPUSC_MIL_FLOAT48_Initialize(): TPUSC_MIL_FLOAT48 = TPUSC_MIL_FLOAT48(mant_MSB = TPUSC_MIL_FLOAT48_mant_MSB(Vector.fill(3)(0.toRawUByte)), exp = 0, mant_LSB = TPUSC_MIL_FLOAT48_mant_LSB(Vector.fill(2)(0.toRawUByte)))

@opaque @inlineOnce 
def TPUSC_MIL_FLOAT48_ACN_Encode(pVal: TPUSC_MIL_FLOAT48, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(48L))
    TPUSC_MIL_FLOAT48_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode mant_MSB */
    assert(24.toInt >= 0) // overflow may happen during cast
    codec.base.bitStream.appendBitsMSBFirstVec(pVal.mant_MSB.arr, 24.toInt)

    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 48L, 24L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 24L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 24L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode exp */
    codec.enc_Int_TwosComplement_ConstSize_8(pVal.exp)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 24L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Encode mant_LSB */
    assert(16.toInt >= 0) // overflow may happen during cast
    codec.base.bitStream.appendBitsMSBFirstVec(pVal.mant_LSB.arr, 16.toInt)

    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 48L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 48L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TPUSC_MIL_FLOAT48_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TPUSC_MIL_FLOAT48] =
{
    require(codec.base.bitStream.validate_offset_bits(48L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode mant_MSB */
    val pVal_mant_MSB = TPUSC_MIL_FLOAT48_mant_MSB(codec.base.bitStream.readBitsVec(24.toInt))
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 48L, 24L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 24L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 24L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode exp */
    val pVal_exp = codec.dec_Int_TwosComplement_ConstSize_8()

    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 24L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Decode mant_LSB */
    val pVal_mant_LSB = TPUSC_MIL_FLOAT48_mant_LSB(codec.base.bitStream.readBitsVec(16.toInt))
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 48L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 48L)
    }
    val pVal = TPUSC_MIL_FLOAT48(pVal_mant_MSB, pVal_exp, pVal_mant_LSB)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2)
    }

    TPUSC_MIL_FLOAT48_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TPUSC_MIL_FLOAT48](l)
        case Right(_) => RightMut[ErrorCode, TPUSC_MIL_FLOAT48](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TPUSC_MIL_FLOAT48]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TPUSC_MIL_FLOAT48_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TPUSC_MIL_FLOAT48_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TPUSC_MIL_FLOAT48]) =
{
    require(codec.base.bitStream.validate_offset_bits(48L))
    val cpy = snapshot(codec)
    val res = TPUSC_MIL_FLOAT48_ACN_Decode(cpy)
    (cpy, res)
}

def TPUSC_BITSTR_VARIABLE_LEN_IsConstraintValid(pVal: TPUSC_BITSTR_VARIABLE_LEN): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal.nCount <= 4095) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_BITSTR_VARIABLE_LEN_Initialize(): TPUSC_BITSTR_VARIABLE_LEN = TPUSC_BITSTR_VARIABLE_LEN(0, Vector.fill(512)(0.toRawUByte))

def TPUSC_OCTSTR_VARIABLE_LEN_IsConstraintValid(pVal: TPUSC_OCTSTR_VARIABLE_LEN): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal.nCount <= 4095) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_OCTSTR_VARIABLE_LEN_Initialize(): TPUSC_OCTSTR_VARIABLE_LEN = TPUSC_OCTSTR_VARIABLE_LEN(0, Vector.fill(4095)(0.toRawUByte))

def TPUSC_CHARSTR_VARIABLE_LEN_IsConstraintValid(pVal: TPUSC_CHARSTR_VARIABLE_LEN): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal.indexOf(0.toRawUByte) <= 4095) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TPUSC_CHARSTR_VARIABLE_LEN_Initialize(): TPUSC_CHARSTR_VARIABLE_LEN = Vector.fill[UByte](4095.toInt+1)(0x0.toRawUByte)

def TCDS_AbsoluteTime_PFC_1_day_IsConstraintValid(pVal: TCDS_AbsoluteTime_PFC_1_day): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(65535L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TCDS_AbsoluteTime_PFC_1_msOfDay_IsConstraintValid(pVal: TCDS_AbsoluteTime_PFC_1_msOfDay): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(4294967295L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TCDS_AbsoluteTime_PFC_1_IsConstraintValid(pVal: TCDS_AbsoluteTime_PFC_1): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TCDS_AbsoluteTime_PFC_1_day_IsConstraintValid(pVal.day)
    if ret.isRight then
        ret = TCDS_AbsoluteTime_PFC_1_msOfDay_IsConstraintValid(pVal.msOfDay)
    ret
}

def TCDS_AbsoluteTime_PFC_1_day_Initialize(): TCDS_AbsoluteTime_PFC_1_day = ULong.fromRaw(0L)
def TCDS_AbsoluteTime_PFC_1_msOfDay_Initialize(): TCDS_AbsoluteTime_PFC_1_msOfDay = ULong.fromRaw(0L)
def TCDS_AbsoluteTime_PFC_1_Initialize(): TCDS_AbsoluteTime_PFC_1 = TCDS_AbsoluteTime_PFC_1(day = ULong.fromRaw(0L), msOfDay = ULong.fromRaw(0L))

@opaque @inlineOnce 
def TCDS_AbsoluteTime_PFC_1_ACN_Encode(pVal: TCDS_AbsoluteTime_PFC_1, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(48L))
    TCDS_AbsoluteTime_PFC_1_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode day */
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_16(pVal.day)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 48L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 16L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode msOfDay */
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(4294967295L))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 4294967295L)
            bitCountLemma(pVal.msOfDay)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_32(pVal.msOfDay)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 48L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 48L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TCDS_AbsoluteTime_PFC_1_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TCDS_AbsoluteTime_PFC_1] =
{
    require(codec.base.bitStream.validate_offset_bits(48L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode day */
    val pVal_day = codec.dec_Int_PositiveInteger_ConstSize_big_endian_16()

    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 48L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 16L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode msOfDay */
    val pVal_msOfDay = codec.dec_Int_PositiveInteger_ConstSize_big_endian_32()

    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 48L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 48L)
    }
    val pVal = TCDS_AbsoluteTime_PFC_1(pVal_day, pVal_msOfDay)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TCDS_AbsoluteTime_PFC_1_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TCDS_AbsoluteTime_PFC_1](l)
        case Right(_) => RightMut[ErrorCode, TCDS_AbsoluteTime_PFC_1](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TCDS_AbsoluteTime_PFC_1]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TCDS_AbsoluteTime_PFC_1_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TCDS_AbsoluteTime_PFC_1_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TCDS_AbsoluteTime_PFC_1]) =
{
    require(codec.base.bitStream.validate_offset_bits(48L))
    val cpy = snapshot(codec)
    val res = TCDS_AbsoluteTime_PFC_1_ACN_Decode(cpy)
    (cpy, res)
}

def TCDS_AbsoluteTime_PFC_2_day_IsConstraintValid(pVal: TCDS_AbsoluteTime_PFC_2_day): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(65535L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TCDS_AbsoluteTime_PFC_2_msOfDay_IsConstraintValid(pVal: TCDS_AbsoluteTime_PFC_2_msOfDay): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(4294967295L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TCDS_AbsoluteTime_PFC_2_usOfDay_IsConstraintValid(pVal: TCDS_AbsoluteTime_PFC_2_usOfDay): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(65535L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TCDS_AbsoluteTime_PFC_2_IsConstraintValid(pVal: TCDS_AbsoluteTime_PFC_2): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TCDS_AbsoluteTime_PFC_2_day_IsConstraintValid(pVal.day)
    if ret.isRight then
        ret = TCDS_AbsoluteTime_PFC_2_msOfDay_IsConstraintValid(pVal.msOfDay)
        if ret.isRight then
            ret = TCDS_AbsoluteTime_PFC_2_usOfDay_IsConstraintValid(pVal.usOfDay)
    ret
}

def TCDS_AbsoluteTime_PFC_2_day_Initialize(): TCDS_AbsoluteTime_PFC_2_day = ULong.fromRaw(0L)
def TCDS_AbsoluteTime_PFC_2_msOfDay_Initialize(): TCDS_AbsoluteTime_PFC_2_msOfDay = ULong.fromRaw(0L)
def TCDS_AbsoluteTime_PFC_2_usOfDay_Initialize(): TCDS_AbsoluteTime_PFC_2_usOfDay = ULong.fromRaw(0L)
def TCDS_AbsoluteTime_PFC_2_Initialize(): TCDS_AbsoluteTime_PFC_2 = TCDS_AbsoluteTime_PFC_2(day = ULong.fromRaw(0L), msOfDay = ULong.fromRaw(0L), usOfDay = ULong.fromRaw(0L))

@opaque @inlineOnce 
def TCDS_AbsoluteTime_PFC_2_ACN_Encode(pVal: TCDS_AbsoluteTime_PFC_2, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    TCDS_AbsoluteTime_PFC_2_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode day */
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_16(pVal.day)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 64L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 16L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode msOfDay */
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(4294967295L))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 4294967295L)
            bitCountLemma(pVal.msOfDay)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_32(pVal.msOfDay)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 48L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 48L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Encode usOfDay */
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_16(pVal.usOfDay)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 64L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TCDS_AbsoluteTime_PFC_2_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TCDS_AbsoluteTime_PFC_2] =
{
    require(codec.base.bitStream.validate_offset_bits(64L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode day */
    val pVal_day = codec.dec_Int_PositiveInteger_ConstSize_big_endian_16()

    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 64L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 16L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode msOfDay */
    val pVal_msOfDay = codec.dec_Int_PositiveInteger_ConstSize_big_endian_32()

    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 48L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 48L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Decode usOfDay */
    val pVal_usOfDay = codec.dec_Int_PositiveInteger_ConstSize_big_endian_16()

    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 64L)
    }
    val pVal = TCDS_AbsoluteTime_PFC_2(pVal_day, pVal_msOfDay, pVal_usOfDay)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2)
    }

    TCDS_AbsoluteTime_PFC_2_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TCDS_AbsoluteTime_PFC_2](l)
        case Right(_) => RightMut[ErrorCode, TCDS_AbsoluteTime_PFC_2](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TCDS_AbsoluteTime_PFC_2]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TCDS_AbsoluteTime_PFC_2_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TCDS_AbsoluteTime_PFC_2_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TCDS_AbsoluteTime_PFC_2]) =
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    val cpy = snapshot(codec)
    val res = TCDS_AbsoluteTime_PFC_2_ACN_Decode(cpy)
    (cpy, res)
}

def TAbsoluteTime_IsConstraintValid(pVal: TAbsoluteTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TCDS_AbsoluteTime_PFC_2_IsConstraintValid(pVal)
    ret
}

def TAbsoluteTime_Initialize(): TAbsoluteTime = TCDS_AbsoluteTime_PFC_2_Initialize()

@opaque @inlineOnce 
def TAbsoluteTime_ACN_Encode(pVal: TAbsoluteTime, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    TAbsoluteTime_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    TCDS_AbsoluteTime_PFC_2_ACN_Encode(pVal, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TAbsoluteTime_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TAbsoluteTime] =
{
    require(codec.base.bitStream.validate_offset_bits(64L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = TCDS_AbsoluteTime_PFC_2_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)

    TAbsoluteTime_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TAbsoluteTime](l)
        case Right(_) => RightMut[ErrorCode, TAbsoluteTime](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TAbsoluteTime]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TAbsoluteTime_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TAbsoluteTime_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TAbsoluteTime]) =
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    val cpy = snapshot(codec)
    val res = TAbsoluteTime_ACN_Decode(cpy)
    (cpy, res)
}

def TCUC_AbsoluteTime_PFC_3_coarseTime_IsConstraintValid(@annotation.unused pVal: TCUC_AbsoluteTime_PFC_3_coarseTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TCUC_AbsoluteTime_PFC_3_fineTime_IsConstraintValid(@annotation.unused pVal: TCUC_AbsoluteTime_PFC_3_fineTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TCUC_AbsoluteTime_PFC_3_IsConstraintValid(pVal: TCUC_AbsoluteTime_PFC_3): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TCUC_AbsoluteTime_PFC_3_coarseTime_IsConstraintValid(pVal.coarseTime)
    if ret.isRight then
        ret = TCUC_AbsoluteTime_PFC_3_fineTime_IsConstraintValid(pVal.fineTime)
    ret
}

def TCUC_AbsoluteTime_PFC_3_coarseTime_Initialize(): TCUC_AbsoluteTime_PFC_3_coarseTime = TCUC_AbsoluteTime_PFC_3_coarseTime(Vector.fill(1)(0.toRawUByte))
def TCUC_AbsoluteTime_PFC_3_fineTime_Initialize(): TCUC_AbsoluteTime_PFC_3_fineTime = TCUC_AbsoluteTime_PFC_3_fineTime(Vector.fill(1)(0.toRawUByte))
def TCUC_AbsoluteTime_PFC_3_Initialize(): TCUC_AbsoluteTime_PFC_3 = TCUC_AbsoluteTime_PFC_3(coarseTime = TCUC_AbsoluteTime_PFC_3_coarseTime(Vector.fill(1)(0.toRawUByte)), fineTime = TCUC_AbsoluteTime_PFC_3_fineTime(Vector.fill(1)(0.toRawUByte)))

@opaque @inlineOnce 
def TCUC_AbsoluteTime_PFC_3_ACN_Encode(pVal: TCUC_AbsoluteTime_PFC_3, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(16L))
    TCUC_AbsoluteTime_PFC_3_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode coarseTime */
    codec.base.encodeOctetString_no_length_vec(pVal.coarseTime.arr, 1.toInt)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 16L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 8L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode fineTime */
    codec.base.encodeOctetString_no_length_vec(pVal.fineTime.arr, 1.toInt)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 16L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 16L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TCUC_AbsoluteTime_PFC_3_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TCUC_AbsoluteTime_PFC_3] =
{
    require(codec.base.bitStream.validate_offset_bits(16L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode coarseTime */
    val pVal_coarseTime = TCUC_AbsoluteTime_PFC_3_coarseTime(codec.base.decodeOctetString_no_length_vec(1))
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 16L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 8L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode fineTime */
    val pVal_fineTime = TCUC_AbsoluteTime_PFC_3_fineTime(codec.base.decodeOctetString_no_length_vec(1))
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 16L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 16L)
    }
    val pVal = TCUC_AbsoluteTime_PFC_3(pVal_coarseTime, pVal_fineTime)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TCUC_AbsoluteTime_PFC_3_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TCUC_AbsoluteTime_PFC_3](l)
        case Right(_) => RightMut[ErrorCode, TCUC_AbsoluteTime_PFC_3](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TCUC_AbsoluteTime_PFC_3]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TCUC_AbsoluteTime_PFC_3_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TCUC_AbsoluteTime_PFC_3_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TCUC_AbsoluteTime_PFC_3]) =
{
    require(codec.base.bitStream.validate_offset_bits(16L))
    val cpy = snapshot(codec)
    val res = TCUC_AbsoluteTime_PFC_3_ACN_Decode(cpy)
    (cpy, res)
}

def TCUC_AbsoluteTime_PFC_18_coarseTime_IsConstraintValid(@annotation.unused pVal: TCUC_AbsoluteTime_PFC_18_coarseTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TCUC_AbsoluteTime_PFC_18_fineTime_IsConstraintValid(@annotation.unused pVal: TCUC_AbsoluteTime_PFC_18_fineTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TCUC_AbsoluteTime_PFC_18_IsConstraintValid(pVal: TCUC_AbsoluteTime_PFC_18): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TCUC_AbsoluteTime_PFC_18_coarseTime_IsConstraintValid(pVal.coarseTime)
    if ret.isRight then
        ret = TCUC_AbsoluteTime_PFC_18_fineTime_IsConstraintValid(pVal.fineTime)
    ret
}

def TCUC_AbsoluteTime_PFC_18_coarseTime_Initialize(): TCUC_AbsoluteTime_PFC_18_coarseTime = TCUC_AbsoluteTime_PFC_18_coarseTime(Vector.fill(4)(0.toRawUByte))
def TCUC_AbsoluteTime_PFC_18_fineTime_Initialize(): TCUC_AbsoluteTime_PFC_18_fineTime = TCUC_AbsoluteTime_PFC_18_fineTime(Vector.fill(3)(0.toRawUByte))
def TCUC_AbsoluteTime_PFC_18_Initialize(): TCUC_AbsoluteTime_PFC_18 = TCUC_AbsoluteTime_PFC_18(coarseTime = TCUC_AbsoluteTime_PFC_18_coarseTime(Vector.fill(4)(0.toRawUByte)), fineTime = TCUC_AbsoluteTime_PFC_18_fineTime(Vector.fill(3)(0.toRawUByte)))

@opaque @inlineOnce 
def TCUC_AbsoluteTime_PFC_18_ACN_Encode(pVal: TCUC_AbsoluteTime_PFC_18, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(56L))
    TCUC_AbsoluteTime_PFC_18_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode coarseTime */
    codec.base.encodeOctetString_no_length_vec(pVal.coarseTime.arr, 4.toInt)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 56L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode fineTime */
    codec.base.encodeOctetString_no_length_vec(pVal.fineTime.arr, 3.toInt)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 56L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 24L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 56L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TCUC_AbsoluteTime_PFC_18_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TCUC_AbsoluteTime_PFC_18] =
{
    require(codec.base.bitStream.validate_offset_bits(56L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode coarseTime */
    val pVal_coarseTime = TCUC_AbsoluteTime_PFC_18_coarseTime(codec.base.decodeOctetString_no_length_vec(4))
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 56L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode fineTime */
    val pVal_fineTime = TCUC_AbsoluteTime_PFC_18_fineTime(codec.base.decodeOctetString_no_length_vec(3))
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 56L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 24L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 56L)
    }
    val pVal = TCUC_AbsoluteTime_PFC_18(pVal_coarseTime, pVal_fineTime)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TCUC_AbsoluteTime_PFC_18_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TCUC_AbsoluteTime_PFC_18](l)
        case Right(_) => RightMut[ErrorCode, TCUC_AbsoluteTime_PFC_18](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TCUC_AbsoluteTime_PFC_18]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TCUC_AbsoluteTime_PFC_18_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TCUC_AbsoluteTime_PFC_18_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TCUC_AbsoluteTime_PFC_18]) =
{
    require(codec.base.bitStream.validate_offset_bits(56L))
    val cpy = snapshot(codec)
    val res = TCUC_AbsoluteTime_PFC_18_ACN_Decode(cpy)
    (cpy, res)
}

def TCUC_AbsoluteTime_PFC_19_coarseTime_IsConstraintValid(@annotation.unused pVal: TCUC_AbsoluteTime_PFC_19_coarseTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TCUC_AbsoluteTime_PFC_19_fineTime_IsConstraintValid(@annotation.unused pVal: TCUC_AbsoluteTime_PFC_19_fineTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TCUC_AbsoluteTime_PFC_19_IsConstraintValid(pVal: TCUC_AbsoluteTime_PFC_19): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TCUC_AbsoluteTime_PFC_19_coarseTime_IsConstraintValid(pVal.coarseTime)
    if ret.isRight then
        ret = TCUC_AbsoluteTime_PFC_19_fineTime_IsConstraintValid(pVal.fineTime)
    ret
}

def TCUC_AbsoluteTime_PFC_19_coarseTime_Initialize(): TCUC_AbsoluteTime_PFC_19_coarseTime = TCUC_AbsoluteTime_PFC_19_coarseTime(Vector.fill(1)(0.toRawUByte))
def TCUC_AbsoluteTime_PFC_19_fineTime_Initialize(): TCUC_AbsoluteTime_PFC_19_fineTime = TCUC_AbsoluteTime_PFC_19_fineTime(Vector.fill(4)(0.toRawUByte))
def TCUC_AbsoluteTime_PFC_19_Initialize(): TCUC_AbsoluteTime_PFC_19 = TCUC_AbsoluteTime_PFC_19(coarseTime = TCUC_AbsoluteTime_PFC_19_coarseTime(Vector.fill(1)(0.toRawUByte)), fineTime = TCUC_AbsoluteTime_PFC_19_fineTime(Vector.fill(4)(0.toRawUByte)))

@opaque @inlineOnce 
def TCUC_AbsoluteTime_PFC_19_ACN_Encode(pVal: TCUC_AbsoluteTime_PFC_19, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(40L))
    TCUC_AbsoluteTime_PFC_19_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode coarseTime */
    codec.base.encodeOctetString_no_length_vec(pVal.coarseTime.arr, 1.toInt)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 40L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 8L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode fineTime */
    codec.base.encodeOctetString_no_length_vec(pVal.fineTime.arr, 4.toInt)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 40L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 40L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TCUC_AbsoluteTime_PFC_19_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TCUC_AbsoluteTime_PFC_19] =
{
    require(codec.base.bitStream.validate_offset_bits(40L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode coarseTime */
    val pVal_coarseTime = TCUC_AbsoluteTime_PFC_19_coarseTime(codec.base.decodeOctetString_no_length_vec(1))
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 40L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 8L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode fineTime */
    val pVal_fineTime = TCUC_AbsoluteTime_PFC_19_fineTime(codec.base.decodeOctetString_no_length_vec(4))
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 40L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 40L)
    }
    val pVal = TCUC_AbsoluteTime_PFC_19(pVal_coarseTime, pVal_fineTime)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TCUC_AbsoluteTime_PFC_19_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TCUC_AbsoluteTime_PFC_19](l)
        case Right(_) => RightMut[ErrorCode, TCUC_AbsoluteTime_PFC_19](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TCUC_AbsoluteTime_PFC_19]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TCUC_AbsoluteTime_PFC_19_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TCUC_AbsoluteTime_PFC_19_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TCUC_AbsoluteTime_PFC_19]) =
{
    require(codec.base.bitStream.validate_offset_bits(40L))
    val cpy = snapshot(codec)
    val res = TCUC_AbsoluteTime_PFC_19_ACN_Decode(cpy)
    (cpy, res)
}

def TCUC_AbsoluteTime_PFC_46_coarseTime_IsConstraintValid(@annotation.unused pVal: TCUC_AbsoluteTime_PFC_46_coarseTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TCUC_AbsoluteTime_PFC_46_fineTime_IsConstraintValid(@annotation.unused pVal: TCUC_AbsoluteTime_PFC_46_fineTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TCUC_AbsoluteTime_PFC_46_IsConstraintValid(pVal: TCUC_AbsoluteTime_PFC_46): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TCUC_AbsoluteTime_PFC_46_coarseTime_IsConstraintValid(pVal.coarseTime)
    if ret.isRight then
        ret = TCUC_AbsoluteTime_PFC_46_fineTime_IsConstraintValid(pVal.fineTime)
    ret
}

def TCUC_AbsoluteTime_PFC_46_coarseTime_Initialize(): TCUC_AbsoluteTime_PFC_46_coarseTime = TCUC_AbsoluteTime_PFC_46_coarseTime(Vector.fill(4)(0.toRawUByte))
def TCUC_AbsoluteTime_PFC_46_fineTime_Initialize(): TCUC_AbsoluteTime_PFC_46_fineTime = TCUC_AbsoluteTime_PFC_46_fineTime(Vector.fill(10)(0.toRawUByte))
def TCUC_AbsoluteTime_PFC_46_Initialize(): TCUC_AbsoluteTime_PFC_46 = TCUC_AbsoluteTime_PFC_46(coarseTime = TCUC_AbsoluteTime_PFC_46_coarseTime(Vector.fill(4)(0.toRawUByte)), fineTime = TCUC_AbsoluteTime_PFC_46_fineTime(Vector.fill(10)(0.toRawUByte)))

@opaque @inlineOnce 
def TCUC_AbsoluteTime_PFC_46_ACN_Encode(pVal: TCUC_AbsoluteTime_PFC_46, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(112L))
    TCUC_AbsoluteTime_PFC_46_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode coarseTime */
    codec.base.encodeOctetString_no_length_vec(pVal.coarseTime.arr, 4.toInt)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 112L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode fineTime */
    codec.base.encodeOctetString_no_length_vec(pVal.fineTime.arr, 10.toInt)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 112L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 80L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 112L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TCUC_AbsoluteTime_PFC_46_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TCUC_AbsoluteTime_PFC_46] =
{
    require(codec.base.bitStream.validate_offset_bits(112L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode coarseTime */
    val pVal_coarseTime = TCUC_AbsoluteTime_PFC_46_coarseTime(codec.base.decodeOctetString_no_length_vec(4))
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 112L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode fineTime */
    val pVal_fineTime = TCUC_AbsoluteTime_PFC_46_fineTime(codec.base.decodeOctetString_no_length_vec(10))
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 112L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 80L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 112L)
    }
    val pVal = TCUC_AbsoluteTime_PFC_46(pVal_coarseTime, pVal_fineTime)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TCUC_AbsoluteTime_PFC_46_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TCUC_AbsoluteTime_PFC_46](l)
        case Right(_) => RightMut[ErrorCode, TCUC_AbsoluteTime_PFC_46](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TCUC_AbsoluteTime_PFC_46]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TCUC_AbsoluteTime_PFC_46_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TCUC_AbsoluteTime_PFC_46_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TCUC_AbsoluteTime_PFC_46]) =
{
    require(codec.base.bitStream.validate_offset_bits(112L))
    val cpy = snapshot(codec)
    val res = TCUC_AbsoluteTime_PFC_46_ACN_Decode(cpy)
    (cpy, res)
}

def TCDS_RelativeTime_PFC_2_day_IsConstraintValid(pVal: TCDS_RelativeTime_PFC_2_day): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(65535L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TCDS_RelativeTime_PFC_2_msOfDay_IsConstraintValid(pVal: TCDS_RelativeTime_PFC_2_msOfDay): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(4294967295L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TCDS_RelativeTime_PFC_2_usOfMs_IsConstraintValid(pVal: TCDS_RelativeTime_PFC_2_usOfMs): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(65535L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TCDS_RelativeTime_PFC_2_IsConstraintValid(pVal: TCDS_RelativeTime_PFC_2): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TCDS_RelativeTime_PFC_2_day_IsConstraintValid(pVal.day)
    if ret.isRight then
        ret = TCDS_RelativeTime_PFC_2_msOfDay_IsConstraintValid(pVal.msOfDay)
        if ret.isRight then
            ret = TCDS_RelativeTime_PFC_2_usOfMs_IsConstraintValid(pVal.usOfMs)
    ret
}

def TCDS_RelativeTime_PFC_2_day_Initialize(): TCDS_RelativeTime_PFC_2_day = ULong.fromRaw(0L)
def TCDS_RelativeTime_PFC_2_msOfDay_Initialize(): TCDS_RelativeTime_PFC_2_msOfDay = ULong.fromRaw(0L)
def TCDS_RelativeTime_PFC_2_usOfMs_Initialize(): TCDS_RelativeTime_PFC_2_usOfMs = ULong.fromRaw(0L)
def TCDS_RelativeTime_PFC_2_Initialize(): TCDS_RelativeTime_PFC_2 = TCDS_RelativeTime_PFC_2(day = ULong.fromRaw(0L), msOfDay = ULong.fromRaw(0L), usOfMs = ULong.fromRaw(0L))

@opaque @inlineOnce 
def TCDS_RelativeTime_PFC_2_ACN_Encode(pVal: TCDS_RelativeTime_PFC_2, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    TCDS_RelativeTime_PFC_2_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode day */
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_16(pVal.day)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 64L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 16L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode msOfDay */
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(4294967295L))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 4294967295L)
            bitCountLemma(pVal.msOfDay)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_32(pVal.msOfDay)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 48L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 48L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Encode usOfMs */
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_16(pVal.usOfMs)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 64L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TCDS_RelativeTime_PFC_2_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TCDS_RelativeTime_PFC_2] =
{
    require(codec.base.bitStream.validate_offset_bits(64L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode day */
    val pVal_day = codec.dec_Int_PositiveInteger_ConstSize_big_endian_16()

    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 64L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 16L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode msOfDay */
    val pVal_msOfDay = codec.dec_Int_PositiveInteger_ConstSize_big_endian_32()

    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 48L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 48L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Decode usOfMs */
    val pVal_usOfMs = codec.dec_Int_PositiveInteger_ConstSize_big_endian_16()

    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 64L)
    }
    val pVal = TCDS_RelativeTime_PFC_2(pVal_day, pVal_msOfDay, pVal_usOfMs)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2)
    }

    TCDS_RelativeTime_PFC_2_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TCDS_RelativeTime_PFC_2](l)
        case Right(_) => RightMut[ErrorCode, TCDS_RelativeTime_PFC_2](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TCDS_RelativeTime_PFC_2]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TCDS_RelativeTime_PFC_2_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TCDS_RelativeTime_PFC_2_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TCDS_RelativeTime_PFC_2]) =
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    val cpy = snapshot(codec)
    val res = TCDS_RelativeTime_PFC_2_ACN_Decode(cpy)
    (cpy, res)
}

def TRelativeTime_IsConstraintValid(pVal: TRelativeTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TCDS_RelativeTime_PFC_2_IsConstraintValid(pVal)
    ret
}

def TRelativeTime_Initialize(): TRelativeTime = TCDS_RelativeTime_PFC_2_Initialize()

@opaque @inlineOnce 
def TRelativeTime_ACN_Encode(pVal: TRelativeTime, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    TRelativeTime_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    TCDS_RelativeTime_PFC_2_ACN_Encode(pVal, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TRelativeTime_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TRelativeTime] =
{
    require(codec.base.bitStream.validate_offset_bits(64L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = TCDS_RelativeTime_PFC_2_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)

    TRelativeTime_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TRelativeTime](l)
        case Right(_) => RightMut[ErrorCode, TRelativeTime](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TRelativeTime]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TRelativeTime_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TRelativeTime_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TRelativeTime]) =
{
    require(codec.base.bitStream.validate_offset_bits(64L))
    val cpy = snapshot(codec)
    val res = TRelativeTime_ACN_Decode(cpy)
    (cpy, res)
}

def TCUC_RelativeTime_PFC_3_coarseTime_IsConstraintValid(@annotation.unused pVal: TCUC_RelativeTime_PFC_3_coarseTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TCUC_RelativeTime_PFC_3_fineTime_IsConstraintValid(@annotation.unused pVal: TCUC_RelativeTime_PFC_3_fineTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TCUC_RelativeTime_PFC_3_IsConstraintValid(pVal: TCUC_RelativeTime_PFC_3): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TCUC_RelativeTime_PFC_3_coarseTime_IsConstraintValid(pVal.coarseTime)
    if ret.isRight then
        ret = TCUC_RelativeTime_PFC_3_fineTime_IsConstraintValid(pVal.fineTime)
    ret
}

def TCUC_RelativeTime_PFC_3_coarseTime_Initialize(): TCUC_RelativeTime_PFC_3_coarseTime = TCUC_RelativeTime_PFC_3_coarseTime(Vector.fill(1)(0.toRawUByte))
def TCUC_RelativeTime_PFC_3_fineTime_Initialize(): TCUC_RelativeTime_PFC_3_fineTime = TCUC_RelativeTime_PFC_3_fineTime(Vector.fill(1)(0.toRawUByte))
def TCUC_RelativeTime_PFC_3_Initialize(): TCUC_RelativeTime_PFC_3 = TCUC_RelativeTime_PFC_3(coarseTime = TCUC_RelativeTime_PFC_3_coarseTime(Vector.fill(1)(0.toRawUByte)), fineTime = TCUC_RelativeTime_PFC_3_fineTime(Vector.fill(1)(0.toRawUByte)))

@opaque @inlineOnce 
def TCUC_RelativeTime_PFC_3_ACN_Encode(pVal: TCUC_RelativeTime_PFC_3, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(16L))
    TCUC_RelativeTime_PFC_3_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode coarseTime */
    codec.base.encodeOctetString_no_length_vec(pVal.coarseTime.arr, 1.toInt)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 16L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 8L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode fineTime */
    codec.base.encodeOctetString_no_length_vec(pVal.fineTime.arr, 1.toInt)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 16L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 16L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TCUC_RelativeTime_PFC_3_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TCUC_RelativeTime_PFC_3] =
{
    require(codec.base.bitStream.validate_offset_bits(16L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode coarseTime */
    val pVal_coarseTime = TCUC_RelativeTime_PFC_3_coarseTime(codec.base.decodeOctetString_no_length_vec(1))
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 16L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 8L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode fineTime */
    val pVal_fineTime = TCUC_RelativeTime_PFC_3_fineTime(codec.base.decodeOctetString_no_length_vec(1))
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 16L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 16L)
    }
    val pVal = TCUC_RelativeTime_PFC_3(pVal_coarseTime, pVal_fineTime)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TCUC_RelativeTime_PFC_3_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TCUC_RelativeTime_PFC_3](l)
        case Right(_) => RightMut[ErrorCode, TCUC_RelativeTime_PFC_3](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TCUC_RelativeTime_PFC_3]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TCUC_RelativeTime_PFC_3_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TCUC_RelativeTime_PFC_3_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TCUC_RelativeTime_PFC_3]) =
{
    require(codec.base.bitStream.validate_offset_bits(16L))
    val cpy = snapshot(codec)
    val res = TCUC_RelativeTime_PFC_3_ACN_Decode(cpy)
    (cpy, res)
}

def TCUC_RelativeTime_PFC_18_coarseTime_IsConstraintValid(@annotation.unused pVal: TCUC_RelativeTime_PFC_18_coarseTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TCUC_RelativeTime_PFC_18_fineTime_IsConstraintValid(@annotation.unused pVal: TCUC_RelativeTime_PFC_18_fineTime): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = Right(0)
    ret
}

def TCUC_RelativeTime_PFC_18_IsConstraintValid(pVal: TCUC_RelativeTime_PFC_18): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TCUC_RelativeTime_PFC_18_coarseTime_IsConstraintValid(pVal.coarseTime)
    if ret.isRight then
        ret = TCUC_RelativeTime_PFC_18_fineTime_IsConstraintValid(pVal.fineTime)
    ret
}

def TCUC_RelativeTime_PFC_18_coarseTime_Initialize(): TCUC_RelativeTime_PFC_18_coarseTime = TCUC_RelativeTime_PFC_18_coarseTime(Vector.fill(4)(0.toRawUByte))
def TCUC_RelativeTime_PFC_18_fineTime_Initialize(): TCUC_RelativeTime_PFC_18_fineTime = TCUC_RelativeTime_PFC_18_fineTime(Vector.fill(3)(0.toRawUByte))
def TCUC_RelativeTime_PFC_18_Initialize(): TCUC_RelativeTime_PFC_18 = TCUC_RelativeTime_PFC_18(coarseTime = TCUC_RelativeTime_PFC_18_coarseTime(Vector.fill(4)(0.toRawUByte)), fineTime = TCUC_RelativeTime_PFC_18_fineTime(Vector.fill(3)(0.toRawUByte)))

@opaque @inlineOnce 
def TCUC_RelativeTime_PFC_18_ACN_Encode(pVal: TCUC_RelativeTime_PFC_18, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(56L))
    TCUC_RelativeTime_PFC_18_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode coarseTime */
    codec.base.encodeOctetString_no_length_vec(pVal.coarseTime.arr, 4.toInt)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 56L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode fineTime */
    codec.base.encodeOctetString_no_length_vec(pVal.fineTime.arr, 3.toInt)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 56L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 24L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 56L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TCUC_RelativeTime_PFC_18_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TCUC_RelativeTime_PFC_18] =
{
    require(codec.base.bitStream.validate_offset_bits(56L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode coarseTime */
    val pVal_coarseTime = TCUC_RelativeTime_PFC_18_coarseTime(codec.base.decodeOctetString_no_length_vec(4))
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 56L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode fineTime */
    val pVal_fineTime = TCUC_RelativeTime_PFC_18_fineTime(codec.base.decodeOctetString_no_length_vec(3))
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 56L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 24L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 56L)
    }
    val pVal = TCUC_RelativeTime_PFC_18(pVal_coarseTime, pVal_fineTime)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TCUC_RelativeTime_PFC_18_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TCUC_RelativeTime_PFC_18](l)
        case Right(_) => RightMut[ErrorCode, TCUC_RelativeTime_PFC_18](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TCUC_RelativeTime_PFC_18]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TCUC_RelativeTime_PFC_18_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TCUC_RelativeTime_PFC_18_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TCUC_RelativeTime_PFC_18]) =
{
    require(codec.base.bitStream.validate_offset_bits(56L))
    val cpy = snapshot(codec)
    val res = TCUC_RelativeTime_PFC_18_ACN_Decode(cpy)
    (cpy, res)
}