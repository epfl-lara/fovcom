/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang.{ghost => ghostExpr, _}
import stainless.annotation._
import stainless.collection._
import stainless.proof._
import StaticChecks._


def TTransaction_ID_IsConstraintValid(pVal: TTransaction_ID): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TPUSC_UINT32_IsConstraintValid(pVal)
    ret
}

def TTransaction_ID_Initialize(): TTransaction_ID = ULong.fromRaw(0L)

@opaque @inlineOnce 
def TTransaction_ID_ACN_Encode(pVal: TTransaction_ID, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    TTransaction_ID_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    TPUSC_UINT32_ACN_Encode(pVal, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L
    }
}

@opaque @inlineOnce 
def TTransaction_ID_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TTransaction_ID] =
{
    require(codec.base.bitStream.validate_offset_bits(32L))

    @ghost val oldCdc = snapshot(codec)
    val pVal = TPUSC_UINT32_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)

    TTransaction_ID_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TTransaction_ID](l)
        case Right(_) => RightMut[ErrorCode, TTransaction_ID](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TTransaction_ID]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L && TTransaction_ID_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TTransaction_ID_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TTransaction_ID]) =
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    val cpy = snapshot(codec)
    val res = TTransaction_ID_ACN_Decode(cpy)
    (cpy, res)
}

def TDataAcquisitionReturnCode_IsConstraintValid(pVal: TDataAcquisitionReturnCode): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal == TDataAcquisitionReturnCode.Tret1) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TDataAcquisitionReturnCode_Initialize(): TDataAcquisitionReturnCode = TDataAcquisitionReturnCode.Tret1

@opaque @inlineOnce 
def TDataAcquisitionReturnCode_ACN_Encode(pVal: TDataAcquisitionReturnCode, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    TDataAcquisitionReturnCode_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TDataAcquisitionReturnCode.Tret1 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(0))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 4294967295L)
            bitCountLemma(intVal_pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_32(intVal_pVal)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L
    }
}

@opaque @inlineOnce 
def TDataAcquisitionReturnCode_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TDataAcquisitionReturnCode] =
{
    require(codec.base.bitStream.validate_offset_bits(32L))

    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = codec.dec_Int_PositiveInteger_ConstSize_big_endian_32()

    val pVal = intVal_pVal.toRaw match
        case 0 => TDataAcquisitionReturnCode.Tret1
        case _ => return LeftMut(ERR_ACN_DECODE_DATAACQUISITIONRETURNCODE)

    TDataAcquisitionReturnCode_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TDataAcquisitionReturnCode](l)
        case Right(_) => RightMut[ErrorCode, TDataAcquisitionReturnCode](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TDataAcquisitionReturnCode]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 32L && TDataAcquisitionReturnCode_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TDataAcquisitionReturnCode_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TDataAcquisitionReturnCode]) =
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    val cpy = snapshot(codec)
    val res = TDataAcquisitionReturnCode_ACN_Decode(cpy)
    (cpy, res)
}

def TAuxiliaryData_IsConstraintValid(pVal: TAuxiliaryData): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TAuxiliaryData.ret1_PRESENT(ret1) =>
            ret = Right(0)
    ret
}

def TAuxiliaryData_Initialize(): TAuxiliaryData = TAuxiliaryData.ret1_PRESENT(0)

def TTransactionExecutionStatus_IsConstraintValid(pVal: TTransactionExecutionStatus): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TAuxiliaryData_IsConstraintValid(pVal.auxiliaryData)
    ret
}

def TTransactionExecutionStatus_Initialize(): TTransactionExecutionStatus = TTransactionExecutionStatus(auxiliaryData = TAuxiliaryData_Initialize())

@opaque @inlineOnce 
def TTransactionExecutionStatus_ACN_Encode(pVal: TTransactionExecutionStatus, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    TTransactionExecutionStatus_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    val TransactionExecutionStatus_dataAcquisitionReturnCode = pVal.auxiliaryData match
        case TAuxiliaryData.ret1_PRESENT(_) =>TDataAcquisitionReturnCode.Tret1

    /* Encode TransactionExecutionStatus_dataAcquisitionReturnCode */
    val intVal_TransactionExecutionStatus_dataAcquisitionReturnCode = TransactionExecutionStatus_dataAcquisitionReturnCode match
        case TDataAcquisitionReturnCode.Tret1 => ULong.fromRaw(0L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(0))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 4294967295L)
            bitCountLemma(intVal_TransactionExecutionStatus_dataAcquisitionReturnCode)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_32(intVal_TransactionExecutionStatus_dataAcquisitionReturnCode)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 32L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode auxiliaryData */
    TransactionExecutionStatus_auxiliaryData_ACN_Encode(codec, pVal, TransactionExecutionStatus_dataAcquisitionReturnCode, pVal.auxiliaryData) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = pVal.auxiliaryData match {
        case TAuxiliaryData.ret1_PRESENT(ret1) =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 32L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def TransactionExecutionStatus_auxiliaryData_ACN_Encode(codec: ACN, pVal: TTransactionExecutionStatus, TransactionExecutionStatus_dataAcquisitionReturnCode: TDataAcquisitionReturnCode, auxiliaryData: TAuxiliaryData): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(0L))
    @ghost val oldCdc = snapshot(codec)
    TAuxiliaryData_IsConstraintValid(auxiliaryData) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    auxiliaryData match
        case TAuxiliaryData.ret1_PRESENT(ret1) =>
    
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + auxiliaryData.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TTransactionExecutionStatus_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TTransactionExecutionStatus] =
{
    require(codec.base.bitStream.validate_offset_bits(32L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode TransactionExecutionStatus_dataAcquisitionReturnCode */
    val intVal_TransactionExecutionStatus_dataAcquisitionReturnCode = codec.dec_Int_PositiveInteger_ConstSize_big_endian_32()

    val TransactionExecutionStatus_dataAcquisitionReturnCode = intVal_TransactionExecutionStatus_dataAcquisitionReturnCode.toRaw match
        case 0 => TDataAcquisitionReturnCode.Tret1
        case _ => return LeftMut(ERR_ACN_DECODE_TRANSACTIONEXECUTIONSTATUS_DATAACQUISITIONRETURNCODE)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 32L, 32L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 32L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode auxiliaryData */
    val pVal_auxiliaryData = TransactionExecutionStatus_auxiliaryData_ACN_Decode(codec, TransactionExecutionStatus_dataAcquisitionReturnCode) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = pVal_auxiliaryData match {
        case TAuxiliaryData.ret1_PRESENT(ret1) =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 32L)
    }
    val pVal = TTransactionExecutionStatus(pVal_auxiliaryData)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TTransactionExecutionStatus_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TTransactionExecutionStatus](l)
        case Right(_) => RightMut[ErrorCode, TTransactionExecutionStatus](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TTransactionExecutionStatus]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TTransactionExecutionStatus_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TTransactionExecutionStatus_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TTransactionExecutionStatus]) =
{
    require(codec.base.bitStream.validate_offset_bits(32L))
    val cpy = snapshot(codec)
    val res = TTransactionExecutionStatus_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def TransactionExecutionStatus_auxiliaryData_ACN_Decode(codec: ACN, TransactionExecutionStatus_dataAcquisitionReturnCode: TDataAcquisitionReturnCode): EitherMut[Int, TAuxiliaryData] = {
    require(codec.base.bitStream.validate_offset_bits(0L))
    @ghost val oldCdc = snapshot(codec)
    val auxiliaryData = TransactionExecutionStatus_dataAcquisitionReturnCode match
        case TDataAcquisitionReturnCode.Tret1 =>
            val ret1: NullType = 0
            TAuxiliaryData.ret1_PRESENT(ret1)
    TAuxiliaryData_IsConstraintValid(auxiliaryData) match {
        case Left(l) =>
            LeftMut[Int, TAuxiliaryData](l)
        case Right(_) =>
            RightMut[Int, TAuxiliaryData](auxiliaryData)
    }
}.ensuring { (res: EitherMut[Int, TAuxiliaryData]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TAuxiliaryData_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def TransactionExecutionStatus_auxiliaryData_ACN_Decode_pure(codec: ACN, TransactionExecutionStatus_dataAcquisitionReturnCode: TDataAcquisitionReturnCode): (ACN, EitherMut[Int, TAuxiliaryData]) = {
    require(codec.base.bitStream.validate_offset_bits(0L))
    val cpy = snapshot(codec)
    val res = TransactionExecutionStatus_auxiliaryData_ACN_Decode(cpy, TransactionExecutionStatus_dataAcquisitionReturnCode)
    (cpy, res)
}