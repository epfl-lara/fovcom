/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang.{ghost => ghostExpr, _}
import stainless.annotation._
import stainless.collection._
import stainless.proof._
import StaticChecks._


def TTimeWindowType_IsConstraintValid(pVal: TTimeWindowType): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (((((((pVal == TTimeWindowType.TselectAll)) || ((pVal == TTimeWindowType.TfromTimeTagToTimeTag)))) || ((pVal == TTimeWindowType.TfromTimeTag)))) || ((pVal == TTimeWindowType.TtoTimeTag))) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TTimeWindowType_Initialize(): TTimeWindowType = TTimeWindowType.TselectAll

@opaque @inlineOnce 
def TTimeWindowType_ACN_Encode(pVal: TTimeWindowType, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    TTimeWindowType_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TTimeWindowType.TselectAll => ULong.fromRaw(0L)
        case TTimeWindowType.TfromTimeTagToTimeTag => ULong.fromRaw(1L)
        case TTimeWindowType.TfromTimeTag => ULong.fromRaw(2L)
        case TTimeWindowType.TtoTimeTag => ULong.fromRaw(3L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(3))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 2)
            bitCountLemma(intVal_pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(intVal_pVal, 2)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L
    }
}

@opaque @inlineOnce 
def TTimeWindowType_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TTimeWindowType] =
{
    require(codec.base.bitStream.validate_offset_bits(2L))

    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = codec.dec_Int_PositiveInteger_ConstSize(2)

    val pVal = intVal_pVal.toRaw match
        case 0 => TTimeWindowType.TselectAll
        case 1 => TTimeWindowType.TfromTimeTagToTimeTag
        case 2 => TTimeWindowType.TfromTimeTag
        case 3 => TTimeWindowType.TtoTimeTag
        case _ => return LeftMut(ERR_ACN_DECODE_TIMEWINDOWTYPE)

    TTimeWindowType_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TTimeWindowType](l)
        case Right(_) => RightMut[ErrorCode, TTimeWindowType](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TTimeWindowType]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L && TTimeWindowType_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TTimeWindowType_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TTimeWindowType]) =
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    val cpy = snapshot(codec)
    val res = TTimeWindowType_ACN_Decode(cpy)
    (cpy, res)
}

def TTimeTags_fromTimeTagToTimeTag_IsConstraintValid(pVal: TTimeTags_fromTimeTagToTimeTag): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TCDS_AbsoluteTime_PFC_2_IsConstraintValid(pVal.fromTimeTag)
    if ret.isRight then
        ret = TCDS_AbsoluteTime_PFC_2_IsConstraintValid(pVal.toTimeTag)
    ret
}

def TTimeTags_IsConstraintValid(pVal: TTimeTags): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TTimeTags.selectAll_PRESENT(selectAll) =>
            ret = Right(0)
        case TTimeTags.fromTimeTagToTimeTag_PRESENT(fromTimeTagToTimeTag) =>
            ret = TTimeTags_fromTimeTagToTimeTag_IsConstraintValid(fromTimeTagToTimeTag)
        case TTimeTags.fromTimeTag_PRESENT(fromTimeTag) =>
            ret = TCDS_AbsoluteTime_PFC_2_IsConstraintValid(fromTimeTag)
        case TTimeTags.toTimeTag_PRESENT(toTimeTag) =>
            ret = TCDS_AbsoluteTime_PFC_2_IsConstraintValid(toTimeTag)
    ret
}

def TTimeTags_fromTimeTagToTimeTag_Initialize(): TTimeTags_fromTimeTagToTimeTag = TTimeTags_fromTimeTagToTimeTag(fromTimeTag = TCDS_AbsoluteTime_PFC_2_Initialize(), toTimeTag = TCDS_AbsoluteTime_PFC_2_Initialize())
def TTimeTags_Initialize(): TTimeTags = TTimeTags.selectAll_PRESENT(0)

def TTimeWindow_IsConstraintValid(pVal: TTimeWindow): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TTimeTags_IsConstraintValid(pVal.timeTags)
    ret
}

def TTimeWindow_Initialize(): TTimeWindow = TTimeWindow(timeTags = TTimeTags_Initialize())

@opaque @inlineOnce 
def TTimeWindow_ACN_Encode(pVal: TTimeWindow, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(130L))
    TTimeWindow_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    val TimeWindow_type = pVal.timeTags match
        case TTimeTags.selectAll_PRESENT(_) =>TTimeWindowType.TselectAll
        case TTimeTags.fromTimeTagToTimeTag_PRESENT(_) =>TTimeWindowType.TfromTimeTagToTimeTag
        case TTimeTags.fromTimeTag_PRESENT(_) =>TTimeWindowType.TfromTimeTag
        case TTimeTags.toTimeTag_PRESENT(_) =>TTimeWindowType.TtoTimeTag

    /* Encode TimeWindow_type */
    val intVal_TimeWindow_type = TimeWindow_type match
        case TTimeWindowType.TselectAll => ULong.fromRaw(0L)
        case TTimeWindowType.TfromTimeTagToTimeTag => ULong.fromRaw(1L)
        case TTimeWindowType.TfromTimeTag => ULong.fromRaw(2L)
        case TTimeWindowType.TtoTimeTag => ULong.fromRaw(3L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(3))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 2)
            bitCountLemma(intVal_TimeWindow_type)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(intVal_TimeWindow_type, 2)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 130L, 2L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 2L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 2L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode timeTags */
    TimeWindow_timeTags_ACN_Encode(codec, pVal, TimeWindow_type, pVal.timeTags) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 130L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = pVal.timeTags match {
        case TTimeTags.selectAll_PRESENT(selectAll) =>
            0L
        case TTimeTags.fromTimeTagToTimeTag_PRESENT(fromTimeTagToTimeTag) =>
            val size_2_1 = fromTimeTagToTimeTag.fromTimeTag.size(codec_0_2.base.bitStream.bitIndex)
            val size_2_2 = fromTimeTagToTimeTag.toTimeTag.size(codec_0_2.base.bitStream.bitIndex + size_2_1)
            size_2_1 + size_2_2
        case TTimeTags.fromTimeTag_PRESENT(fromTimeTag) =>
            fromTimeTag.size(codec_0_2.base.bitStream.bitIndex)
        case TTimeTags.toTimeTag_PRESENT(toTimeTag) =>
            toTimeTag.size(codec_0_2.base.bitStream.bitIndex)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 130L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def TimeWindow_timeTags_fromTimeTagToTimeTag_ACN_Encode(codec: ACN, pVal: TTimeWindow, fromTimeTagToTimeTag: TTimeTags_fromTimeTagToTimeTag): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(128L))
    @ghost val oldCdc = snapshot(codec)
    TTimeTags_fromTimeTagToTimeTag_IsConstraintValid(fromTimeTagToTimeTag) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode fromTimeTag */
    TCDS_AbsoluteTime_PFC_2_ACN_Encode(fromTimeTagToTimeTag.fromTimeTag, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 128L, 64L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = fromTimeTagToTimeTag.fromTimeTag.size(codec_0_1.base.bitStream.bitIndex)
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode toTimeTag */
    TCDS_AbsoluteTime_PFC_2_ACN_Encode(fromTimeTagToTimeTag.toTimeTag, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 128L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = fromTimeTagToTimeTag.toTimeTag.size(codec_0_2.base.bitStream.bitIndex)
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 128L)
    }
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            val size_1_0 = fromTimeTagToTimeTag.fromTimeTag.size(old(codec).base.bitStream.bitIndex)
            val size_1_1 = fromTimeTagToTimeTag.toTimeTag.size(old(codec).base.bitStream.bitIndex + size_1_0)
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1
    }
}

@opaque @inlineOnce
def TimeWindow_timeTags_ACN_Encode(codec: ACN, pVal: TTimeWindow, TimeWindow_type: TTimeWindowType, timeTags: TTimeTags): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(128L))
    @ghost val oldCdc = snapshot(codec)
    TTimeTags_IsConstraintValid(timeTags) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    timeTags match
        case TTimeTags.selectAll_PRESENT(selectAll) =>
    
        case TTimeTags.fromTimeTagToTimeTag_PRESENT(fromTimeTagToTimeTag) =>
            TimeWindow_timeTags_fromTimeTagToTimeTag_ACN_Encode(codec, pVal, fromTimeTagToTimeTag) match {
                case Left(l) =>
                    return Left(l)
                case Right(_) =>
                    ()
            }
        case TTimeTags.fromTimeTag_PRESENT(fromTimeTag) =>
            TCDS_AbsoluteTime_PFC_2_ACN_Encode(fromTimeTag, codec, false) match // uper:6
                case Right(_) =>
                case Left(err) => return Left(err)
        case TTimeTags.toTimeTag_PRESENT(toTimeTag) =>
            TCDS_AbsoluteTime_PFC_2_ACN_Encode(toTimeTag, codec, false) match // uper:6
                case Right(_) =>
                case Left(err) => return Left(err)
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + timeTags.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TTimeWindow_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TTimeWindow] =
{
    require(codec.base.bitStream.validate_offset_bits(130L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode TimeWindow_type */
    val intVal_TimeWindow_type = codec.dec_Int_PositiveInteger_ConstSize(2)

    val TimeWindow_type = intVal_TimeWindow_type.toRaw match
        case 0 => TTimeWindowType.TselectAll
        case 1 => TTimeWindowType.TfromTimeTagToTimeTag
        case 2 => TTimeWindowType.TfromTimeTag
        case 3 => TTimeWindowType.TtoTimeTag
        case _ => return LeftMut(ERR_ACN_DECODE_TIMEWINDOW_TYPE)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 130L, 2L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 2L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 2L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode timeTags */
    val pVal_timeTags = TimeWindow_timeTags_ACN_Decode(codec, TimeWindow_type) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 130L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = pVal_timeTags match {
        case TTimeTags.selectAll_PRESENT(selectAll) =>
            0L
        case TTimeTags.fromTimeTagToTimeTag_PRESENT(fromTimeTagToTimeTag) =>
            val size_2_1 = fromTimeTagToTimeTag.fromTimeTag.size(codec_0_2.base.bitStream.bitIndex)
            val size_2_2 = fromTimeTagToTimeTag.toTimeTag.size(codec_0_2.base.bitStream.bitIndex + size_2_1)
            size_2_1 + size_2_2
        case TTimeTags.fromTimeTag_PRESENT(fromTimeTag) =>
            fromTimeTag.size(codec_0_2.base.bitStream.bitIndex)
        case TTimeTags.toTimeTag_PRESENT(toTimeTag) =>
            toTimeTag.size(codec_0_2.base.bitStream.bitIndex)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 130L)
    }
    val pVal = TTimeWindow(pVal_timeTags)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TTimeWindow_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TTimeWindow](l)
        case Right(_) => RightMut[ErrorCode, TTimeWindow](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TTimeWindow]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TTimeWindow_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TTimeWindow_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TTimeWindow]) =
{
    require(codec.base.bitStream.validate_offset_bits(130L))
    val cpy = snapshot(codec)
    val res = TTimeWindow_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def TimeWindow_timeTags_fromTimeTagToTimeTag_ACN_Decode(codec: ACN): EitherMut[Int, TTimeTags_fromTimeTagToTimeTag] = {
    require(codec.base.bitStream.validate_offset_bits(128L))
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode fromTimeTag */
    val fromTimeTagToTimeTag_fromTimeTag = TCDS_AbsoluteTime_PFC_2_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 128L, 64L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 64L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = fromTimeTagToTimeTag_fromTimeTag.size(codec_0_1.base.bitStream.bitIndex)
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode toTimeTag */
    val fromTimeTagToTimeTag_toTimeTag = TCDS_AbsoluteTime_PFC_2_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 128L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = fromTimeTagToTimeTag_toTimeTag.size(codec_0_2.base.bitStream.bitIndex)
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 128L)
    }
    val fromTimeTagToTimeTag = TTimeTags_fromTimeTagToTimeTag(fromTimeTagToTimeTag_fromTimeTag, fromTimeTagToTimeTag_toTimeTag)
    TTimeTags_fromTimeTagToTimeTag_IsConstraintValid(fromTimeTagToTimeTag) match {
        case Left(l) =>
            LeftMut[Int, TTimeTags_fromTimeTagToTimeTag](l)
        case Right(_) =>
            RightMut[Int, TTimeTags_fromTimeTagToTimeTag](fromTimeTagToTimeTag)
    }
}.ensuring { (res: EitherMut[Int, TTimeTags_fromTimeTagToTimeTag]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            val size_1_0 = resVal.fromTimeTag.size(old(codec).base.bitStream.bitIndex)
            val size_1_1 = resVal.toTimeTag.size(old(codec).base.bitStream.bitIndex + size_1_0)
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 && TTimeTags_fromTimeTagToTimeTag_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def TimeWindow_timeTags_fromTimeTagToTimeTag_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, TTimeTags_fromTimeTagToTimeTag]) = {
    require(codec.base.bitStream.validate_offset_bits(128L))
    val cpy = snapshot(codec)
    val res = TimeWindow_timeTags_fromTimeTagToTimeTag_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def TimeWindow_timeTags_ACN_Decode(codec: ACN, TimeWindow_type: TTimeWindowType): EitherMut[Int, TTimeTags] = {
    require(codec.base.bitStream.validate_offset_bits(128L))
    @ghost val oldCdc = snapshot(codec)
    val timeTags = TimeWindow_type match
        case TTimeWindowType.TselectAll =>
            val selectAll: NullType = 0
            TTimeTags.selectAll_PRESENT(selectAll)
        case TTimeWindowType.TfromTimeTagToTimeTag =>
            val fromTimeTagToTimeTag = TimeWindow_timeTags_fromTimeTagToTimeTag_ACN_Decode(codec) match {
                case LeftMut(l) =>
                    return LeftMut(l)
                case RightMut(v) =>
                    v
            }
            TTimeTags.fromTimeTagToTimeTag_PRESENT(fromTimeTagToTimeTag)
        case TTimeWindowType.TfromTimeTag =>
            val fromTimeTag = TCDS_AbsoluteTime_PFC_2_ACN_Decode(codec) match // uper:13
                case RightMut(decData) => decData
                case LeftMut(err) => return LeftMut(err)
            TTimeTags.fromTimeTag_PRESENT(fromTimeTag)
        case TTimeWindowType.TtoTimeTag =>
            val toTimeTag = TCDS_AbsoluteTime_PFC_2_ACN_Decode(codec) match // uper:13
                case RightMut(decData) => decData
                case LeftMut(err) => return LeftMut(err)
            TTimeTags.toTimeTag_PRESENT(toTimeTag)
    TTimeTags_IsConstraintValid(timeTags) match {
        case Left(l) =>
            LeftMut[Int, TTimeTags](l)
        case Right(_) =>
            RightMut[Int, TTimeTags](timeTags)
    }
}.ensuring { (res: EitherMut[Int, TTimeTags]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TTimeTags_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def TimeWindow_timeTags_ACN_Decode_pure(codec: ACN, TimeWindow_type: TTimeWindowType): (ACN, EitherMut[Int, TTimeTags]) = {
    require(codec.base.bitStream.validate_offset_bits(128L))
    val cpy = snapshot(codec)
    val res = TimeWindow_timeTags_ACN_Decode(cpy, TimeWindow_type)
    (cpy, res)
}