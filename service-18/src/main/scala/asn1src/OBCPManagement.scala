/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang.{ghost => ghostExpr, _}
import stainless.annotation._
import stainless.collection._
import stainless.proof._
import StaticChecks._


def TOBCPExecutionStatus_IsConstraintValid(pVal: TOBCPExecutionStatus): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (((((pVal == TOBCPExecutionStatus.Tinactive)) || ((pVal == TOBCPExecutionStatus.TactiveAndRunning)))) || ((pVal == TOBCPExecutionStatus.TactiveAndHeld))) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TOBCPExecutionStatus_Initialize(): TOBCPExecutionStatus = TOBCPExecutionStatus.Tinactive

@opaque @inlineOnce 
def TOBCPExecutionStatus_ACN_Encode(pVal: TOBCPExecutionStatus, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    TOBCPExecutionStatus_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TOBCPExecutionStatus.Tinactive => ULong.fromRaw(0L)
        case TOBCPExecutionStatus.TactiveAndRunning => ULong.fromRaw(1L)
        case TOBCPExecutionStatus.TactiveAndHeld => ULong.fromRaw(2L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(2))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 2)
            bitCountLemma(intVal_pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(intVal_pVal, 2)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L
    }
}

@opaque @inlineOnce 
def TOBCPExecutionStatus_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TOBCPExecutionStatus] =
{
    require(codec.base.bitStream.validate_offset_bits(2L))

    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = codec.dec_Int_PositiveInteger_ConstSize(2)

    val pVal = intVal_pVal.toRaw match
        case 0 => TOBCPExecutionStatus.Tinactive
        case 1 => TOBCPExecutionStatus.TactiveAndRunning
        case 2 => TOBCPExecutionStatus.TactiveAndHeld
        case _ => return LeftMut(ERR_ACN_DECODE_OBCPEXECUTIONSTATUS)

    TOBCPExecutionStatus_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TOBCPExecutionStatus](l)
        case Right(_) => RightMut[ErrorCode, TOBCPExecutionStatus](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TOBCPExecutionStatus]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L && TOBCPExecutionStatus_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TOBCPExecutionStatus_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TOBCPExecutionStatus]) =
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    val cpy = snapshot(codec)
    val res = TOBCPExecutionStatus_ACN_Decode(cpy)
    (cpy, res)
}

def TOBCPObservabilityLevel_IsConstraintValid(pVal: TOBCPObservabilityLevel): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (((((((pVal == TOBCPObservabilityLevel.Tno_observability)) || ((pVal == TOBCPObservabilityLevel.Tat_procedure_level)))) || ((pVal == TOBCPObservabilityLevel.Tat_step_level)))) || ((pVal == TOBCPObservabilityLevel.Tat_detailed_level))) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TOBCPObservabilityLevel_Initialize(): TOBCPObservabilityLevel = TOBCPObservabilityLevel.Tno_observability

@opaque @inlineOnce 
def TOBCPObservabilityLevel_ACN_Encode(pVal: TOBCPObservabilityLevel, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    TOBCPObservabilityLevel_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TOBCPObservabilityLevel.Tno_observability => ULong.fromRaw(0L)
        case TOBCPObservabilityLevel.Tat_procedure_level => ULong.fromRaw(1L)
        case TOBCPObservabilityLevel.Tat_step_level => ULong.fromRaw(2L)
        case TOBCPObservabilityLevel.Tat_detailed_level => ULong.fromRaw(3L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(3))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 2)
            bitCountLemma(intVal_pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(intVal_pVal, 2)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L
    }
}

@opaque @inlineOnce 
def TOBCPObservabilityLevel_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TOBCPObservabilityLevel] =
{
    require(codec.base.bitStream.validate_offset_bits(2L))

    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = codec.dec_Int_PositiveInteger_ConstSize(2)

    val pVal = intVal_pVal.toRaw match
        case 0 => TOBCPObservabilityLevel.Tno_observability
        case 1 => TOBCPObservabilityLevel.Tat_procedure_level
        case 2 => TOBCPObservabilityLevel.Tat_step_level
        case 3 => TOBCPObservabilityLevel.Tat_detailed_level
        case _ => return LeftMut(ERR_ACN_DECODE_OBCPOBSERVABILITYLEVEL)

    TOBCPObservabilityLevel_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TOBCPObservabilityLevel](l)
        case Right(_) => RightMut[ErrorCode, TOBCPObservabilityLevel](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TOBCPObservabilityLevel]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L && TOBCPObservabilityLevel_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TOBCPObservabilityLevel_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TOBCPObservabilityLevel]) =
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    val cpy = snapshot(codec)
    val res = TOBCPObservabilityLevel_ACN_Decode(cpy)
    (cpy, res)
}

def TOBCPStep_ID_IsConstraintValid(pVal: TOBCPStep_ID): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (((pVal == TOBCPStep_ID.TstopAtEndOfCurrentStep)) || ((pVal == TOBCPStep_ID.TnextStep))) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TOBCPStep_ID_Initialize(): TOBCPStep_ID = TOBCPStep_ID.TstopAtEndOfCurrentStep

@opaque @inlineOnce 
def TOBCPStep_ID_ACN_Encode(pVal: TOBCPStep_ID, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    TOBCPStep_ID_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = pVal match
        case TOBCPStep_ID.TstopAtEndOfCurrentStep => ULong.fromRaw(0L)
        case TOBCPStep_ID.TnextStep => ULong.fromRaw(1L)

    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(1))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 2)
            bitCountLemma(intVal_pVal)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(intVal_pVal, 2)
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L
    }
}

@opaque @inlineOnce 
def TOBCPStep_ID_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TOBCPStep_ID] =
{
    require(codec.base.bitStream.validate_offset_bits(2L))

    @ghost val oldCdc = snapshot(codec)
    val intVal_pVal = codec.dec_Int_PositiveInteger_ConstSize(2)

    val pVal = intVal_pVal.toRaw match
        case 0 => TOBCPStep_ID.TstopAtEndOfCurrentStep
        case 1 => TOBCPStep_ID.TnextStep
        case _ => return LeftMut(ERR_ACN_DECODE_OBCPSTEP_ID)

    TOBCPStep_ID_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TOBCPStep_ID](l)
        case Right(_) => RightMut[ErrorCode, TOBCPStep_ID](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TOBCPStep_ID]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 2L && TOBCPStep_ID_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TOBCPStep_ID_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TOBCPStep_ID]) =
{
    require(codec.base.bitStream.validate_offset_bits(2L))
    val cpy = snapshot(codec)
    val res = TOBCPStep_ID_ACN_Decode(cpy)
    (cpy, res)
}