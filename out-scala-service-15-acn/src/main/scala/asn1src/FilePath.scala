/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang.{ghost => ghostExpr, _}
import stainless.annotation._
import stainless.collection._
import stainless.proof._
import StaticChecks._


def TFilePath_IsConstraintValid(pVal: TFilePath): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TPUSC_CHARSTR_VARIABLE_LEN_IsConstraintValid(pVal.repositoryPath)
    if ret.isRight then
        ret = TPUSC_CHARSTR_VARIABLE_LEN_IsConstraintValid(pVal.fileName)
    ret
}

def TFilePath_Initialize(): TFilePath = TFilePath(repositoryPath = Vector.fill[UByte](4095.toInt+1)(0x0.toRawUByte), fileName = Vector.fill[UByte](4095.toInt+1)(0x0.toRawUByte))

@opaque @inlineOnce 
def TFilePath_ACN_Encode(pVal: TFilePath, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(57354L))
    TFilePath_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    val FilePath_repositoryPathLength = ULong.fromRaw(pVal.repositoryPath.indexOfOrLength(0x00.toRawUByte))
    if FilePath_repositoryPathLength < ULong.fromRaw(0) || FilePath_repositoryPathLength > ULong.fromRaw(4095) then
        return Left(860)
    /* Encode FilePath_repositoryPathLength */
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(4095))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 12)
            bitCountLemma(FilePath_repositoryPathLength)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(FilePath_repositoryPathLength, 12)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 57354L, 12L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 12L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 12L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode repositoryPath */
    locally {
        val bix = codec.base.bitStream.bitIndex
        codec.enc_IA5String_CharIndex_External_Field_DeterminantVec(4095, pVal.repositoryPath)
        if codec.base.bitStream.bitIndex > bix + 4095L * 7L || codec.base.bitStream.bitIndex != bix + 7L * pVal.repositoryPath.indexOfOrLength(UByte.fromRaw(0.toByte)) then
            return Left(461)
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 57342L, 28665L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 28677L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 7L * pVal.repositoryPath.indexOfOrLength(UByte.fromRaw(0.toByte))
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    val FilePath_fileNameLength = ULong.fromRaw(pVal.fileName.indexOfOrLength(0x00.toRawUByte))
    if FilePath_fileNameLength < ULong.fromRaw(0) || FilePath_fileNameLength > ULong.fromRaw(4095) then
        return Left(860)
    /* Encode FilePath_fileNameLength */
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(4095))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 12)
            bitCountLemma(FilePath_fileNameLength)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(FilePath_fileNameLength, 12)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 28677L, 12L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 28689L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = 12L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Encode fileName */
    locally {
        val bix = codec.base.bitStream.bitIndex
        codec.enc_IA5String_CharIndex_External_Field_DeterminantVec(4095, pVal.fileName)
        if codec.base.bitStream.bitIndex > bix + 4095L * 7L || codec.base.bitStream.bitIndex != bix + 7L * pVal.fileName.indexOfOrLength(UByte.fromRaw(0.toByte)) then
            return Left(461)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 57354L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_3 = 7L * pVal.fileName.indexOfOrLength(UByte.fromRaw(0.toByte))
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 57354L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TFilePath_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TFilePath] =
{
    require(codec.base.bitStream.validate_offset_bits(57354L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode FilePath_repositoryPathLength */
    val FilePath_repositoryPathLength = codec.dec_Int_PositiveInteger_ConstSize(12)

    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 57354L, 12L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 12L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 12L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode repositoryPath */
    val pVal_repositoryPath = locally {
        val bix = codec.base.bitStream.bitIndex
        if FilePath_repositoryPathLength.toRaw < 0L then
            return LeftMut(464)
        val pVal_repositoryPath = codec.dec_IA5String_CharIndex_External_Field_DeterminantVec(4095, FilePath_repositoryPathLength.toRaw)
        if codec.base.bitStream.bitIndex > bix + 4095L * 7L || codec.base.bitStream.bitIndex != bix + 7L * pVal_repositoryPath.indexOfOrLength(UByte.fromRaw(0.toByte)) then
            return LeftMut(470)
        pVal_repositoryPath
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 57342L, 28665L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 28677L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 7L * pVal_repositoryPath.indexOfOrLength(UByte.fromRaw(0.toByte))
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Decode FilePath_fileNameLength */
    val FilePath_fileNameLength = codec.dec_Int_PositiveInteger_ConstSize(12)

    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 28677L, 12L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 28689L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = 12L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Decode fileName */
    val pVal_fileName = locally {
        val bix = codec.base.bitStream.bitIndex
        if FilePath_fileNameLength.toRaw < 0L then
            return LeftMut(464)
        val pVal_fileName = codec.dec_IA5String_CharIndex_External_Field_DeterminantVec(4095, FilePath_fileNameLength.toRaw)
        if codec.base.bitStream.bitIndex > bix + 4095L * 7L || codec.base.bitStream.bitIndex != bix + 7L * pVal_fileName.indexOfOrLength(UByte.fromRaw(0.toByte)) then
            return LeftMut(470)
        pVal_fileName
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 57354L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_3 = 7L * pVal_fileName.indexOfOrLength(UByte.fromRaw(0.toByte))
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 57354L)
    }
    val pVal = TFilePath(pVal_repositoryPath, pVal_fileName)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3)
    }

    TFilePath_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TFilePath](l)
        case Right(_) => RightMut[ErrorCode, TFilePath](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TFilePath]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TFilePath_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TFilePath_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TFilePath]) =
{
    require(codec.base.bitStream.validate_offset_bits(57354L))
    val cpy = snapshot(codec)
    val res = TFilePath_ACN_Decode(cpy)
    (cpy, res)
}