/*
Code automatically generated by asn1scc tool
*/
package asn1src

import asn1scala._
import stainless.lang.{ghost => ghostExpr, _}
import stainless.annotation._
import stainless.collection._
import stainless.proof._
import StaticChecks._


def TTM_PacketSecondaryHeader_messageTypeCounter_IsConstraintValid(pVal: TTM_PacketSecondaryHeader_messageTypeCounter): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = (pVal <= ULong.fromRaw(65535L)) match
        case true =>
            Right(0)
        case false =>
            Left(45)
    ret
}

def TTM_PacketSecondaryHeader_IsConstraintValid(pVal: TTM_PacketSecondaryHeader): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TSpacecraftTimeReferenceStatus_IsConstraintValid(pVal.spacecraftTimeReferenceStatus)
    if ret.isRight then
        ret = TTM_PacketSecondaryHeader_messageTypeCounter_IsConstraintValid(pVal.messageTypeCounter)
        if ret.isRight then
            ret = TApplicationProcessUser_ID_IsConstraintValid(pVal.destination_ID)
            if ret.isRight then
                ret = TCDS_AbsoluteTime_PFC_2_IsConstraintValid(pVal.time)
    ret
}

def TTM_PacketSecondaryHeader_messageTypeCounter_Initialize(): TTM_PacketSecondaryHeader_messageTypeCounter = ULong.fromRaw(0L)
def TTM_PacketSecondaryHeader_Initialize(): TTM_PacketSecondaryHeader = TTM_PacketSecondaryHeader(tmPacketPusVersionNumber = 0, spacecraftTimeReferenceStatus = ULong.fromRaw(0L), messageTypeCounter = ULong.fromRaw(0L), destination_ID = ULong.fromRaw(0L), time = TCDS_AbsoluteTime_PFC_2_Initialize())

@opaque @inlineOnce 
def TTM_PacketSecondaryHeader_ACN_Encode(pVal: TTM_PacketSecondaryHeader, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(100L))
    TTM_PacketSecondaryHeader_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode spacecraftTimeReferenceStatus */
    TSpacecraftTimeReferenceStatus_ACN_Encode(pVal.spacecraftTimeReferenceStatus, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 100L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 4L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Encode messageTypeCounter */
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_16(pVal.messageTypeCounter)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 96L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 20L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Encode destination_ID */
    TApplicationProcessUser_ID_ACN_Encode(pVal.destination_ID, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 80L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 36L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_3 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Encode time */
    TCDS_AbsoluteTime_PFC_2_ACN_Encode(pVal.time, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 100L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_4 = pVal.time.size(codec_0_5.base.bitStream.bitIndex)
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 100L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3 + size_4)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TTM_PacketSecondaryHeader_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TTM_PacketSecondaryHeader] =
{
    require(codec.base.bitStream.validate_offset_bits(100L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode tmPacketPusVersionNumber */
    val pVal_tmPacketPusVersionNumber: NullType = 0
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 100L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode spacecraftTimeReferenceStatus */
    val pVal_spacecraftTimeReferenceStatus = TSpacecraftTimeReferenceStatus_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 100L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 4L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Decode messageTypeCounter */
    val pVal_messageTypeCounter = codec.dec_Int_PositiveInteger_ConstSize_big_endian_16()

    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 96L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 20L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Decode destination_ID */
    val pVal_destination_ID = TApplicationProcessUser_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 80L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 36L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_3 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Decode time */
    val pVal_time = TCDS_AbsoluteTime_PFC_2_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 100L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_4 = pVal_time.size(codec_0_5.base.bitStream.bitIndex)
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 100L)
    }
    val pVal = TTM_PacketSecondaryHeader(pVal_tmPacketPusVersionNumber, pVal_spacecraftTimeReferenceStatus, pVal_messageTypeCounter, pVal_destination_ID, pVal_time)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3 + size_4)
    }

    TTM_PacketSecondaryHeader_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TTM_PacketSecondaryHeader](l)
        case Right(_) => RightMut[ErrorCode, TTM_PacketSecondaryHeader](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TTM_PacketSecondaryHeader]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TTM_PacketSecondaryHeader_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TTM_PacketSecondaryHeader_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TTM_PacketSecondaryHeader]) =
{
    require(codec.base.bitStream.validate_offset_bits(100L))
    val cpy = snapshot(codec)
    val res = TTM_PacketSecondaryHeader_ACN_Decode(cpy)
    (cpy, res)
}

def TTM_DataWithSecondaryHeader_IsConstraintValid(pVal: TTM_DataWithSecondaryHeader): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TTM_PacketSecondaryHeader_IsConstraintValid(pVal.secondaryHeader)
    if ret.isRight then
        ret = TTM_Payload_IsConstraintValid(pVal.data)
        if ret.isRight then
            pVal.packetErrorControl match
                case SomeMut(packetErrorControl) =>
                    ret = TPacketErrorControl_IsConstraintValid(packetErrorControl)
                case NoneMut() =>
    if ret.isRight then
        ret = (pVal.packetErrorControl.isDefined == true) match
            case true =>
                Right(0)
            case false =>
                Left(45)
    ret
}

def TTM_DataWithSecondaryHeader_Initialize(): TTM_DataWithSecondaryHeader = TTM_DataWithSecondaryHeader(secondaryHeader = TTM_PacketSecondaryHeader_Initialize(), data = TTM_Payload_Initialize(), packetErrorControl = SomeMut(TPacketErrorControl(Vector.fill(2)(0.toRawUByte))))

@opaque @inlineOnce 
def TTM_DataWithSecondaryHeader_ACN_Encode(pVal: TTM_DataWithSecondaryHeader, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(154L))
    TTM_DataWithSecondaryHeader_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode secondaryHeader */
    val res_pVal_secondaryHeader = TM_DataWithSecondaryHeader_secondaryHeader_ACN_Encode(codec, pVal, pVal.secondaryHeader) match {
        case Left(l) =>
            return Left(l)
        case Right((_, v1, v2)) =>
            (v1, v2)
    }
    val TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID = res_pVal_secondaryHeader._1
    val TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID = res_pVal_secondaryHeader._2
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 154L, 116L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 116L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1_0 = 0L
    @ghost val size_1_1 = 4L
    @ghost val size_1_2 = 8L
    @ghost val size_1_3 = 8L
    @ghost val size_1_4 = 16L
    @ghost val size_1_5 = 16L
    @ghost val size_1_6 = pVal.secondaryHeader.time.size(codec_0_1.base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5)
    @ghost val size_0 = size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5 + size_1_6
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode data */
    TM_DataWithSecondaryHeader_data_ACN_Encode(codec, pVal, TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID, TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID, pVal.data) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 38L, 15L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 131L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = pVal.data match {
        case TTM_Payload.tm_255_255_PRESENT(tm_255_255) =>
            alignedSizeToByte(8L, codec_0_2.base.bitStream.bitIndex)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    TM_DataWithSecondaryHeader_packetErrorControl_Optional_ACN_Encode(codec, pVal, pVal.packetErrorControl) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 154L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = pVal.packetErrorControl match {
        case SomeMut(v) =>
            alignedSizeToByte(16L, codec_0_3.base.bitStream.bitIndex)
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 154L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def TM_DataWithSecondaryHeader_secondaryHeader_ACN_Encode(codec: ACN, pVal: TTM_DataWithSecondaryHeader, secondaryHeader: TTM_PacketSecondaryHeader): Either[Int, (Int, ULong, ULong)] = {
    require(codec.base.bitStream.validate_offset_bits(116L))
    @ghost val oldCdc = snapshot(codec)
    TTM_PacketSecondaryHeader_IsConstraintValid(secondaryHeader) match {
        case Left(l) =>
            return Left[Int, (Int, ULong, ULong)](l)
        case Right(_) =>
    }
    @ghost val codec_0_1 = snapshot(codec)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode spacecraftTimeReferenceStatus */
    TSpacecraftTimeReferenceStatus_ACN_Encode(secondaryHeader.spacecraftTimeReferenceStatus, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 116L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 4L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    val TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID = pVal.data match
        case _: TTM_Payload.tm_255_255_PRESENT =>
            ULong.fromRaw(255)
    /* Encode TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID */
    codec.enc_Int_PositiveInteger_ConstSize_8(TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 112L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 12L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    val TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID = pVal.data match
        case _: TTM_Payload.tm_255_255_PRESENT =>
            ULong.fromRaw(255)
    /* Encode TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID */
    codec.enc_Int_PositiveInteger_ConstSize_8(TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 104L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 20L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_3 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Encode messageTypeCounter */
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_16(secondaryHeader.messageTypeCounter)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_5.base.bitStream, codec.base.bitStream, 96L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 36L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_4 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    @ghost val codec_0_6 = snapshot(codec)
    /* Encode destination_ID */
    TApplicationProcessUser_ID_ACN_Encode(secondaryHeader.destination_ID, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_6.base.bitStream, codec.base.bitStream, 80L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 52L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_5 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5)
    }
    @ghost val codec_0_7 = snapshot(codec)
    /* Encode time */
    TCDS_AbsoluteTime_PFC_2_ACN_Encode(secondaryHeader.time, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 116L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_6 = secondaryHeader.time.size(codec_0_7.base.bitStream.bitIndex)
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 116L)
    }
    Right[Int, (Int, ULong, ULong)]((0, TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID, TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID))
}.ensuring { (res: Either[Int, (Int, ULong, ULong)]) => 
    res match {
        case Left(_) =>
            true
        case Right((_, acn1, acn2)) =>
            val size_1_0 = 0L
            val size_1_1 = 4L
            val size_1_2 = 8L
            val size_1_3 = 8L
            val size_1_4 = 16L
            val size_1_5 = 16L
            val size_1_6 = secondaryHeader.time.size(old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5)
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5 + size_1_6
    }
}

@opaque @inlineOnce
def TM_DataWithSecondaryHeader_data_ACN_Encode(codec: ACN, pVal: TTM_DataWithSecondaryHeader, TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID: ULong, TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID: ULong, data: TTM_Payload): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(15L))
    @ghost val oldCdc = snapshot(codec)
    TTM_Payload_IsConstraintValid(data) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    locally {
        @ghost val unalignedCodec = snapshot(codec)
        codec.base.bitStream.alignToByte()
        ghostExpr {
            BitStream.validateOffsetBitsIneqLemma(unalignedCodec.base.bitStream, codec.base.bitStream, 15, 7L)
            check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 0L + 7L)
        }
    }
    data match
        case TTM_Payload.tm_255_255_PRESENT(tm_255_255) =>
            locally {
                ghostExpr {
                    @opaque @inlineOnce
                    def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(255) - ULong.fromRaw(0)) == 8)
                    bitCountLemma()
                }
            }
            codec.base.encodeConstrainedPosWholeNumber(tm_255_255, 0.toRawULong, 255.toRawULong)
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + data.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def TM_DataWithSecondaryHeader_packetErrorControl_Optional_ACN_Encode(codec: ACN, pVal: TTM_DataWithSecondaryHeader, packetErrorControl: OptionMut[TPacketErrorControl]): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    @ghost val oldCdc = snapshot(codec)
    /* Encode packetErrorControl */
    /* marked as ALWAYS PRESENT, so it must be Some */
    packetErrorControl match
        case SomeMut(packetErrorControl) =>
            locally {
                @ghost val unalignedCodec = snapshot(codec)
                codec.base.bitStream.alignToByte()
                ghostExpr {
                    BitStream.validateOffsetBitsIneqLemma(unalignedCodec.base.bitStream, codec.base.bitStream, 23, 7L)
                    check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 131L + 7L)
                }
            }
            assert(16.toInt >= 0) // overflow may happen during cast
            codec.base.bitStream.appendBitsMSBFirstVec(packetErrorControl.arr, 16.toInt)
    
        case NoneMut() => return Left(628)
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + alignedSizeToByte(16L, old(codec).base.bitStream.bitIndex)
    }
}



@opaque @inlineOnce 
def TTM_DataWithSecondaryHeader_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TTM_DataWithSecondaryHeader] =
{
    require(codec.base.bitStream.validate_offset_bits(154L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode secondaryHeader */
    val pVal_secondaryHeader_tuple = TM_DataWithSecondaryHeader_secondaryHeader_ACN_Decode(codec) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    val pVal_secondaryHeader = pVal_secondaryHeader_tuple._1
    val TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID = pVal_secondaryHeader_tuple._2
    val TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID = pVal_secondaryHeader_tuple._3
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 154L, 116L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 116L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1_0 = 0L
    @ghost val size_1_1 = 4L
    @ghost val size_1_2 = 8L
    @ghost val size_1_3 = 8L
    @ghost val size_1_4 = 16L
    @ghost val size_1_5 = 16L
    @ghost val size_1_6 = pVal_secondaryHeader.time.size(codec_0_1.base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5)
    @ghost val size_0 = size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5 + size_1_6
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode data */
    val pVal_data = TM_DataWithSecondaryHeader_data_ACN_Decode(codec, TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID, TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 38L, 15L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 131L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = pVal_data match {
        case TTM_Payload.tm_255_255_PRESENT(tm_255_255) =>
            alignedSizeToByte(8L, codec_0_2.base.bitStream.bitIndex)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    val pVal_packetErrorControl = TM_DataWithSecondaryHeader_packetErrorControl_Optional_ACN_Decode(codec) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 154L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = pVal_packetErrorControl match {
        case SomeMut(v) =>
            alignedSizeToByte(16L, codec_0_3.base.bitStream.bitIndex)
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 154L)
    }
    val pVal = TTM_DataWithSecondaryHeader(pVal_secondaryHeader, pVal_data, pVal_packetErrorControl)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2)
    }

    TTM_DataWithSecondaryHeader_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TTM_DataWithSecondaryHeader](l)
        case Right(_) => RightMut[ErrorCode, TTM_DataWithSecondaryHeader](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TTM_DataWithSecondaryHeader]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TTM_DataWithSecondaryHeader_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TTM_DataWithSecondaryHeader_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TTM_DataWithSecondaryHeader]) =
{
    require(codec.base.bitStream.validate_offset_bits(154L))
    val cpy = snapshot(codec)
    val res = TTM_DataWithSecondaryHeader_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def TM_DataWithSecondaryHeader_secondaryHeader_ACN_Decode(codec: ACN): EitherMut[Int, (TTM_PacketSecondaryHeader, ULong, ULong)] = {
    require(codec.base.bitStream.validate_offset_bits(116L))
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode tmPacketPusVersionNumber */
    val secondaryHeader_tmPacketPusVersionNumber: NullType = 0
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 116L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode spacecraftTimeReferenceStatus */
    val secondaryHeader_spacecraftTimeReferenceStatus = TSpacecraftTimeReferenceStatus_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 116L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 4L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Decode TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID */
    val TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID = codec.dec_Int_PositiveInteger_ConstSize_8()
    
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 112L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 12L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Decode TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID */
    val TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID = codec.dec_Int_PositiveInteger_ConstSize_8()
    
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 104L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 20L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_3 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Decode messageTypeCounter */
    val secondaryHeader_messageTypeCounter = codec.dec_Int_PositiveInteger_ConstSize_big_endian_16()
    
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_5.base.bitStream, codec.base.bitStream, 96L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 36L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_4 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    @ghost val codec_0_6 = snapshot(codec)
    /* Decode destination_ID */
    val secondaryHeader_destination_ID = TApplicationProcessUser_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_6.base.bitStream, codec.base.bitStream, 80L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 52L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_5 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5)
    }
    @ghost val codec_0_7 = snapshot(codec)
    /* Decode time */
    val secondaryHeader_time = TCDS_AbsoluteTime_PFC_2_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 116L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_6 = secondaryHeader_time.size(codec_0_7.base.bitStream.bitIndex)
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 116L)
    }
    val secondaryHeader = TTM_PacketSecondaryHeader(secondaryHeader_tmPacketPusVersionNumber, secondaryHeader_spacecraftTimeReferenceStatus, secondaryHeader_messageTypeCounter, secondaryHeader_destination_ID, secondaryHeader_time)
    TTM_PacketSecondaryHeader_IsConstraintValid(secondaryHeader) match {
        case Left(l) =>
            LeftMut[Int, (TTM_PacketSecondaryHeader, ULong, ULong)](l)
        case Right(_) =>
            RightMut[Int, (TTM_PacketSecondaryHeader, ULong, ULong)]((secondaryHeader, TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID, TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID))
    }
}.ensuring { (res: EitherMut[Int, (TTM_PacketSecondaryHeader, ULong, ULong)]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut((resVal, _, _)) =>
            val size_1_0 = 0L
            val size_1_1 = 4L
            val size_1_2 = 8L
            val size_1_3 = 8L
            val size_1_4 = 16L
            val size_1_5 = 16L
            val size_1_6 = resVal.time.size(old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5)
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5 + size_1_6 && TTM_PacketSecondaryHeader_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def TM_DataWithSecondaryHeader_secondaryHeader_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, (TTM_PacketSecondaryHeader, ULong, ULong)]) = {
    require(codec.base.bitStream.validate_offset_bits(116L))
    val cpy = snapshot(codec)
    val res = TM_DataWithSecondaryHeader_secondaryHeader_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def TM_DataWithSecondaryHeader_data_ACN_Decode(codec: ACN, TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID: ULong, TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID: ULong): EitherMut[Int, TTM_Payload] = {
    require(codec.base.bitStream.validate_offset_bits(15L))
    @ghost val oldCdc = snapshot(codec)
    locally {
        @ghost val unalignedCodec = snapshot(codec)
        codec.base.bitStream.alignToByte()
        ghostExpr {
            BitStream.validateOffsetBitsIneqLemma(unalignedCodec.base.bitStream, codec.base.bitStream, 15, 7L)
            check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 0L + 7L)
        }
    }
    val data = if ((TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID == ULong.fromRaw(255)) && (TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID == ULong.fromRaw(255))) {
        locally {
            ghostExpr {
                @opaque @inlineOnce
                def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(255) - ULong.fromRaw(0)) == 8)
                bitCountLemma()
            }
        }
        val tm_255_255 = codec.base.decodeConstrainedPosWholeNumber(ULong.fromRaw(0), ULong.fromRaw(255)) // uper:135
        TTM_Payload.tm_255_255_PRESENT(tm_255_255)
    }
    else return LeftMut(ERR_ACN_DECODE_TM_DATAWITHSECONDARYHEADER_DATA)
    TTM_Payload_IsConstraintValid(data) match {
        case Left(l) =>
            LeftMut[Int, TTM_Payload](l)
        case Right(_) =>
            RightMut[Int, TTM_Payload](data)
    }
}.ensuring { (res: EitherMut[Int, TTM_Payload]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TTM_Payload_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def TM_DataWithSecondaryHeader_data_ACN_Decode_pure(codec: ACN, TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID: ULong, TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID: ULong): (ACN, EitherMut[Int, TTM_Payload]) = {
    require(codec.base.bitStream.validate_offset_bits(15L))
    val cpy = snapshot(codec)
    val res = TM_DataWithSecondaryHeader_data_ACN_Decode(cpy, TM_DataWithSecondaryHeader_secondaryHeader_serviceType_ID, TM_DataWithSecondaryHeader_secondaryHeader_messageSubtype_ID)
    (cpy, res)
}

@opaque @inlineOnce
def TM_DataWithSecondaryHeader_packetErrorControl_Optional_ACN_Decode(codec: ACN): EitherMut[Int, OptionMut[TPacketErrorControl]] = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    @ghost val oldCdc = snapshot(codec)
    /* Decode packetErrorControl */
    /* marked as ALWAYS PRESENT */
    val packetErrorControl: OptionMut[TPacketErrorControl] =
        locally {
            @ghost val unalignedCodec = snapshot(codec)
            codec.base.bitStream.alignToByte()
            ghostExpr {
                BitStream.validateOffsetBitsIneqLemma(unalignedCodec.base.bitStream, codec.base.bitStream, 23, 7L)
                check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 131L + 7L)
            }
        }
        val pVal_packetErrorControl = TPacketErrorControl(codec.base.bitStream.readBitsVec(16.toInt))
        SomeMut(pVal_packetErrorControl)
    RightMut[Int, OptionMut[TPacketErrorControl]](packetErrorControl)
}.ensuring { (res: EitherMut[Int, OptionMut[TPacketErrorControl]]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            resVal.isDefined && old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + alignedSizeToByte(16L, old(codec).base.bitStream.bitIndex)
    }
}



@ghost @pure
def TM_DataWithSecondaryHeader_packetErrorControl_Optional_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, OptionMut[TPacketErrorControl]]) = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    val cpy = snapshot(codec)
    val res = TM_DataWithSecondaryHeader_packetErrorControl_Optional_ACN_Decode(cpy)
    (cpy, res)
}



def TTM_DataNoSecondaryHeader_IsConstraintValid(pVal: TTM_DataNoSecondaryHeader): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal.packetErrorControl match
        case SomeMut(packetErrorControl) =>
            ret = TPacketErrorControl_IsConstraintValid(packetErrorControl)
        case NoneMut() =>
    if ret.isRight then
        ret = (pVal.packetErrorControl.isDefined == true) match
            case true =>
                Right(0)
            case false =>
                Left(45)
    ret
}

def TTM_DataNoSecondaryHeader_Initialize(): TTM_DataNoSecondaryHeader = TTM_DataNoSecondaryHeader(data = 0, packetErrorControl = SomeMut(TPacketErrorControl(Vector.fill(2)(0.toRawUByte))))

@opaque @inlineOnce 
def TTM_DataNoSecondaryHeader_ACN_Encode(pVal: TTM_DataNoSecondaryHeader, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(23L))
    TTM_DataNoSecondaryHeader_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode data */
    TTM_NoHeaderPayload_ACN_Encode(pVal.data, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 23L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    TM_DataNoSecondaryHeader_packetErrorControl_Optional_ACN_Encode(codec, pVal, pVal.packetErrorControl) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 23L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = pVal.packetErrorControl match {
        case SomeMut(v) =>
            alignedSizeToByte(16L, codec_0_2.base.bitStream.bitIndex)
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 23L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def TM_DataNoSecondaryHeader_packetErrorControl_Optional_ACN_Encode(codec: ACN, pVal: TTM_DataNoSecondaryHeader, packetErrorControl: OptionMut[TPacketErrorControl]): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    @ghost val oldCdc = snapshot(codec)
    /* Encode packetErrorControl */
    /* marked as ALWAYS PRESENT, so it must be Some */
    packetErrorControl match
        case SomeMut(packetErrorControl) =>
            locally {
                @ghost val unalignedCodec = snapshot(codec)
                codec.base.bitStream.alignToByte()
                ghostExpr {
                    BitStream.validateOffsetBitsIneqLemma(unalignedCodec.base.bitStream, codec.base.bitStream, 23, 7L)
                    check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 0L + 7L)
                }
            }
            assert(16.toInt >= 0) // overflow may happen during cast
            codec.base.bitStream.appendBitsMSBFirstVec(packetErrorControl.arr, 16.toInt)
    
        case NoneMut() => return Left(628)
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + alignedSizeToByte(16L, old(codec).base.bitStream.bitIndex)
    }
}



@opaque @inlineOnce 
def TTM_DataNoSecondaryHeader_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TTM_DataNoSecondaryHeader] =
{
    require(codec.base.bitStream.validate_offset_bits(23L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode data */
    val pVal_data = TTM_NoHeaderPayload_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 23L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    val pVal_packetErrorControl = TM_DataNoSecondaryHeader_packetErrorControl_Optional_ACN_Decode(codec) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 23L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = pVal_packetErrorControl match {
        case SomeMut(v) =>
            alignedSizeToByte(16L, codec_0_2.base.bitStream.bitIndex)
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 23L)
    }
    val pVal = TTM_DataNoSecondaryHeader(pVal_data, pVal_packetErrorControl)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TTM_DataNoSecondaryHeader_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TTM_DataNoSecondaryHeader](l)
        case Right(_) => RightMut[ErrorCode, TTM_DataNoSecondaryHeader](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TTM_DataNoSecondaryHeader]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TTM_DataNoSecondaryHeader_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TTM_DataNoSecondaryHeader_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TTM_DataNoSecondaryHeader]) =
{
    require(codec.base.bitStream.validate_offset_bits(23L))
    val cpy = snapshot(codec)
    val res = TTM_DataNoSecondaryHeader_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def TM_DataNoSecondaryHeader_packetErrorControl_Optional_ACN_Decode(codec: ACN): EitherMut[Int, OptionMut[TPacketErrorControl]] = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    @ghost val oldCdc = snapshot(codec)
    /* Decode packetErrorControl */
    /* marked as ALWAYS PRESENT */
    val packetErrorControl: OptionMut[TPacketErrorControl] =
        locally {
            @ghost val unalignedCodec = snapshot(codec)
            codec.base.bitStream.alignToByte()
            ghostExpr {
                BitStream.validateOffsetBitsIneqLemma(unalignedCodec.base.bitStream, codec.base.bitStream, 23, 7L)
                check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 0L + 7L)
            }
        }
        val pVal_packetErrorControl = TPacketErrorControl(codec.base.bitStream.readBitsVec(16.toInt))
        SomeMut(pVal_packetErrorControl)
    RightMut[Int, OptionMut[TPacketErrorControl]](packetErrorControl)
}.ensuring { (res: EitherMut[Int, OptionMut[TPacketErrorControl]]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            resVal.isDefined && old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + alignedSizeToByte(16L, old(codec).base.bitStream.bitIndex)
    }
}



@ghost @pure
def TM_DataNoSecondaryHeader_packetErrorControl_Optional_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, OptionMut[TPacketErrorControl]]) = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    val cpy = snapshot(codec)
    val res = TM_DataNoSecondaryHeader_packetErrorControl_Optional_ACN_Decode(cpy)
    (cpy, res)
}



def TTM_PacketDataField_IsConstraintValid(pVal: TTM_PacketDataField): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    pVal match
        case TTM_PacketDataField.TM_PacketDataField_dataWithSecondaryHeader_PRESENT(dataWithSecondaryHeader) =>
            ret = TTM_DataWithSecondaryHeader_IsConstraintValid(dataWithSecondaryHeader)
        case TTM_PacketDataField.TM_PacketDataField_dataNoSecondaryHeader_PRESENT(dataNoSecondaryHeader) =>
            ret = TTM_DataNoSecondaryHeader_IsConstraintValid(dataNoSecondaryHeader)
    ret
}

def TTM_PacketDataField_Initialize(): TTM_PacketDataField = TTM_PacketDataField.TM_PacketDataField_dataWithSecondaryHeader_PRESENT(TTM_DataWithSecondaryHeader_Initialize())

def TTM_PacketType_Initialize(): TTM_PacketType = 0

@opaque @inlineOnce 
def TTM_PacketType_ACN_Encode(@annotation.unused pVal: TTM_PacketType, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    locally {
        val tmp: Array[UByte] = Array(0x00.toRawUByte)
        codec.base.bitStream.appendBitsMSBFirst(tmp, 1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 1L
    }
}

@opaque @inlineOnce 
def TTM_PacketType_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TTM_PacketType] =
{
    require(codec.base.bitStream.validate_offset_bits(1L))

    @ghost val oldCdc = snapshot(codec)
    locally {
        val tmp: Array[UByte] = Array(0x00.toRawUByte)
        if !codec.BitStream_ReadBitPattern(tmp, 1) then
            return LeftMut(ERR_ACN_DECODE_TM_PACKETTYPE)

    }
    val pVal: NullType = 0

    RightMut[ErrorCode, TTM_PacketType](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TTM_PacketType]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + 1L
    }
}

@ghost @pure 
def TTM_PacketType_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TTM_PacketType]) =
{
    require(codec.base.bitStream.validate_offset_bits(1L))
    val cpy = snapshot(codec)
    val res = TTM_PacketType_ACN_Decode(cpy)
    (cpy, res)
}

def TTM_Packet_ID_IsConstraintValid(pVal: TTM_Packet_ID): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TApplicationProcess_ID_IsConstraintValid(pVal.applicationProcess_ID)
    ret
}

def TTM_Packet_ID_Initialize(): TTM_Packet_ID = TTM_Packet_ID(packetType = 0, applicationProcess_ID = ULong.fromRaw(0L))

@opaque @inlineOnce 
def TTM_Packet_ID_ACN_Encode(pVal: TTM_Packet_ID, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(12L))
    TTM_Packet_ID_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode packetType */
    TTM_PacketType_ACN_Encode(pVal.packetType, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 12L, 1L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 1L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode applicationProcess_ID */
    TApplicationProcess_ID_ACN_Encode(pVal.applicationProcess_ID, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 12L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 11L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 12L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TTM_Packet_ID_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TTM_Packet_ID] =
{
    require(codec.base.bitStream.validate_offset_bits(12L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode packetType */
    val pVal_packetType = TTM_PacketType_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 12L, 1L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 1L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode applicationProcess_ID */
    val pVal_applicationProcess_ID = TApplicationProcess_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 12L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 11L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 12L)
    }
    val pVal = TTM_Packet_ID(pVal_packetType, pVal_applicationProcess_ID)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1)
    }

    TTM_Packet_ID_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TTM_Packet_ID](l)
        case Right(_) => RightMut[ErrorCode, TTM_Packet_ID](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TTM_Packet_ID]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TTM_Packet_ID_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TTM_Packet_ID_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TTM_Packet_ID]) =
{
    require(codec.base.bitStream.validate_offset_bits(12L))
    val cpy = snapshot(codec)
    val res = TTM_Packet_ID_ACN_Decode(cpy)
    (cpy, res)
}

def TTM_CCSDS_Packet_IsConstraintValid(pVal: TTM_CCSDS_Packet): Either[ErrorCode, Int] =
{
    var ret: Either[ErrorCode, Int] = Right(0)
    ret = TTM_Packet_ID_IsConstraintValid(pVal.packet_ID)
    if ret.isRight then
        ret = TPacketSequenceControl_IsConstraintValid(pVal.packetSequenceControl)
        if ret.isRight then
            ret = TPacketDataLength_IsConstraintValid(pVal.packetDataLength)
            if ret.isRight then
                ret = TTM_PacketDataField_IsConstraintValid(pVal.packetDataField)
    ret
}

def TTM_CCSDS_Packet_Initialize(): TTM_CCSDS_Packet = TTM_CCSDS_Packet(packetVersionNumber = 0, packet_ID = TTM_Packet_ID_Initialize(), packetSequenceControl = TPacketSequenceControl_Initialize(), packetDataLength = ULong.fromRaw(0L), packetDataField = TTM_PacketDataField_Initialize())

@opaque @inlineOnce 
def TTM_CCSDS_Packet_ACN_Encode(pVal: TTM_CCSDS_Packet, codec: ACN, bCheckConstraints: Boolean): Either[ErrorCode, Int] =  // acn:21
{
    require(codec.base.bitStream.validate_offset_bits(202L))
    TTM_CCSDS_Packet_IsConstraintValid(pVal) match
        case Left(l) => return Left(l)
        case Right(_) =>
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode packetVersionNumber */
    TPacketVersionNumberValue_ACN_Encode(pVal.packetVersionNumber, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 202L, 3L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 3L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 3L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode packet_ID */
    val res_pVal_packet_ID = TM_CCSDS_Packet_packet_ID_ACN_Encode(codec, pVal, pVal.packet_ID) match {
        case Left(l) =>
            return Left(l)
        case Right((_, v1)) =>
            v1
    }
    val TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag = res_pVal_packet_ID
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 199L, 13L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 16L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1_1 = 1L
    @ghost val size_1_2 = 1L
    @ghost val size_1_3 = 11L
    @ghost val size_1 = size_1_1 + size_1_2 + size_1_3
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Encode packetSequenceControl */
    TPacketSequenceControl_ACN_Encode(pVal.packetSequenceControl, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 186L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = pVal.packetSequenceControl.size(codec_0_3.base.bitStream.bitIndex)
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Encode packetDataLength */
    TPacketDataLength_ACN_Encode(pVal.packetDataLength, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 170L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 48L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_3 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Encode packetDataField */
    TM_CCSDS_Packet_packetDataField_ACN_Encode(codec, pVal, TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag, pVal.packetDataField) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 202L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_4 = pVal.packetDataField match {
        case TTM_PacketDataField.TM_PacketDataField_dataWithSecondaryHeader_PRESENT(dataWithSecondaryHeader) =>
            val size_3_4 = 0L
            val size_3_5 = 4L
            val size_3_6 = 8L
            val size_3_7 = 8L
            val size_3_8 = 16L
            val size_3_9 = 16L
            val size_3_10 = dataWithSecondaryHeader.secondaryHeader.time.size(codec_0_5.base.bitStream.bitIndex + size_3_4 + size_3_5 + size_3_6 + size_3_7 + size_3_8 + size_3_9)
            val size_2_4 = size_3_4 + size_3_5 + size_3_6 + size_3_7 + size_3_8 + size_3_9 + size_3_10
            val size_2_5 = dataWithSecondaryHeader.data match {
                case TTM_Payload.tm_255_255_PRESENT(tm_255_255) =>
                    alignedSizeToByte(8L, codec_0_5.base.bitStream.bitIndex + size_2_4)
            }
            val size_2_6 = dataWithSecondaryHeader.packetErrorControl match {
                case SomeMut(v) =>
                    alignedSizeToByte(16L, codec_0_5.base.bitStream.bitIndex + size_2_4 + size_2_5)
                case NoneMut() =>
                    0L
            }
            size_2_4 + size_2_5 + size_2_6
        case TTM_PacketDataField.TM_PacketDataField_dataNoSecondaryHeader_PRESENT(dataNoSecondaryHeader) =>
            val size_2_4 = 0L
            val size_2_5 = dataNoSecondaryHeader.packetErrorControl match {
                case SomeMut(v) =>
                    alignedSizeToByte(16L, codec_0_5.base.bitStream.bitIndex + size_2_4)
                case NoneMut() =>
                    0L
            }
            size_2_4 + size_2_5
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 202L)
    }
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3 + size_4)
    }
    Right(0)
}.ensuring { (res : Either[ErrorCode, Int]) =>
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + pVal.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def TM_CCSDS_Packet_packet_ID_ACN_Encode(codec: ACN, pVal: TTM_CCSDS_Packet, packet_ID: TTM_Packet_ID): Either[Int, (Int, ULong)] = {
    require(codec.base.bitStream.validate_offset_bits(13L))
    @ghost val oldCdc = snapshot(codec)
    TTM_Packet_ID_IsConstraintValid(packet_ID) match {
        case Left(l) =>
            return Left[Int, (Int, ULong)](l)
        case Right(_) =>
    }
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode packetType */
    TTM_PacketType_ACN_Encode(packet_ID.packetType, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 13L, 1L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 1L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    val TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag = pVal.packetDataField match
        case _: TTM_PacketDataField.TM_PacketDataField_dataWithSecondaryHeader_PRESENT =>
            ULong.fromRaw(1)
        case _: TTM_PacketDataField.TM_PacketDataField_dataNoSecondaryHeader_PRESENT =>
            ULong.fromRaw(0)
    /* Encode TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag */
    locally {
        ghostExpr {
            @opaque @inlineOnce
            def bitCountLemma(v: ULong): Unit = {
                require(v <= ULong.fromRaw(1))
            }.ensuring(_ => GetBitCountUnsigned(v) <= 1)
            bitCountLemma(TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag)
        }
    }
    codec.enc_Int_PositiveInteger_ConstSize(TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag, 1)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 12L, 1L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 2L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 1L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Encode applicationProcess_ID */
    TApplicationProcess_ID_ACN_Encode(packet_ID.applicationProcess_ID, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 13L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = 11L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 13L)
    }
    Right[Int, (Int, ULong)]((0, TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag))
}.ensuring { (res: Either[Int, (Int, ULong)]) => 
    res match {
        case Left(_) =>
            true
        case Right((_, acn1)) =>
            val size_1_0 = 1L
            val size_1_1 = 1L
            val size_1_2 = 11L
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2
    }
}

@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_ACN_Encode(codec: ACN, pVal: TTM_CCSDS_Packet, dataWithSecondaryHeader: TTM_DataWithSecondaryHeader, secondaryHeader: TTM_PacketSecondaryHeader): Either[Int, (Int, ULong, ULong)] = {
    require(codec.base.bitStream.validate_offset_bits(116L))
    @ghost val oldCdc = snapshot(codec)
    TTM_PacketSecondaryHeader_IsConstraintValid(secondaryHeader) match {
        case Left(l) =>
            return Left[Int, (Int, ULong, ULong)](l)
        case Right(_) =>
    }
    @ghost val codec_0_1 = snapshot(codec)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode spacecraftTimeReferenceStatus */
    TSpacecraftTimeReferenceStatus_ACN_Encode(secondaryHeader.spacecraftTimeReferenceStatus, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 116L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 4L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID =
        if pVal.packetDataField.isInstanceOf[TTM_PacketDataField.TM_PacketDataField_dataWithSecondaryHeader_PRESENT] then
            val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID = dataWithSecondaryHeader.data match
                case _: TTM_Payload.tm_255_255_PRESENT =>
                    ULong.fromRaw(255)
            TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID
        else ULong.fromRaw(0)
    /* Encode TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID */
    codec.enc_Int_PositiveInteger_ConstSize_8(TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 112L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 12L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID =
        if pVal.packetDataField.isInstanceOf[TTM_PacketDataField.TM_PacketDataField_dataWithSecondaryHeader_PRESENT] then
            val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID = dataWithSecondaryHeader.data match
                case _: TTM_Payload.tm_255_255_PRESENT =>
                    ULong.fromRaw(255)
            TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID
        else ULong.fromRaw(0)
    /* Encode TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID */
    codec.enc_Int_PositiveInteger_ConstSize_8(TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 104L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 20L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_3 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Encode messageTypeCounter */
    codec.enc_Int_PositiveInteger_ConstSize_big_endian_16(secondaryHeader.messageTypeCounter)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_5.base.bitStream, codec.base.bitStream, 96L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 36L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_4 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    @ghost val codec_0_6 = snapshot(codec)
    /* Encode destination_ID */
    TApplicationProcessUser_ID_ACN_Encode(secondaryHeader.destination_ID, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_6.base.bitStream, codec.base.bitStream, 80L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 52L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_5 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5)
    }
    @ghost val codec_0_7 = snapshot(codec)
    /* Encode time */
    TCDS_AbsoluteTime_PFC_2_ACN_Encode(secondaryHeader.time, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 116L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_6 = secondaryHeader.time.size(codec_0_7.base.bitStream.bitIndex)
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 116L)
    }
    Right[Int, (Int, ULong, ULong)]((0, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID))
}.ensuring { (res: Either[Int, (Int, ULong, ULong)]) => 
    res match {
        case Left(_) =>
            true
        case Right((_, acn1, acn2)) =>
            val size_1_0 = 0L
            val size_1_1 = 4L
            val size_1_2 = 8L
            val size_1_3 = 8L
            val size_1_4 = 16L
            val size_1_5 = 16L
            val size_1_6 = secondaryHeader.time.size(old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5)
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5 + size_1_6
    }
}

@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_data_ACN_Encode(codec: ACN, pVal: TTM_CCSDS_Packet, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID: ULong, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID: ULong, data: TTM_Payload): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(15L))
    @ghost val oldCdc = snapshot(codec)
    TTM_Payload_IsConstraintValid(data) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    locally {
        @ghost val unalignedCodec = snapshot(codec)
        codec.base.bitStream.alignToByte()
        ghostExpr {
            BitStream.validateOffsetBitsIneqLemma(unalignedCodec.base.bitStream, codec.base.bitStream, 15, 7L)
            check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 0L + 7L)
        }
    }
    data match
        case TTM_Payload.tm_255_255_PRESENT(tm_255_255) =>
            locally {
                ghostExpr {
                    @opaque @inlineOnce
                    def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(255) - ULong.fromRaw(0)) == 8)
                    bitCountLemma()
                }
            }
            codec.base.encodeConstrainedPosWholeNumber(tm_255_255, 0.toRawULong, 255.toRawULong)
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + data.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_packetErrorControl_Optional_ACN_Encode(codec: ACN, pVal: TTM_CCSDS_Packet, packetErrorControl: OptionMut[TPacketErrorControl]): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    @ghost val oldCdc = snapshot(codec)
    /* Encode packetErrorControl */
    /* marked as ALWAYS PRESENT, so it must be Some */
    packetErrorControl match
        case SomeMut(packetErrorControl) =>
            locally {
                @ghost val unalignedCodec = snapshot(codec)
                codec.base.bitStream.alignToByte()
                ghostExpr {
                    BitStream.validateOffsetBitsIneqLemma(unalignedCodec.base.bitStream, codec.base.bitStream, 23, 7L)
                    check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 131L + 7L)
                }
            }
            assert(16.toInt >= 0) // overflow may happen during cast
            codec.base.bitStream.appendBitsMSBFirstVec(packetErrorControl.arr, 16.toInt)
    
        case NoneMut() => return Left(628)
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + alignedSizeToByte(16L, old(codec).base.bitStream.bitIndex)
    }
}



@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_ACN_Encode(codec: ACN, pVal: TTM_CCSDS_Packet, dataWithSecondaryHeader: TTM_DataWithSecondaryHeader): Either[Int, (Int, ULong, ULong)] = {
    require(codec.base.bitStream.validate_offset_bits(154L))
    @ghost val oldCdc = snapshot(codec)
    TTM_DataWithSecondaryHeader_IsConstraintValid(dataWithSecondaryHeader) match {
        case Left(l) =>
            return Left[Int, (Int, ULong, ULong)](l)
        case Right(_) =>
    }
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode secondaryHeader */
    val res_dataWithSecondaryHeader_secondaryHeader = TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_ACN_Encode(codec, pVal, dataWithSecondaryHeader, dataWithSecondaryHeader.secondaryHeader) match {
        case Left(l) =>
            return Left(l)
        case Right((_, v1, v2)) =>
            (v1, v2)
    }
    val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID = res_dataWithSecondaryHeader_secondaryHeader._1
    val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID = res_dataWithSecondaryHeader_secondaryHeader._2
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 154L, 116L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 116L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1_0 = 0L
    @ghost val size_1_1 = 4L
    @ghost val size_1_2 = 8L
    @ghost val size_1_3 = 8L
    @ghost val size_1_4 = 16L
    @ghost val size_1_5 = 16L
    @ghost val size_1_6 = dataWithSecondaryHeader.secondaryHeader.time.size(codec_0_1.base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5)
    @ghost val size_0 = size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5 + size_1_6
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Encode data */
    TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_data_ACN_Encode(codec, pVal, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID, dataWithSecondaryHeader.data) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 38L, 15L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 131L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = dataWithSecondaryHeader.data match {
        case TTM_Payload.tm_255_255_PRESENT(tm_255_255) =>
            alignedSizeToByte(8L, codec_0_2.base.bitStream.bitIndex)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_packetErrorControl_Optional_ACN_Encode(codec, pVal, dataWithSecondaryHeader.packetErrorControl) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 154L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_2 = dataWithSecondaryHeader.packetErrorControl match {
        case SomeMut(v) =>
            alignedSizeToByte(16L, codec_0_3.base.bitStream.bitIndex)
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 154L)
    }
    Right[Int, (Int, ULong, ULong)]((0, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID))
}.ensuring { (res: Either[Int, (Int, ULong, ULong)]) => 
    res match {
        case Left(_) =>
            true
        case Right((_, acn1, acn2)) =>
            val size_2_0 = 0L
            val size_2_1 = 4L
            val size_2_2 = 8L
            val size_2_3 = 8L
            val size_2_4 = 16L
            val size_2_5 = 16L
            val size_2_6 = dataWithSecondaryHeader.secondaryHeader.time.size(old(codec).base.bitStream.bitIndex + size_2_0 + size_2_1 + size_2_2 + size_2_3 + size_2_4 + size_2_5)
            val size_1_0 = size_2_0 + size_2_1 + size_2_2 + size_2_3 + size_2_4 + size_2_5 + size_2_6
            val size_1_1 = dataWithSecondaryHeader.data match {
                case TTM_Payload.tm_255_255_PRESENT(tm_255_255) =>
                    alignedSizeToByte(8L, old(codec).base.bitStream.bitIndex + size_1_0)
            }
            val size_1_2 = dataWithSecondaryHeader.packetErrorControl match {
                case SomeMut(v) =>
                    alignedSizeToByte(16L, old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1)
                case NoneMut() =>
                    0L
            }
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2
    }
}

@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_dataNoSecondaryHeader_packetErrorControl_Optional_ACN_Encode(codec: ACN, pVal: TTM_CCSDS_Packet, packetErrorControl: OptionMut[TPacketErrorControl]): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    @ghost val oldCdc = snapshot(codec)
    /* Encode packetErrorControl */
    /* marked as ALWAYS PRESENT, so it must be Some */
    packetErrorControl match
        case SomeMut(packetErrorControl) =>
            locally {
                @ghost val unalignedCodec = snapshot(codec)
                codec.base.bitStream.alignToByte()
                ghostExpr {
                    BitStream.validateOffsetBitsIneqLemma(unalignedCodec.base.bitStream, codec.base.bitStream, 23, 7L)
                    check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 0L + 7L)
                }
            }
            assert(16.toInt >= 0) // overflow may happen during cast
            codec.base.bitStream.appendBitsMSBFirstVec(packetErrorControl.arr, 16.toInt)
    
        case NoneMut() => return Left(628)
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + alignedSizeToByte(16L, old(codec).base.bitStream.bitIndex)
    }
}



@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_dataNoSecondaryHeader_ACN_Encode(codec: ACN, pVal: TTM_CCSDS_Packet, dataNoSecondaryHeader: TTM_DataNoSecondaryHeader): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    @ghost val oldCdc = snapshot(codec)
    TTM_DataNoSecondaryHeader_IsConstraintValid(dataNoSecondaryHeader) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    @ghost val codec_0_1 = snapshot(codec)
    /* Encode data */
    TTM_NoHeaderPayload_ACN_Encode(dataNoSecondaryHeader.data, codec, false) match // uper:6
        case Right(_) =>
        case Left(err) => return Left(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 23L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    TM_CCSDS_Packet_packetDataField_dataNoSecondaryHeader_packetErrorControl_Optional_ACN_Encode(codec, pVal, dataNoSecondaryHeader.packetErrorControl) match {
        case Left(l) =>
            return Left(l)
        case Right(_) =>
            ()
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 23L)
        check(codec.base.buf.length == oldCdc.base.buf.length)
    }
    @ghost val size_1 = dataNoSecondaryHeader.packetErrorControl match {
        case SomeMut(v) =>
            alignedSizeToByte(16L, codec_0_2.base.bitStream.bitIndex)
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 23L)
    }
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            val size_1_0 = 0L
            val size_1_1 = dataNoSecondaryHeader.packetErrorControl match {
                case SomeMut(v) =>
                    alignedSizeToByte(16L, old(codec).base.bitStream.bitIndex + size_1_0)
                case NoneMut() =>
                    0L
            }
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1
    }
}

@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_ACN_Encode(codec: ACN, pVal: TTM_CCSDS_Packet, TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag: ULong, packetDataField: TTM_PacketDataField): Either[Int, Int] = {
    require(codec.base.bitStream.validate_offset_bits(154L))
    @ghost val oldCdc = snapshot(codec)
    TTM_PacketDataField_IsConstraintValid(packetDataField) match {
        case Left(l) =>
            return Left[Int, Int](l)
        case Right(_) =>
    }
    packetDataField match
        case TTM_PacketDataField.TM_PacketDataField_dataWithSecondaryHeader_PRESENT(dataWithSecondaryHeader) =>
            val res_dataWithSecondaryHeader = TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_ACN_Encode(codec, pVal, dataWithSecondaryHeader) match {
                case Left(l) =>
                    return Left(l)
                case Right((_, v1, v2)) =>
                    (v1, v2)
            }
            val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID = res_dataWithSecondaryHeader._1
            val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID = res_dataWithSecondaryHeader._2
        case TTM_PacketDataField.TM_PacketDataField_dataNoSecondaryHeader_PRESENT(dataNoSecondaryHeader) =>
            TM_CCSDS_Packet_packetDataField_dataNoSecondaryHeader_ACN_Encode(codec, pVal, dataNoSecondaryHeader) match {
                case Left(l) =>
                    return Left(l)
                case Right(_) =>
                    ()
            }
    Right[Int, Int](0)
}.ensuring { (res: Either[Int, Int]) => 
    res match {
        case Left(_) =>
            true
        case Right(_) =>
            old(codec).base.buf.length == codec.base.buf.length && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + packetDataField.size(old(codec).base.bitStream.bitIndex)
    }
}

@opaque @inlineOnce 
def TTM_CCSDS_Packet_ACN_Decode(codec: ACN): EitherMut[ErrorCode, TTM_CCSDS_Packet] =
{
    require(codec.base.bitStream.validate_offset_bits(202L))

    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode packetVersionNumber */
    val pVal_packetVersionNumber = TPacketVersionNumberValue_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 202L, 3L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 3L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 3L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode packet_ID */
    val pVal_packet_ID_tuple = TM_CCSDS_Packet_packet_ID_ACN_Decode(codec) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    val pVal_packet_ID = pVal_packet_ID_tuple._1
    val TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag = pVal_packet_ID_tuple._2
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 199L, 13L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 16L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1_1 = 1L
    @ghost val size_1_2 = 1L
    @ghost val size_1_3 = 11L
    @ghost val size_1 = size_1_1 + size_1_2 + size_1_3
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Decode packetSequenceControl */
    val pVal_packetSequenceControl = TPacketSequenceControl_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 186L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 32L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = pVal_packetSequenceControl.size(codec_0_3.base.bitStream.bitIndex)
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Decode packetDataLength */
    val pVal_packetDataLength = TPacketDataLength_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 170L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 48L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_3 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Decode packetDataField */
    val pVal_packetDataField = TM_CCSDS_Packet_packetDataField_ACN_Decode(codec, TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 202L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_4 = pVal_packetDataField match {
        case TTM_PacketDataField.TM_PacketDataField_dataWithSecondaryHeader_PRESENT(dataWithSecondaryHeader) =>
            val size_3_4 = 0L
            val size_3_5 = 4L
            val size_3_6 = 8L
            val size_3_7 = 8L
            val size_3_8 = 16L
            val size_3_9 = 16L
            val size_3_10 = dataWithSecondaryHeader.secondaryHeader.time.size(codec_0_5.base.bitStream.bitIndex + size_3_4 + size_3_5 + size_3_6 + size_3_7 + size_3_8 + size_3_9)
            val size_2_4 = size_3_4 + size_3_5 + size_3_6 + size_3_7 + size_3_8 + size_3_9 + size_3_10
            val size_2_5 = dataWithSecondaryHeader.data match {
                case TTM_Payload.tm_255_255_PRESENT(tm_255_255) =>
                    alignedSizeToByte(8L, codec_0_5.base.bitStream.bitIndex + size_2_4)
            }
            val size_2_6 = dataWithSecondaryHeader.packetErrorControl match {
                case SomeMut(v) =>
                    alignedSizeToByte(16L, codec_0_5.base.bitStream.bitIndex + size_2_4 + size_2_5)
                case NoneMut() =>
                    0L
            }
            size_2_4 + size_2_5 + size_2_6
        case TTM_PacketDataField.TM_PacketDataField_dataNoSecondaryHeader_PRESENT(dataNoSecondaryHeader) =>
            val size_2_4 = 0L
            val size_2_5 = dataNoSecondaryHeader.packetErrorControl match {
                case SomeMut(v) =>
                    alignedSizeToByte(16L, codec_0_5.base.bitStream.bitIndex + size_2_4)
                case NoneMut() =>
                    0L
            }
            size_2_4 + size_2_5
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 202L)
    }
    val pVal = TTM_CCSDS_Packet(pVal_packetVersionNumber, pVal_packet_ID, pVal_packetSequenceControl, pVal_packetDataLength, pVal_packetDataField)
    ghostExpr {
        check(pVal.size(oldCdc.base.bitStream.bitIndex) == size_0 + size_1 + size_2 + size_3 + size_4)
    }

    TTM_CCSDS_Packet_IsConstraintValid(pVal) match
        case Left(l) => LeftMut[ErrorCode, TTM_CCSDS_Packet](l)
        case Right(_) => RightMut[ErrorCode, TTM_CCSDS_Packet](pVal)
}.ensuring { (res : EitherMut[ErrorCode, TTM_CCSDS_Packet]) =>
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TTM_CCSDS_Packet_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure 
def TTM_CCSDS_Packet_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[ErrorCode, TTM_CCSDS_Packet]) =
{
    require(codec.base.bitStream.validate_offset_bits(202L))
    val cpy = snapshot(codec)
    val res = TTM_CCSDS_Packet_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def TM_CCSDS_Packet_packet_ID_ACN_Decode(codec: ACN): EitherMut[Int, (TTM_Packet_ID, ULong)] = {
    require(codec.base.bitStream.validate_offset_bits(13L))
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode packetType */
    val packet_ID_packetType = TTM_PacketType_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 13L, 1L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 1L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 1L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag */
    val TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag = codec.dec_Int_PositiveInteger_ConstSize(1)
    
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 12L, 1L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 2L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 1L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Decode applicationProcess_ID */
    val packet_ID_applicationProcess_ID = TApplicationProcess_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 13L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = 11L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 13L)
    }
    val packet_ID = TTM_Packet_ID(packet_ID_packetType, packet_ID_applicationProcess_ID)
    TTM_Packet_ID_IsConstraintValid(packet_ID) match {
        case Left(l) =>
            LeftMut[Int, (TTM_Packet_ID, ULong)](l)
        case Right(_) =>
            RightMut[Int, (TTM_Packet_ID, ULong)]((packet_ID, TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag))
    }
}.ensuring { (res: EitherMut[Int, (TTM_Packet_ID, ULong)]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut((resVal, _)) =>
            val size_1_0 = 1L
            val size_1_1 = 1L
            val size_1_2 = 11L
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 && TTM_Packet_ID_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def TM_CCSDS_Packet_packet_ID_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, (TTM_Packet_ID, ULong)]) = {
    require(codec.base.bitStream.validate_offset_bits(13L))
    val cpy = snapshot(codec)
    val res = TM_CCSDS_Packet_packet_ID_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_ACN_Decode(codec: ACN): EitherMut[Int, (TTM_PacketSecondaryHeader, ULong, ULong)] = {
    require(codec.base.bitStream.validate_offset_bits(116L))
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode tmPacketPusVersionNumber */
    val secondaryHeader_tmPacketPusVersionNumber: NullType = 0
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 116L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode spacecraftTimeReferenceStatus */
    val secondaryHeader_spacecraftTimeReferenceStatus = TSpacecraftTimeReferenceStatus_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 116L, 4L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 4L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = 4L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    /* Decode TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID */
    val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID = codec.dec_Int_PositiveInteger_ConstSize_8()
    
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_3.base.bitStream, codec.base.bitStream, 112L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 12L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    @ghost val codec_0_4 = snapshot(codec)
    /* Decode TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID */
    val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID = codec.dec_Int_PositiveInteger_ConstSize_8()
    
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_4.base.bitStream, codec.base.bitStream, 104L, 8L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 20L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_3 = 8L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3)
    }
    @ghost val codec_0_5 = snapshot(codec)
    /* Decode messageTypeCounter */
    val secondaryHeader_messageTypeCounter = codec.dec_Int_PositiveInteger_ConstSize_big_endian_16()
    
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_5.base.bitStream, codec.base.bitStream, 96L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 36L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_4 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4)
    }
    @ghost val codec_0_6 = snapshot(codec)
    /* Decode destination_ID */
    val secondaryHeader_destination_ID = TApplicationProcessUser_ID_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_6.base.bitStream, codec.base.bitStream, 80L, 16L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 52L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_5 = 16L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5)
    }
    @ghost val codec_0_7 = snapshot(codec)
    /* Decode time */
    val secondaryHeader_time = TCDS_AbsoluteTime_PFC_2_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 116L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_6 = secondaryHeader_time.size(codec_0_7.base.bitStream.bitIndex)
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2 + size_3 + size_4 + size_5 + size_6)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 116L)
    }
    val secondaryHeader = TTM_PacketSecondaryHeader(secondaryHeader_tmPacketPusVersionNumber, secondaryHeader_spacecraftTimeReferenceStatus, secondaryHeader_messageTypeCounter, secondaryHeader_destination_ID, secondaryHeader_time)
    TTM_PacketSecondaryHeader_IsConstraintValid(secondaryHeader) match {
        case Left(l) =>
            LeftMut[Int, (TTM_PacketSecondaryHeader, ULong, ULong)](l)
        case Right(_) =>
            RightMut[Int, (TTM_PacketSecondaryHeader, ULong, ULong)]((secondaryHeader, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID))
    }
}.ensuring { (res: EitherMut[Int, (TTM_PacketSecondaryHeader, ULong, ULong)]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut((resVal, _, _)) =>
            val size_1_0 = 0L
            val size_1_1 = 4L
            val size_1_2 = 8L
            val size_1_3 = 8L
            val size_1_4 = 16L
            val size_1_5 = 16L
            val size_1_6 = resVal.time.size(old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5)
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5 + size_1_6 && TTM_PacketSecondaryHeader_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, (TTM_PacketSecondaryHeader, ULong, ULong)]) = {
    require(codec.base.bitStream.validate_offset_bits(116L))
    val cpy = snapshot(codec)
    val res = TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_data_ACN_Decode(codec: ACN, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID: ULong, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID: ULong): EitherMut[Int, TTM_Payload] = {
    require(codec.base.bitStream.validate_offset_bits(15L))
    @ghost val oldCdc = snapshot(codec)
    locally {
        @ghost val unalignedCodec = snapshot(codec)
        codec.base.bitStream.alignToByte()
        ghostExpr {
            BitStream.validateOffsetBitsIneqLemma(unalignedCodec.base.bitStream, codec.base.bitStream, 15, 7L)
            check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 0L + 7L)
        }
    }
    val data = if ((TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID == ULong.fromRaw(255)) && (TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID == ULong.fromRaw(255))) {
        locally {
            ghostExpr {
                @opaque @inlineOnce
                def bitCountLemma(): Unit = ().ensuring(_ => GetBitCountUnsigned(ULong.fromRaw(255) - ULong.fromRaw(0)) == 8)
                bitCountLemma()
            }
        }
        val tm_255_255 = codec.base.decodeConstrainedPosWholeNumber(ULong.fromRaw(0), ULong.fromRaw(255)) // uper:135
        TTM_Payload.tm_255_255_PRESENT(tm_255_255)
    }
    else return LeftMut(ERR_ACN_DECODE_TM_CCSDS_PACKET_PACKETDATAFIELD_DATAWITHSECONDARYHEADER_DATA)
    TTM_Payload_IsConstraintValid(data) match {
        case Left(l) =>
            LeftMut[Int, TTM_Payload](l)
        case Right(_) =>
            RightMut[Int, TTM_Payload](data)
    }
}.ensuring { (res: EitherMut[Int, TTM_Payload]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TTM_Payload_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_data_ACN_Decode_pure(codec: ACN, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID: ULong, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID: ULong): (ACN, EitherMut[Int, TTM_Payload]) = {
    require(codec.base.bitStream.validate_offset_bits(15L))
    val cpy = snapshot(codec)
    val res = TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_data_ACN_Decode(cpy, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID)
    (cpy, res)
}

@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_packetErrorControl_Optional_ACN_Decode(codec: ACN): EitherMut[Int, OptionMut[TPacketErrorControl]] = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    @ghost val oldCdc = snapshot(codec)
    /* Decode packetErrorControl */
    /* marked as ALWAYS PRESENT */
    val packetErrorControl: OptionMut[TPacketErrorControl] =
        locally {
            @ghost val unalignedCodec = snapshot(codec)
            codec.base.bitStream.alignToByte()
            ghostExpr {
                BitStream.validateOffsetBitsIneqLemma(unalignedCodec.base.bitStream, codec.base.bitStream, 23, 7L)
                check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 131L + 7L)
            }
        }
        val dataWithSecondaryHeader_packetErrorControl = TPacketErrorControl(codec.base.bitStream.readBitsVec(16.toInt))
        SomeMut(dataWithSecondaryHeader_packetErrorControl)
    RightMut[Int, OptionMut[TPacketErrorControl]](packetErrorControl)
}.ensuring { (res: EitherMut[Int, OptionMut[TPacketErrorControl]]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            resVal.isDefined && old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + alignedSizeToByte(16L, old(codec).base.bitStream.bitIndex)
    }
}



@ghost @pure
def TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_packetErrorControl_Optional_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, OptionMut[TPacketErrorControl]]) = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    val cpy = snapshot(codec)
    val res = TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_packetErrorControl_Optional_ACN_Decode(cpy)
    (cpy, res)
}



@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_ACN_Decode(codec: ACN): EitherMut[Int, (TTM_DataWithSecondaryHeader, ULong, ULong)] = {
    require(codec.base.bitStream.validate_offset_bits(154L))
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode secondaryHeader */
    val dataWithSecondaryHeader_secondaryHeader_tuple = TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_ACN_Decode(codec) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    val dataWithSecondaryHeader_secondaryHeader = dataWithSecondaryHeader_secondaryHeader_tuple._1
    val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID = dataWithSecondaryHeader_secondaryHeader_tuple._2
    val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID = dataWithSecondaryHeader_secondaryHeader_tuple._3
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 154L, 116L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 116L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1_0 = 0L
    @ghost val size_1_1 = 4L
    @ghost val size_1_2 = 8L
    @ghost val size_1_3 = 8L
    @ghost val size_1_4 = 16L
    @ghost val size_1_5 = 16L
    @ghost val size_1_6 = dataWithSecondaryHeader_secondaryHeader.time.size(codec_0_1.base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5)
    @ghost val size_0 = size_1_0 + size_1_1 + size_1_2 + size_1_3 + size_1_4 + size_1_5 + size_1_6
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    /* Decode data */
    val dataWithSecondaryHeader_data = TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_data_ACN_Decode(codec, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_2.base.bitStream, codec.base.bitStream, 38L, 15L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 131L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = dataWithSecondaryHeader_data match {
        case TTM_Payload.tm_255_255_PRESENT(tm_255_255) =>
            alignedSizeToByte(8L, codec_0_2.base.bitStream.bitIndex)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    @ghost val codec_0_3 = snapshot(codec)
    val dataWithSecondaryHeader_packetErrorControl = TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_packetErrorControl_Optional_ACN_Decode(codec) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 154L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_2 = dataWithSecondaryHeader_packetErrorControl match {
        case SomeMut(v) =>
            alignedSizeToByte(16L, codec_0_3.base.bitStream.bitIndex)
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1 + size_2)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 154L)
    }
    val dataWithSecondaryHeader = TTM_DataWithSecondaryHeader(dataWithSecondaryHeader_secondaryHeader, dataWithSecondaryHeader_data, dataWithSecondaryHeader_packetErrorControl)
    TTM_DataWithSecondaryHeader_IsConstraintValid(dataWithSecondaryHeader) match {
        case Left(l) =>
            LeftMut[Int, (TTM_DataWithSecondaryHeader, ULong, ULong)](l)
        case Right(_) =>
            RightMut[Int, (TTM_DataWithSecondaryHeader, ULong, ULong)]((dataWithSecondaryHeader, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID, TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID))
    }
}.ensuring { (res: EitherMut[Int, (TTM_DataWithSecondaryHeader, ULong, ULong)]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut((resVal, _, _)) =>
            val size_2_0 = 0L
            val size_2_1 = 4L
            val size_2_2 = 8L
            val size_2_3 = 8L
            val size_2_4 = 16L
            val size_2_5 = 16L
            val size_2_6 = resVal.secondaryHeader.time.size(old(codec).base.bitStream.bitIndex + size_2_0 + size_2_1 + size_2_2 + size_2_3 + size_2_4 + size_2_5)
            val size_1_0 = size_2_0 + size_2_1 + size_2_2 + size_2_3 + size_2_4 + size_2_5 + size_2_6
            val size_1_1 = resVal.data match {
                case TTM_Payload.tm_255_255_PRESENT(tm_255_255) =>
                    alignedSizeToByte(8L, old(codec).base.bitStream.bitIndex + size_1_0)
            }
            val size_1_2 = resVal.packetErrorControl match {
                case SomeMut(v) =>
                    alignedSizeToByte(16L, old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1)
                case NoneMut() =>
                    0L
            }
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 + size_1_2 && TTM_DataWithSecondaryHeader_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, (TTM_DataWithSecondaryHeader, ULong, ULong)]) = {
    require(codec.base.bitStream.validate_offset_bits(154L))
    val cpy = snapshot(codec)
    val res = TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_dataNoSecondaryHeader_packetErrorControl_Optional_ACN_Decode(codec: ACN): EitherMut[Int, OptionMut[TPacketErrorControl]] = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    @ghost val oldCdc = snapshot(codec)
    /* Decode packetErrorControl */
    /* marked as ALWAYS PRESENT */
    val packetErrorControl: OptionMut[TPacketErrorControl] =
        locally {
            @ghost val unalignedCodec = snapshot(codec)
            codec.base.bitStream.alignToByte()
            ghostExpr {
                BitStream.validateOffsetBitsIneqLemma(unalignedCodec.base.bitStream, codec.base.bitStream, 23, 7L)
                check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 0L + 7L)
            }
        }
        val dataNoSecondaryHeader_packetErrorControl = TPacketErrorControl(codec.base.bitStream.readBitsVec(16.toInt))
        SomeMut(dataNoSecondaryHeader_packetErrorControl)
    RightMut[Int, OptionMut[TPacketErrorControl]](packetErrorControl)
}.ensuring { (res: EitherMut[Int, OptionMut[TPacketErrorControl]]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            resVal.isDefined && old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + alignedSizeToByte(16L, old(codec).base.bitStream.bitIndex)
    }
}



@ghost @pure
def TM_CCSDS_Packet_packetDataField_dataNoSecondaryHeader_packetErrorControl_Optional_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, OptionMut[TPacketErrorControl]]) = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    val cpy = snapshot(codec)
    val res = TM_CCSDS_Packet_packetDataField_dataNoSecondaryHeader_packetErrorControl_Optional_ACN_Decode(cpy)
    (cpy, res)
}



@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_dataNoSecondaryHeader_ACN_Decode(codec: ACN): EitherMut[Int, TTM_DataNoSecondaryHeader] = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    @ghost val oldCdc = snapshot(codec)
    @ghost val codec_0_1 = snapshot(codec)
    /* Decode data */
    val dataNoSecondaryHeader_data = TTM_NoHeaderPayload_ACN_Decode(codec) match // uper:13
        case RightMut(decData) => decData
        case LeftMut(err) => return LeftMut(err)
    ghostExpr {
        BitStream.validateOffsetBitsIneqLemma(codec_0_1.base.bitStream, codec.base.bitStream, 23L, 0L)
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_0 = 0L
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0)
    }
    @ghost val codec_0_2 = snapshot(codec)
    val dataNoSecondaryHeader_packetErrorControl = TM_CCSDS_Packet_packetDataField_dataNoSecondaryHeader_packetErrorControl_Optional_ACN_Decode(codec) match {
        case LeftMut(l) =>
            return LeftMut(l)
        case RightMut(v) =>
            v
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= oldCdc.base.bitStream.bitIndex + 23L)
        check(codec.base.buf == oldCdc.base.buf)
    }
    @ghost val size_1 = dataNoSecondaryHeader_packetErrorControl match {
        case SomeMut(v) =>
            alignedSizeToByte(16L, codec_0_2.base.bitStream.bitIndex)
        case NoneMut() =>
            0L
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex == oldCdc.base.bitStream.bitIndex + size_0 + size_1)
    }
    ghostExpr {
        check(codec.base.bitStream.bitIndex <= codec_0_1.base.bitStream.bitIndex + 23L)
    }
    val dataNoSecondaryHeader = TTM_DataNoSecondaryHeader(dataNoSecondaryHeader_data, dataNoSecondaryHeader_packetErrorControl)
    TTM_DataNoSecondaryHeader_IsConstraintValid(dataNoSecondaryHeader) match {
        case Left(l) =>
            LeftMut[Int, TTM_DataNoSecondaryHeader](l)
        case Right(_) =>
            RightMut[Int, TTM_DataNoSecondaryHeader](dataNoSecondaryHeader)
    }
}.ensuring { (res: EitherMut[Int, TTM_DataNoSecondaryHeader]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            val size_1_0 = 0L
            val size_1_1 = resVal.packetErrorControl match {
                case SomeMut(v) =>
                    alignedSizeToByte(16L, old(codec).base.bitStream.bitIndex + size_1_0)
                case NoneMut() =>
                    0L
            }
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + size_1_0 + size_1_1 && TTM_DataNoSecondaryHeader_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def TM_CCSDS_Packet_packetDataField_dataNoSecondaryHeader_ACN_Decode_pure(codec: ACN): (ACN, EitherMut[Int, TTM_DataNoSecondaryHeader]) = {
    require(codec.base.bitStream.validate_offset_bits(23L))
    val cpy = snapshot(codec)
    val res = TM_CCSDS_Packet_packetDataField_dataNoSecondaryHeader_ACN_Decode(cpy)
    (cpy, res)
}

@opaque @inlineOnce
def TM_CCSDS_Packet_packetDataField_ACN_Decode(codec: ACN, TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag: ULong): EitherMut[Int, TTM_PacketDataField] = {
    require(codec.base.bitStream.validate_offset_bits(154L))
    @ghost val oldCdc = snapshot(codec)
    val packetDataField = if ((TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag == ULong.fromRaw(1))) {
        val dataWithSecondaryHeader_tuple = TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_ACN_Decode(codec) match {
            case LeftMut(l) =>
                return LeftMut(l)
            case RightMut(v) =>
                v
        }
        val dataWithSecondaryHeader = dataWithSecondaryHeader_tuple._1
        val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_serviceType_ID = dataWithSecondaryHeader_tuple._2
        val TM_CCSDS_Packet_packetDataField_dataWithSecondaryHeader_secondaryHeader_messageSubtype_ID = dataWithSecondaryHeader_tuple._3
        TTM_PacketDataField.TM_PacketDataField_dataWithSecondaryHeader_PRESENT(dataWithSecondaryHeader)
    }
    else if ((TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag == ULong.fromRaw(0))) {
        val dataNoSecondaryHeader = TM_CCSDS_Packet_packetDataField_dataNoSecondaryHeader_ACN_Decode(codec) match {
            case LeftMut(l) =>
                return LeftMut(l)
            case RightMut(v) =>
                v
        }
        TTM_PacketDataField.TM_PacketDataField_dataNoSecondaryHeader_PRESENT(dataNoSecondaryHeader)
    }
    else return LeftMut(ERR_ACN_DECODE_TM_CCSDS_PACKET_PACKETDATAFIELD)
    TTM_PacketDataField_IsConstraintValid(packetDataField) match {
        case Left(l) =>
            LeftMut[Int, TTM_PacketDataField](l)
        case Right(_) =>
            RightMut[Int, TTM_PacketDataField](packetDataField)
    }
}.ensuring { (res: EitherMut[Int, TTM_PacketDataField]) => 
    res match {
        case LeftMut(_) =>
            true
        case RightMut(resVal) =>
            old(codec).base.buf == codec.base.buf && codec.base.bitStream.bitIndex == old(codec).base.bitStream.bitIndex + resVal.size(old(codec).base.bitStream.bitIndex) && TTM_PacketDataField_IsConstraintValid(resVal).isRight
    }
}

@ghost @pure
def TM_CCSDS_Packet_packetDataField_ACN_Decode_pure(codec: ACN, TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag: ULong): (ACN, EitherMut[Int, TTM_PacketDataField]) = {
    require(codec.base.bitStream.validate_offset_bits(154L))
    val cpy = snapshot(codec)
    val res = TM_CCSDS_Packet_packetDataField_ACN_Decode(cpy, TM_CCSDS_Packet_packet_ID_secondaryHeaderFlag)
    (cpy, res)
}